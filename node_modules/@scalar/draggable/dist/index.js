import { ref as b, defineComponent as T, computed as v, openBlock as Y, createElementBlock as w, normalizeClass as y, withModifiers as m, unref as D, renderSlot as B } from "vue";
const r = b(null), n = b(null), C = (d, f) => {
  let l = !1;
  return function(...t) {
    l || (d(...t), l = !0, setTimeout(() => l = !1, f));
  };
}, L = ["draggable"], A = /* @__PURE__ */ T({
  __name: "Draggable",
  props: {
    ceiling: { default: 0.8 },
    floor: { default: 0.2 },
    isDraggable: { type: Boolean, default: !0 },
    isDroppable: { type: [Boolean, Function], default: !0 },
    parentIds: {},
    id: {}
  },
  emits: ["onDragEnd", "onDragStart"],
  setup(d, { expose: f, emit: l }) {
    const t = d, u = l, i = v(
      () => (t.parentIds.length ?? 0) > 0 ? t.parentIds[t.parentIds.length - 1] : null
    ), I = (e) => {
      !e.dataTransfer || !(e.target instanceof HTMLElement) || !t.isDraggable || (e.target.classList.add("dragging"), e.dataTransfer.dropEffect = "move", e.dataTransfer.effectAllowed = "move", r.value = { id: t.id, parentId: i.value }, u("onDragStart", { id: t.id, parentId: i.value }));
    }, h = (e) => typeof t.isDroppable == "function" ? t.isDroppable(r.value, {
      id: t.id,
      parentId: i.value,
      offset: e
    }) : t.isDroppable, g = C((e) => {
      if (!r.value || r.value.id === t.id || t.parentIds.includes(r.value?.id ?? ""))
        return;
      const a = n.value?.offset, o = e.target.offsetHeight, c = t.floor * o, p = t.ceiling * o;
      let s = 3;
      e.offsetY <= 0 && a && a !== 3 ? s = a : e.offsetY <= c ? s = 0 : e.offsetY >= p ? s = 1 : e.offsetY > c && e.offsetY < p && (s = 2), h(s) && (n.value = { id: t.id, parentId: i.value, offset: s });
    }, 25), E = ["above", "below", "asChild"], _ = v(() => {
      let e = "sidebar-indent-nested";
      return t.id === n.value?.id && (e += ` dragover-${E[n.value.offset]}`), e;
    }), S = () => {
      if (!n.value || !r.value) return;
      const e = { ...r.value }, a = { ...n.value };
      r.value = null, n.value = null, document.querySelectorAll("div.dragging").forEach((o) => o.classList.remove("dragging")), e.id !== a.id && u("onDragEnd", e, a);
    };
    return f({
      draggingItem: r,
      hoveredItem: n
    }), (e, a) => (Y(), w("div", {
      class: y(_.value),
      draggable: e.isDraggable,
      onDragend: S,
      onDragover: a[0] || (a[0] = m(
        //@ts-ignore
        (...o) => D(g) && D(g)(...o),
        ["prevent", "stop"]
      )),
      onDragstart: m(I, ["stop"])
    }, [
      B(e.$slots, "default")
    ], 42, L));
  }
});
export {
  A as Draggable
};
