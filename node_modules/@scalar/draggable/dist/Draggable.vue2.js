import { defineComponent as S, computed as g, createElementBlock as Y, openBlock as y, withModifiers as c, normalizeClass as B, unref as v, renderSlot as C } from "vue";
import { hoveredItem as r, draggingItem as n } from "./store.js";
import { throttle as L } from "./throttle.js";
const T = ["draggable"], H = /* @__PURE__ */ S({
  __name: "Draggable",
  props: {
    ceiling: { default: 0.8 },
    floor: { default: 0.2 },
    isDraggable: { type: Boolean, default: !0 },
    isDroppable: { type: [Boolean, Function], default: !0 },
    parentIds: {},
    id: {}
  },
  emits: ["onDragEnd", "onDragStart"],
  setup(t, { expose: m, emit: D }) {
    const d = D, l = g(() => t.parentIds.at(-1) ?? null), b = (e) => {
      !e.dataTransfer || !(e.target instanceof HTMLElement) || !t.isDraggable || (e.target.classList.add("dragging"), e.dataTransfer.dropEffect = "move", e.dataTransfer.effectAllowed = "move", n.value = { id: t.id, parentId: l.value }, d("onDragStart", { id: t.id, parentId: l.value }));
    }, p = (e) => typeof t.isDroppable == "function" ? t.isDroppable(n.value, {
      id: t.id,
      parentId: l.value,
      offset: e
    }) : t.isDroppable, s = L((e) => {
      if (!n.value || n.value.id === t.id || t.parentIds.includes(n.value?.id ?? ""))
        return;
      const a = r.value?.offset, o = e.target.offsetHeight, f = t.floor * o, u = t.ceiling * o;
      let i = 3;
      e.offsetY <= 0 && a && a !== 3 ? i = a : e.offsetY <= f ? i = 0 : e.offsetY >= u ? i = 1 : e.offsetY > f && e.offsetY < u && (i = 2), p(i) && (r.value = { id: t.id, parentId: l.value, offset: i });
    }, 25), I = ["above", "below", "asChild"], h = g(() => {
      let e = "sidebar-indent-nested";
      return t.id === r.value?.id && (e += ` dragover-${I[r.value.offset]}`), e;
    }), E = () => {
      if (!r.value || !n.value)
        return;
      const e = { ...n.value }, a = { ...r.value };
      n.value = null, r.value = null, document.querySelectorAll("div.dragging").forEach((o) => o.classList.remove("dragging")), e.id !== a.id && d("onDragEnd", e, a);
    };
    return m({
      draggingItem: n,
      hoveredItem: r
    }), (e, a) => (y(), Y("div", {
      class: B(h.value),
      draggable: e.isDraggable,
      onDragend: E,
      onDragover: a[0] || (a[0] = c(
        //@ts-ignore
        (...o) => v(s) && v(s)(...o),
        ["prevent", "stop"]
      )),
      onDragstart: c(b, ["stop"])
    }, [
      C(e.$slots, "default", {}, void 0, !0)
    ], 42, T));
  }
});
export {
  H as default
};
