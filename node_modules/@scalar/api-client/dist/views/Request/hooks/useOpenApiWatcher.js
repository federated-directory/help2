import { fetchDocument as A, createHash as y } from "@scalar/oas-utils/helpers";
import { parseSchema as l } from "@scalar/oas-utils/transforms";
import { useToasts as E } from "@scalar/use-toasts";
import { useTimeoutPoll as D } from "@vueuse/core";
import R from "microdiff";
import { watch as g } from "vue";
import { useActiveEntities as S } from "../../../store/active-entities.js";
import { specDictionary as f } from "../../../store/import-spec.js";
import { combineRenameDiffs as T, mutateCollectionDiff as M, mutateSecuritySchemeDiff as I, mutateServerDiff as C, mutateTagDiff as L, mutateRequestDiff as N } from "../libs/watch-mode.js";
import { useWorkspace as U } from "../../../store/store.js";
const b = 5 * 1e3, P = 60 * 1e3, B = () => {
  const { toast: h } = E(), c = S(), o = U(), { activeCollection: s, activeWorkspace: v } = c, { collectionMutators: n } = o, i = (e) => h(`[useOpenApiWatcher] Changes to the ${e} were not applied`, "error"), O = (e) => {
    e.path[0] === "info" || e.path[0] === "security" ? M(e, c, o) || i("collection") : e.path[0] === "components" && e.path[1] === "securitySchemes" ? I(e, c, o) || i("securitySchemes") : e.path[0] === "servers" ? C(e, c, o) || i("servers") : e.path[0] === "tags" ? L(e, c, o) || i("tags") : e.path[0] === "paths" && (N(e, c, o) || i("requests"));
  }, { pause: p, resume: m } = D(async () => {
    const e = s.value?.documentUrl;
    if (!e)
      return;
    const t = f[e];
    try {
      const a = await A(e, v.value?.proxyUrl, void 0, !1), u = y(a);
      if (n.edit(s.value.uid, "watchModeStatus", "WATCHING"), t?.hash)
        if (t.hash && t.hash !== u) {
          const { schema: r } = await l(a), W = R(t.schema, r), d = T(W);
          try {
            d.forEach(O), f[e] = {
              hash: u,
              schema: r
            };
          } catch (w) {
            console.error("[useOpenApiWatcher] Error:", w);
          }
        } else
          console.log("[useOpenApiWatcher] No changes detected yet…");
      else {
        const { schema: r } = await l(a);
        r && (f[e] = {
          hash: u,
          schema: r
        });
      }
    } catch (a) {
      console.error("[useOpenApiWatcher] Error:", a), console.info("[useOpenApiWatcher] Pausing watcher for 60 seconds"), p(), n.edit(s.value.uid, "watchModeStatus", "ERROR"), h("[useOpenApiWatcher] Unable to fetch the spec file, paused the watcher for 60 seconds", "error"), setTimeout(() => {
        console.info("[useOpenApiWatcher] Resuming watcher"), m();
      }, P);
    }
  }, b);
  g(
    [() => s.value?.documentUrl, () => s.value?.watchMode],
    ([e, t]) => {
      e && t ? (console.info(`[useOpenApiWatcher] Watching ${e} …`), m()) : s.value && (p(), n.edit(s.value.uid, "watchModeStatus", "IDLE"));
    },
    { immediate: !0 }
  );
};
export {
  B as useOpenApiWatcher
};
