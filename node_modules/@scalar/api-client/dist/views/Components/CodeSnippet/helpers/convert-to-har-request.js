import { mergeUrls as g } from "@scalar/oas-utils/helpers";
const v = ({
  baseUrl: l = "",
  method: s,
  body: a,
  path: c,
  cookies: p,
  headers: n,
  query: m
}) => {
  const f = g(l, c, void 0, !0), r = {
    method: s.toUpperCase(),
    url: f.toString(),
    httpVersion: "HTTP/1.1",
    headers: [],
    queryString: [],
    cookies: [],
    headersSize: -1,
    bodySize: -1
  };
  if (p.length && (r.cookies = p.filter((e) => e.enabled).map(({ key: e, value: t }) => ({
    name: e,
    value: t
  }))), n.length && (r.headers = n.filter((e) => e.enabled && !(e.key.toLowerCase() === "accept" && e.value === "*/*")).map(({ key: e, value: t }) => ({
    name: e.replace(/\b\w/g, (o) => o.toUpperCase()),
    value: t
  }))), m.length && (r.queryString = m.filter((e) => e.enabled).map(({ key: e, value: t }) => ({
    name: e,
    value: t
  }))), a)
    try {
      const e = n.find((t) => t.key.toLowerCase() === "content-type")?.value;
      if (a.activeBody === "formData" && a.formData) {
        const t = [];
        a.formData.value.forEach(({ key: o, value: u, file: i, enabled: d }) => {
          d && (i ? t.push({
            name: o || "blob",
            value: "BINARY",
            fileName: i.name,
            contentType: i.type || "application/octet-stream"
          }) : t.push({
            name: o,
            value: u
          }));
        }), a.formData?.encoding === "urlencoded" ? r.postData = {
          mimeType: e || "application/x-www-form-urlencoded",
          params: t
        } : r.postData = {
          mimeType: e || "multipart/form-data",
          params: t
        };
      } else a.activeBody === "raw" && a.raw && (r.postData = {
        mimeType: e || "application/json",
        text: a.raw?.value ?? ""
      });
    } catch {
    }
  return r;
};
export {
  v as convertToHarRequest
};
