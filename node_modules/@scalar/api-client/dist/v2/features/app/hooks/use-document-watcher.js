import { computed as g, toValue as l, watch as h, onBeforeUnmount as T } from "vue";
const p = 5 * 1e3, M = 60 * 1e3, E = () => {
  let t = null;
  const e = () => {
    t && (clearTimeout(t), t = null);
  };
  return {
    clear: e,
    schedule: (a, c) => {
      e(), t = setTimeout(a, c);
    }
  };
}, V = (t) => {
  let e = t;
  return {
    reset: () => {
      e = t;
    },
    backoff: () => {
      e = Math.min(e * 2, M);
    },
    get: () => e
  };
}, k = (t) => t.flatMap(([e]) => e), D = ({
  documentName: t,
  store: e,
  initialTimeout: u = p
}) => {
  const a = g(() => {
    const r = l(e), o = l(t);
    return !r || !o ? null : r.workspace.documents[o];
  }), c = E(), n = V(u), f = () => {
    n.reset(), c.schedule(i, n.get());
  }, d = () => {
    n.backoff(), c.schedule(i, n.get());
  }, i = async () => {
    const r = l(e), o = l(t), m = a.value?.["x-scalar-original-source-url"];
    if (!r || !o || !m)
      return;
    const s = await r.rebaseDocument({
      name: o,
      url: m
    });
    s?.ok ? (await s.applyChanges(k(s.conflicts)), f()) : s?.ok === !1 && s.type === "NO_CHANGES_DETECTED" ? f() : d();
  };
  h(
    [() => a.value?.["x-scalar-original-source-url"], () => a.value?.["x-scalar-watch-mode"]],
    ([r, o = !0]) => {
      if (!l(e)) {
        c.clear();
        return;
      }
      if (c.clear(), !r || !o) {
        n.reset();
        return;
      }
      c.schedule(i, n.get());
    },
    { immediate: !0 }
  ), T(() => {
    c.clear();
  });
};
export {
  D as useDocumentWatcher
};
