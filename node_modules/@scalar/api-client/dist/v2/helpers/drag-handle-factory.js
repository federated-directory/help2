import { sortByOrder as B } from "@scalar/helpers/array/sort-by-order";
import { dereference as k, escapeJsonPointer as j } from "@scalar/openapi-parser";
import { unpackProxyObject as x } from "@scalar/workspace-store/helpers/unpack-proxy";
import { getParentEntry as d, getOpenapiObject as h } from "@scalar/workspace-store/navigation";
import { toValue as b } from "vue";
import { removeCircular as A } from "./remove-circular.js";
const P = (r, t, n, a) => {
  if (t === -1 || n === -1 || t === n)
    return null;
  const o = [...r], [e] = o.splice(t, 1);
  if (e === void 0)
    return null;
  const u = R(t, n, a, o.length);
  return o.splice(u, 0, e), x(o, { depth: 1 });
}, R = (r, t, n, a) => {
  const o = r < t;
  return n === "after" ? o ? t : t + 1 : n === "before" ? o ? t - 1 : t : n === "into" ? a : t;
}, y = (r, t) => t.includes(r.type), p = (r) => r.offset === "before" || r.offset === "after", m = (r) => r.offset === "into", l = (r, t) => !r.parent || !t.parent ? !1 : r.parent.id === t.parent.id, O = ({ store: r, entry: t }) => {
  const n = d("document", t);
  n && r.buildSidebar(n.name);
}, M = (r, t) => r["x-scalar-order"] ?? t.children?.map((a) => a.id) ?? [], w = (r, t, n, a) => {
  const o = t.parent;
  if (!o || !y(o, ["tag", "document"]))
    return !1;
  const e = h({ store: r, entry: o });
  if (!e)
    return !1;
  const u = M(e, o), s = u.findIndex((f) => f === t.id), c = u.findIndex((f) => f === n.id), i = P(u, s, c, a);
  return i ? (e["x-scalar-order"] = i, O({ store: r, entry: o }), !0) : !1;
}, T = (r, t, n) => {
  const a = new Set(r.tags ?? []);
  n && a.add(n.name), t && a.delete(t.name), r.tags = Array.from(a);
}, $ = (r, t, n, a) => {
  r.paths?.[n.path]?.[n.method] && delete r.paths[n.path][n.method], t.paths ? (t.paths[n.path] || (t.paths[n.path] = {}), t.paths[n.path][n.method] = a) : t.paths = {
    [n.path]: {
      [n.method]: a
    }
  };
}, C = (r, t, n) => {
  const o = k(r).schema.paths?.[t]?.[n];
  return A(o, { prefix: `#/paths/${j(t)}/${n}` });
}, F = (r, t, n) => {
  const a = d("document", t), o = d("document", n);
  if (!a || !o)
    return !1;
  const e = h({ store: r, entry: a }), u = h({ store: r, entry: o });
  if (!e || !u)
    return !1;
  const s = C(
    x(e),
    t.path,
    t.method
  );
  if (!s)
    return !1;
  const c = d("tag", t) ?? null, i = d("tag", n) ?? null;
  return T(s, c, i), $(e, u, t, s), O({ store: r, entry: t }), O({ store: r, entry: n }), !0;
}, H = (r, t, n, a) => {
  const o = r.workspace["x-scalar-order"] ?? [], e = Object.keys(r.workspace.documents), u = B(e, o, (f) => f), s = u.findIndex((f) => f === t.id), c = u.findIndex((f) => f === n.id), i = P(u, s, c, a);
  return i ? (r.update("x-scalar-order", i), !0) : !1;
}, G = ({
  store: r,
  sidebarState: t
}) => ({
  handleDragEnd: (o, e) => {
    const u = b(r);
    if (!u)
      return !1;
    const s = t.getEntryById(o.id), c = t.getEntryById(e.id);
    if (!s || !c)
      return !1;
    if (s.type === "document")
      return c.type !== "document" || !p(e) ? !1 : H(u, s, c, e.offset);
    if (s.type === "tag")
      return c.type !== "tag" || !p(e) || !l(s, c) ? !1 : w(
        u,
        s,
        c,
        e.offset
      );
    if (s.type === "operation") {
      if (p(e) && l(s, c))
        return w(
          u,
          s,
          c,
          e.offset
        );
      if (y(c, ["tag", "document"]) && m(e))
        return F(u, s, c);
    }
    return !1;
  },
  isDroppable: (o, e) => {
    const u = b(r);
    if (!u)
      return !1;
    const s = t.getEntryById(o.id), c = t.getEntryById(e.id);
    if (!s || !c || s.type === "example")
      return !1;
    if (s.type === "document")
      return c.type === "document" && p(e);
    if (s.type === "tag")
      return p(e) && l(s, c);
    if (s.type === "operation") {
      const i = d("document", c), f = d("document", s);
      if (!i || !f)
        return !1;
      const E = h({ store: u, entry: i });
      if (!E)
        return !1;
      const D = l(s, c);
      return p(e) && !D ? !1 : D ? p(e) || m(e) && y(c, ["tag", "document"]) : m(e) && y(c, ["tag", "document"]) && (f.id === i.id || E.paths?.[s.path]?.[s.method] === void 0);
    }
    return !1;
  }
});
export {
  G as dragHandleFactory
};
