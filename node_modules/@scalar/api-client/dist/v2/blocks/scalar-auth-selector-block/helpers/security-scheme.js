import { generateHash as h } from "@scalar/helpers/string/generate-hash";
import { getResolvedRef as p } from "@scalar/workspace-store/helpers/get-resolved-ref";
import { authOptions as b } from "./auth-options.js";
const m = ({
  name: o,
  type: i,
  value: n
}) => ({
  id: h(JSON.stringify(n)),
  label: i === "openIdConnect" ? `${o} (coming soon)` : o,
  value: n,
  isDeletable: !0
}), y = (o) => m({
  type: "complex",
  name: Object.keys(o).join(" & "),
  value: o
}), f = (o, i) => {
  const n = Object.keys(o);
  if (n.length > 1)
    return y(o);
  if (n[0]) {
    const s = p(i[n[0]]);
    return s ? m({ name: n[0], type: s.type, value: o }) : void 0;
  }
}, v = (o, i, n) => {
  const { requiredFormatted: s, requiredSchemeNames: u, existingIds: d } = o.reduce(
    (e, t) => {
      const a = f(t, i);
      a && (e.requiredFormatted.push(a), e.existingIds.add(a.id));
      for (const r of Object.keys(t))
        e.requiredSchemeNames.add(r);
      return e;
    },
    {
      requiredFormatted: [],
      requiredSchemeNames: /* @__PURE__ */ new Set(),
      existingIds: /* @__PURE__ */ new Set()
    }
  ), c = [];
  for (const [e, t] of Object.entries(i)) {
    if (u.has(e))
      continue;
    const a = p(t);
    if (a) {
      const r = m({ name: e, type: a.type, value: { [e]: [] } });
      c.push(r), d.add(r.id);
    }
  }
  for (const e of n) {
    const t = f(e, i);
    t && !d.has(t.id) && (c.push(t), d.add(t.id));
  }
  const l = [
    { label: "Required authentication", options: s },
    { label: "Available authentication", options: c }
  ];
  return l.push({
    label: "Add new authentication",
    options: Object.entries(b).map(([e, t]) => ({
      id: e,
      label: t.label,
      value: { [e]: [] },
      payload: t.payload,
      isDeletable: !1
    }))
  }), l;
};
export {
  y as formatComplexScheme,
  m as formatScheme,
  v as getSecuritySchemeOptions
};
