import { defineComponent as K, computed as l, ref as m, onMounted as O, onBeforeUnmount as S, watch as V, createElementBlock as w, openBlock as T, createElementVNode as I, createVNode as u, withCtx as g, unref as B } from "vue";
import { AVAILABLE_CLIENTS as M } from "@scalar/types/snippetz";
import { useToasts as A } from "@scalar/use-toasts";
import L from "../../../components/ViewLayout/ViewLayout.vue.js";
import N from "../../../components/ViewLayout/ViewLayoutContent.vue.js";
import { ERRORS as P } from "../../../libs/errors.js";
import { buildRequest as H } from "./helpers/build-request.js";
import { getSecuritySchemes as F } from "./helpers/build-request-security.js";
import { harToFetchRequest as $ } from "./helpers/har-to-fetch-request.js";
import { harToFetchResponse as j } from "./helpers/har-to-fetch-response.js";
import { sendRequest as D } from "./helpers/send-request.js";
import Q from "./components/Header.vue.js";
import { generateClientOptions as z } from "../operation-code-sample/helpers/generate-client-options.js";
import { getSecurityRequirements as G } from "../../features/operation/helpers/get-security-requirements.js";
import { getSelectedSecurity as J } from "../../features/operation/helpers/get-selected-security.js";
import W from "../request-block/RequestBlock.vue.js";
import X from "../response-block/ResponseBlock.vue.js";
const Y = { class: "bg-b-1 flex h-full flex-col" }, Z = { class: "lg:min-h-header flex w-full flex-wrap items-center justify-center p-2 lg:p-0" }, p = {
  name: "OperationBlock"
}, fe = /* @__PURE__ */ K({
  ...p,
  props: {
    eventBus: {},
    documentSecurity: {},
    documentSelectedSecurity: {},
    appVersion: {},
    globalCookies: { default: () => [] },
    path: {},
    method: {},
    httpClients: { default: () => M },
    layout: {},
    server: {},
    selectedClient: {},
    servers: {},
    hideClientButton: { type: Boolean },
    integration: {},
    documentUrl: {},
    source: {},
    operation: {},
    setOperationSecurity: { type: Boolean },
    exampleKey: {},
    authMeta: {},
    securitySchemes: {},
    plugins: { default: () => [] },
    environment: {},
    proxyUrl: {}
  },
  emits: ["update:servers"],
  setup(e, { emit: q }) {
    const R = q, C = l(() => z(e.httpClients)), d = l(
      () => G(e.documentSecurity, e.operation.security)
    ), h = l(
      () => J(
        e.documentSelectedSecurity,
        e.operation["x-scalar-selected-security"],
        d.value,
        e.setOperationSecurity
      )
    ), v = l(
      () => F(e.securitySchemes, h.value.selectedSchemes)
    ), { toast: y } = A(), f = m(null), a = m(null), s = m(null), i = () => f.value?.abort(P.REQUEST_ABORTED), c = async () => {
      const [t, n] = H({
        environment: e.environment,
        exampleKey: e.exampleKey,
        globalCookies: e.globalCookies,
        method: e.method,
        operation: e.operation,
        path: e.path,
        selectedSecuritySchemes: v.value,
        server: e.server,
        proxyUrl: e.proxyUrl
      });
      if (t) {
        y(t.message, "error");
        return;
      }
      f.value = n.controller, a.value && "reader" in a.value && a.value.reader.cancel(), e.eventBus.emit("hooks:on:request:sent", {
        meta: {
          method: e.method,
          path: e.path,
          exampleKey: e.exampleKey
        }
      });
      const [o, r] = await D({
        isUsingProxy: n.isUsingProxy,
        operation: e.operation,
        plugins: e.plugins,
        request: n.request
      });
      if (e.eventBus.emit("hooks:on:request:complete", {
        payload: r ? {
          response: r.originalResponse,
          request: r.request.clone(),
          duration: r.response.duration,
          timestamp: r.timestamp
        } : void 0,
        meta: {
          method: e.method,
          path: e.path,
          exampleKey: e.exampleKey
        }
      }), o) {
        y(o.message, "error");
        return;
      }
      a.value = r.response, s.value = r.request;
    };
    O(() => {
      e.eventBus.on("operation:send:request:hotkey", c), e.eventBus.on("operation:cancel:request", i);
    }), S(() => {
      e.eventBus.off("operation:send:request:hotkey", c), e.eventBus.off("operation:cancel:request", i);
    });
    const x = l(
      () => (e.operation["x-scalar-history"] ?? []).map((t) => ({
        method: t.request.method,
        path: t.request.url,
        duration: t.time,
        status: t.response.status
      })).reverse()
    ), k = ({ index: t }) => {
      const n = (e.operation["x-scalar-history"]?.length ?? 0) - t - 1, o = e.operation["x-scalar-history"]?.[n];
      if (!o)
        return;
      const r = () => e.eventBus.emit("ui:route:example", {
        exampleName: "draft",
        callback: async (U) => {
          if (U === "error")
            return;
          const b = j({
            harResponse: o.response,
            url: o.request.url,
            method: e.method,
            path: e.path,
            duration: o.time
          }), E = $({
            harRequest: o.request
          });
          a.value = b, s.value = E;
        }
      });
      e.eventBus.emit("operation:reload:history", {
        meta: {
          path: e.path,
          method: e.method
        },
        index: n,
        callback: r
      });
    };
    return V([() => e.path, () => e.method, () => e.exampleKey], () => {
      a.value = null, s.value = null, i();
    }), S(() => {
      i();
    }), (t, n) => (T(), w("div", Y, [
      I("div", Z, [
        u(Q, {
          documentUrl: e.documentUrl,
          environment: e.environment,
          eventBus: e.eventBus,
          hideClientButton: e.hideClientButton,
          history: x.value,
          integration: e.integration,
          layout: e.layout,
          method: e.method,
          path: e.path,
          server: e.server,
          servers: e.servers,
          source: e.source,
          onExecute: c,
          "onSelect:history:item": k,
          "onUpdate:servers": n[0] || (n[0] = (o) => R("update:servers"))
        }, null, 8, ["documentUrl", "environment", "eventBus", "hideClientButton", "history", "integration", "layout", "method", "path", "server", "servers", "source"])
      ]),
      u(L, { class: "border-t" }, {
        default: g(() => [
          u(N, { class: "flex-1" }, {
            default: g(() => [
              u(B(W), {
                authMeta: e.authMeta,
                clientOptions: C.value,
                environment: e.environment,
                eventBus: e.eventBus,
                exampleKey: e.exampleKey,
                globalCookies: e.globalCookies,
                layout: e.layout,
                method: e.method,
                operation: e.operation,
                path: e.path,
                plugins: e.plugins,
                proxyUrl: e.proxyUrl,
                securityRequirements: d.value,
                securitySchemes: e.securitySchemes,
                selectedClient: e.selectedClient,
                selectedSecurity: h.value,
                selectedSecuritySchemes: v.value,
                server: e.server
              }, null, 8, ["authMeta", "clientOptions", "environment", "eventBus", "exampleKey", "globalCookies", "layout", "method", "operation", "path", "plugins", "proxyUrl", "securityRequirements", "securitySchemes", "selectedClient", "selectedSecurity", "selectedSecuritySchemes", "server"]),
              u(B(X), {
                appVersion: e.appVersion,
                eventBus: e.eventBus,
                layout: e.layout,
                plugins: e.plugins,
                request: s.value,
                response: a.value,
                totalPerformedRequests: x.value.length
              }, null, 8, ["appVersion", "eventBus", "layout", "plugins", "request", "response", "totalPerformedRequests"])
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ]));
  }
});
export {
  fe as default
};
