import { isDefined as p } from "@scalar/helpers/array/is-defined";
import { objectKeys as l } from "@scalar/helpers/object/object-keys";
import { replaceEnvVariables as s } from "@scalar/helpers/regex/replace-variables";
import { getResolvedRef as m } from "@scalar/workspace-store/helpers/get-resolved-ref";
import { xScalarCookieSchema as d } from "@scalar/workspace-store/schemas/extensions/general/x-scalar-cookies";
import { coerceValue as x } from "@scalar/workspace-store/schemas/typebox-coerce";
import { encode as k } from "js-base64";
const A = (f, o) => o.flatMap(
  (i) => l(i).flatMap((a) => {
    const n = m(f?.[a]);
    return n || [];
  })
) ?? [], B = (f, o = {}, i = "") => {
  const a = {}, n = [], u = new URLSearchParams();
  return f.forEach((r) => {
    if (r.type === "apiKey") {
      const t = s(r.name, o), e = s(r["x-scalar-secret-token"], o) || i;
      r.in === "header" && (a[t] = e), r.in === "query" && u.append(t, e), r.in === "cookie" && n.push(
        x(d, {
          name: t,
          value: e,
          path: "/"
        })
      );
    }
    if (r.type === "http")
      if (r.scheme === "basic") {
        const t = s(r["x-scalar-secret-username"], o), e = s(r["x-scalar-secret-password"], o), c = `${t}:${e}`;
        a.Authorization = `Basic ${c === ":" ? "username:password" : k(c)}`;
      } else {
        const t = s(r["x-scalar-secret-token"], o);
        a.Authorization = `Bearer ${t || i}`;
      }
    if (r.type === "oauth2") {
      const t = Object.values(r.flows), e = s(
        t.filter(p).find((c) => c["x-scalar-secret-token"])?.["x-scalar-secret-token"] ?? "",
        o
      );
      a.Authorization = `Bearer ${e || i}`;
    }
  }), { headers: a, cookies: n, urlParams: u };
};
export {
  B as buildRequestSecurity,
  A as getSecuritySchemes
};
