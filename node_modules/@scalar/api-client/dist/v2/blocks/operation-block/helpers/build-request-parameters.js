import { isDefined as k } from "@scalar/helpers/array/is-defined";
import { replaceEnvVariables as u } from "@scalar/helpers/regex/replace-variables";
import { getResolvedRef as z } from "@scalar/workspace-store/helpers/get-resolved-ref";
import { xScalarCookieSchema as S } from "@scalar/workspace-store/schemas/extensions/general/x-scalar-cookies";
import { coerceValue as m } from "@scalar/workspace-store/schemas/typebox-coerce";
import { deSerializeParameter as g } from "./de-serialize-parameter.js";
import { isParamDisabled as b } from "../../request-block/helpers/is-param-disabled.js";
import { getExample as x } from "./get-example.js";
import { serializeSimpleStyle as h, serializeFormStyleForCookies as v, serializeContentValue as C, serializeDeepObjectStyle as D, serializeSpaceDelimitedStyle as P, serializePipeDelimitedStyle as V, serializeFormStyle as $ } from "./serialize-parameter.js";
const d = (t, r) => "explode" in t && t.explode !== void 0 ? t.explode : r, Q = (t = [], r = {}, l = "default") => {
  const e = {
    cookies: [],
    headers: {},
    pathVariables: {},
    urlParams: new URLSearchParams()
  };
  if (t.length === 0)
    return e;
  for (const c of t) {
    const o = z(c), n = x(o, l, void 0);
    if (!n || b(o, n))
      continue;
    const s = typeof n.value == "string" ? u(n.value, r) : n.value, i = g(s, o), a = u(o.name, r);
    switch (o.in) {
      case "header": {
        if (a.toLowerCase() === "content-type" && i === "multipart/form-data")
          break;
        const p = h(i, d(o, !1));
        if (!k(p))
          break;
        const y = String(p);
        e.headers[a] ? e.headers[a] = `${e.headers[a]},${y}` : e.headers[a] = y;
        break;
      }
      case "path": {
        const f = h(i, d(o, !1));
        e.pathVariables[a] = encodeURIComponent(String(f));
        break;
      }
      case "query": {
        w(o, a, i, e.urlParams);
        break;
      }
      case "cookie": {
        R(a, i, d(o, !0), e.cookies);
        break;
      }
    }
  }
  return e;
}, w = (t, r, l, e) => {
  const c = "explode" in t && t.explode !== void 0 ? t.explode : !0, o = "style" in t && t.style ? t.style : "form";
  if ("content" in t && t.content) {
    const s = Object.keys(t.content)[0] ?? "application/json", i = C(l, s);
    e.set(r, i);
    return;
  }
  if (o === "deepObject" && c) {
    const s = D(r, l);
    for (const i of s)
      e.append(i.key, i.value);
    return;
  }
  if (o === "spaceDelimited") {
    const s = P(l), i = e.get(r);
    e.set(r, i ? `${i} ${s}` : s);
    return;
  }
  if (o === "pipeDelimited") {
    const s = V(l), i = e.get(r);
    e.set(r, i ? `${i}|${s}` : s);
    return;
  }
  const n = $(l, c);
  if (Array.isArray(n))
    for (const s of n) {
      const i = s.key || r;
      e.append(i, String(s.value));
    }
  else
    e.append(r, String(n));
}, R = (t, r, l, e) => {
  const c = v(r, l);
  if (Array.isArray(c))
    for (const o of c) {
      const n = o.key || t;
      e.push(
        m(S, {
          name: n,
          value: String(o.value),
          path: "/"
        })
      );
    }
  else
    e.push(
      m(S, {
        name: t,
        value: String(c),
        path: "/"
      })
    );
};
export {
  Q as buildRequestParameters
};
