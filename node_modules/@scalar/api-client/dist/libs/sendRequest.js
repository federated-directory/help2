import { ERRORS as E } from "../errors.js";
import { normalizeHeaders as $ } from "./normalizeHeaders.js";
import { isValidUrl as L, redirectToProxy as q, shouldUseProxy as B } from "@scalar/oas-utils/helpers";
import C from "axios";
import O from "js-cookie";
import U from "whatwg-mimetype";
import { textMediaTypes as F } from "../views/Request/consts/mediaTypes.js";
const f = (s = []) => s.reduce(
  (o, n) => (n.key && (o[n.key] = n.value), o),
  {}
), k = (s, o) => {
  const n = new U(o);
  if (F.includes(n.essence)) {
    const d = new TextDecoder(n.parameters.get("charset")).decode(s);
    return n.subtype === "json" ? JSON.parse(d) : d;
  } else
    return new Blob([s], { type: n.essence });
}, N = async (s, o, n, u, d, l) => {
  let i = n;
  o.parameters.path.forEach((e) => {
    !e.key || !e.value || (i = i.replace(`{${e.key}}`, e.value));
  });
  const a = f(
    o.parameters.headers.filter(({ enabled: e }) => e)
  );
  let c = null;
  if (o.body.activeBody === "binary" && o.body.binary)
    a["Content-Type"] = o.body.binary.type, a["Content-Disposition"] = `attachment; filename="${o.body.binary.name}"`, c = o.body.binary;
  else if (o.body.activeBody === "raw" && o.body.raw.value)
    c = o.body.raw.value;
  else if (o.body.activeBody === "formData") {
    a["Content-Type"] = "multipart/form-data";
    const e = new FormData();
    o.body.formData.encoding === "form-data" && (o.body.formData.value.forEach(
      (t) => {
        const r = t.file ? t.file : t.value;
        t.key && r && e.append(t.key, r);
      }
    ), c = e);
  }
  const p = [], [D, g] = i.split("?");
  new URLSearchParams(g ?? "").forEach((e, t) => {
    p.push({
      key: t,
      value: e,
      enabled: !0
    });
  });
  const w = {
    ...f(
      o.parameters.query.filter(({ enabled: e }) => e).filter(({ value: e }) => e !== "")
    ),
    ...f(p)
  }, y = {
    ...f(
      (o.parameters.cookies ?? []).filter(({ enabled: e }) => e)
    )
  };
  if (l) {
    if (!n)
      throw new Error(E.URL_EMPTY);
    try {
      new URL(n);
    } catch {
      throw new Error(E.INVALID_URL);
    }
    const e = new URL(n).host;
    Object.keys(l).forEach((t) => {
      const r = l[t];
      if (!r.domain) return;
      (L(r.domain) ? new URL(r.domain).origin : r.domain) === e && (y[r.name] = r.domain);
    });
  }
  u == null || u.forEach((e) => {
    if (e.type === "apiKey" && e.value)
      switch (e.in) {
        case "cookie":
          y[e.name] = e.value;
          break;
        case "query":
          w[e.name] = e.value;
          break;
        case "header":
          a[e.name] = e.value;
          break;
      }
    else e.type === "http" && e.value ? e.scheme === "basic" && e.secondValue ? a.Authorization = `Basic ${btoa(`${e.value}:${e.secondValue}`)}` : a.Authorization = `Bearer ${e.value}` : e.type === "oauth2" && e.flow.token && (a.Authorization = `Bearer ${e.flow.token}`);
  }), Object.keys(y).forEach((e) => {
    O.set(e, y[e], {
      // Means that the browser sends the cookie with both cross-site and same-site requests.
      sameSite: "None",
      // The Secure attribute must also be set when setting SameSite=None.
      secure: !0
    });
  });
  const v = new URLSearchParams(w).toString();
  i = `${D}${v ? "?" + v : ""}`;
  const h = {
    url: q(d, i),
    method: s.method,
    responseType: "arraybuffer",
    headers: a
  };
  c && (h.data = c);
  const R = Date.now();
  try {
    const e = await C(h);
    B(d, i) && [
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Origin",
      "Access-Control-Allow-Methods",
      "Access-Control-Expose-Headers"
    ].map((b) => b.toLowerCase()).forEach((b) => delete e.headers[b]);
    const t = e.data, r = e.headers["Content-Type"] ?? e.headers["content-type"] ?? "text/plain;charset=UTF-8", T = k(t, `${r}`), A = $(e.headers);
    return {
      sentTime: Date.now(),
      request: o,
      response: {
        ...e,
        headers: A,
        data: T,
        duration: Date.now() - R
      }
    };
  } catch (e) {
    const t = e, r = t.response;
    return console.error("ERROR", e), {
      sentTime: Date.now(),
      request: o,
      response: r ? {
        ...r,
        data: k(
          r.data,
          "text/plain;charset=UTF-8"
        ),
        duration: Date.now() - R
      } : void 0,
      error: t
    };
  }
};
export {
  N as sendRequest
};
