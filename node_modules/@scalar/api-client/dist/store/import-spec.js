import { fetchDocument as E, createHash as y } from "@scalar/oas-utils/helpers";
import { importSpecToWorkspace as R } from "@scalar/oas-utils/transforms";
import { toRaw as S } from "vue";
import { normalizeError as g } from "../libs/errors.js";
const w = {};
function D({
  requestMutators: i,
  collectionMutators: s,
  serverMutators: l,
  tagMutators: m,
  securitySchemeMutators: p,
  requestExampleMutators: d,
  workspaceMutators: f,
  workspaces: u
}) {
  const n = async (t, a, e = {}) => {
    const c = S(t), r = await R(c, e);
    if (r.error) {
      console.group("IMPORT ERRORS"), r.importWarnings.forEach((o) => console.warn(o)), console.groupEnd();
      return;
    }
    return e.documentUrl && typeof c == "string" && (w[e.documentUrl] = {
      hash: y(c),
      schema: r.schema
    }), r.examples.forEach((o) => d.add(o)), r.requests.forEach((o) => i.add(o)), r.tags.forEach((o) => m.add(o)), r.servers.forEach((o) => l.add(o)), r.securitySchemes.forEach((o) => p.add(o)), s.add(r.collection), f.edit(a, "collections", [
      ...u[a]?.collections ?? [],
      r.collection.uid
    ]), r;
  };
  async function h(t, a, {
    proxyUrl: e,
    ...c
  } = {}) {
    try {
      const r = await E(t, e);
      return [
        null,
        await n(r, a, {
          documentUrl: t,
          ...c
        })
      ];
    } catch (r) {
      return console.error("Failed to fetch spec from URL:", r), [g(r), null];
    }
  }
  return {
    importSpecFile: n,
    importSpecFromUrl: h
  };
}
export {
  D as importSpecFileFactory,
  w as specDictionary
};
