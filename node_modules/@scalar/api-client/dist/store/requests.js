import { LS_KEYS as S } from "@scalar/helpers/object/local-storage";
import { iterateTitle as y } from "@scalar/helpers/string/iterate-title";
import { requestSchema as E, createExampleFromRequest as F } from "@scalar/oas-utils/entities/spec";
import { schemaModel as T } from "@scalar/oas-utils/helpers";
import { mutationFactory as A } from "@scalar/object-utils/mutator-record";
import { reactive as R } from "vue";
function C(m) {
  const i = R({}), o = A(i, R({}), m && S.REQUEST);
  return {
    requests: i,
    requestMutators: o
  };
}
function L({
  requestExamples: m,
  requestExampleMutators: i,
  requestMutators: o,
  collectionMutators: c,
  collections: s,
  tags: d,
  tagMutators: p
}, q) {
  return {
    addRequest: (r, u) => {
      const e = T(r, E, !1);
      if (!e)
        return console.error("INVALID REQUEST DATA", r);
      const t = s[u], h = F(
        e,
        y(
          (e.summary ?? "Example") + " #1",
          (a) => e.examples.some((l) => a === m[l]?.name)
        )
      );
      return e.examples.push(h.uid), o.add(e), i.add(h), t && c.edit(u, "requests", [...t.requests, e.uid]), e.tags?.length ? e.tags.forEach((a) => {
        const l = t?.tags.find((x) => d[x]?.name === a);
        l && d[l] ? p.edit(l, "children", [...d[l].children, e.uid]) : q({ name: a, children: [e.uid] }, u);
      }) : t && c.edit(u, "children", [...t.children, e.uid]), e;
    },
    deleteRequest: (r, u) => {
      const e = s[u];
      r.examples.forEach((t) => i.delete(t)), e && (c.edit(
        u,
        "requests",
        e.requests.filter((t) => t !== r.uid)
      ), c.edit(
        u,
        "children",
        e.children.filter((t) => t !== r.uid)
      ), r.tags?.forEach((t) => {
        const h = e.tags.find((a) => d[a]?.name === t);
        h && p.edit(h, "children", d[h]?.children.filter((a) => a !== r.uid) || []);
      })), o.delete(r.uid);
    },
    findRequestParents: D({ collections: s, tags: d })
  };
}
function D({
  collections: m,
  tags: i
}) {
  function o(c) {
    const s = Object.values(m).find((n) => n.requests?.includes(c.uid));
    if (!s)
      return [];
    const d = Object.keys(i).reduce(
      (n, f) => (n[f] = [], n),
      { [s?.uid]: [] }
    );
    function p(n, f) {
      f.forEach((r) => d[r]?.push(...n.children)), n.children.forEach((r) => {
        i[r] && p(i[r], [...f, r]);
      });
    }
    p(s, [s.uid]);
    const q = /* @__PURE__ */ new Set();
    return Object.entries(d).forEach(([n, f]) => {
      f.includes(c.uid) && q.add(n);
    }), [...q];
  }
  return o;
}
function Q() {
  return { request: E.parse({
    method: "get",
    parameters: [],
    path: "",
    summary: "My First Request",
    examples: []
  }) };
}
export {
  Q as createInitialRequest,
  C as createStoreRequests,
  L as extendedRequestDataFactory,
  D as findRequestParentsFactory
};
