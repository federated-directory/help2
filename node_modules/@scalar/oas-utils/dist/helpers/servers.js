import { isDefined } from "@scalar/helpers/array/is-defined";
import { combineUrlAndPath } from "@scalar/helpers/url/merge-urls";
import { serverSchema } from "../entities/spec/server.js";
function getServersFromDocument(servers, options = {}) {
  if (!servers?.length) {
    const fallbackServer = createFallbackServer(options);
    return fallbackServer ? [fallbackServer] : [];
  }
  if (!Array.isArray(servers)) {
    return [];
  }
  const validServers = servers.map((server) => processServerObject(server, options)).filter(isDefined);
  if (validServers.length === 0) {
    const fallbackServer = createFallbackServer(options);
    return fallbackServer ? [fallbackServer] : [];
  }
  return validServers;
}
function extractBaseUrlFromDocumentUrl(documentUrl) {
  try {
    const url = new URL(documentUrl);
    const port = url.port ? `:${url.port}` : "";
    return `${url.protocol}//${url.hostname}${port}`;
  } catch {
    return void 0;
  }
}
function getFallbackUrl() {
  if (typeof window === "undefined" || typeof window?.location?.origin !== "string") {
    return void 0;
  }
  return window.location.origin;
}
function createServerFromUrl(url, context) {
  try {
    return serverSchema.parse({ url });
  } catch {
    console.warn(`Failed to create server from ${context}:`, url);
    return void 0;
  }
}
function createDefaultServerFromDocumentUrl(documentUrl) {
  const baseUrl = extractBaseUrlFromDocumentUrl(documentUrl);
  if (!baseUrl) {
    return void 0;
  }
  return createServerFromUrl(baseUrl, "document URL");
}
function createDefaultServerFromFallback() {
  const fallbackUrl = getFallbackUrl();
  if (!fallbackUrl) {
    return void 0;
  }
  return createServerFromUrl(fallbackUrl, "fallback URL");
}
function resolveRelativeServerUrl(serverUrl, options) {
  const { baseServerURL, documentUrl } = options;
  if (baseServerURL) {
    return combineUrlAndPath(baseServerURL, serverUrl);
  }
  if (documentUrl) {
    const baseUrl = extractBaseUrlFromDocumentUrl(documentUrl);
    if (baseUrl) {
      return combineUrlAndPath(baseUrl, serverUrl);
    }
  }
  const fallbackUrl = getFallbackUrl();
  if (fallbackUrl) {
    return combineUrlAndPath(fallbackUrl, serverUrl);
  }
  return serverUrl;
}
function processServerObject(server, options) {
  try {
    const parsedServer = serverSchema.parse(server);
    if (parsedServer.url?.startsWith("/")) {
      parsedServer.url = resolveRelativeServerUrl(parsedServer.url, options);
    }
    return parsedServer;
  } catch (error) {
    console.warn("Invalid server configuration:", server, "Error:", error);
    return void 0;
  }
}
function createFallbackServer(options) {
  if (options.documentUrl) {
    const defaultServer = createDefaultServerFromDocumentUrl(options.documentUrl);
    if (defaultServer) {
      return defaultServer;
    }
  }
  return createDefaultServerFromFallback();
}
export {
  getServersFromDocument
};
//# sourceMappingURL=servers.js.map
