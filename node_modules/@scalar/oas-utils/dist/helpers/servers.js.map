{
  "version": 3,
  "sources": ["../../src/helpers/servers.ts"],
  "sourcesContent": ["import { isDefined } from '@scalar/helpers/array/is-defined'\nimport { combineUrlAndPath } from '@scalar/helpers/url/merge-urls'\nimport type { ServerObject } from '@scalar/workspace-store/schemas/v3.1/strict/openapi-document'\n\nimport { type Server, serverSchema } from '@/entities/spec/server'\n\n/**\n * Server processing options containing base URLs for resolving relative server URLs.\n */\ntype ServerProcessingOptions = {\n  baseServerURL?: string\n  documentUrl?: string\n}\n\n/**\n * Retrieves and processes servers from an OpenAPI document.\n *\n * This function handles several scenarios:\n * 1. No servers provided - creates a default server from document URL or fallback\n * 2. Invalid server configurations - filters them out with warnings\n * 3. Relative URLs - resolves them to absolute URLs using available base URLs\n *\n * @param servers - Array of OpenAPI server objects from the document\n * @param options - Configuration options for server processing\n * @returns Array of validated Server entities\n */\nexport function getServersFromDocument(\n  servers: ServerObject[] | undefined,\n  options: ServerProcessingOptions = {},\n): Server[] {\n  // Handle case where no servers are provided\n  if (!servers?.length) {\n    const fallbackServer = createFallbackServer(options)\n    return fallbackServer ? [fallbackServer] : []\n  }\n\n  // Handle invalid server array\n  if (!Array.isArray(servers)) {\n    return []\n  }\n\n  // Process each server and filter out invalid ones\n  const validServers = servers.map((server) => processServerObject(server, options)).filter(isDefined)\n\n  // If all servers were invalid, provide a fallback\n  if (validServers.length === 0) {\n    const fallbackServer = createFallbackServer(options)\n    return fallbackServer ? [fallbackServer] : []\n  }\n\n  return validServers\n}\n\n/**\n * Extracts the base URL (protocol + hostname) from a document URL.\n * Returns undefined if the URL is invalid.\n */\nfunction extractBaseUrlFromDocumentUrl(documentUrl: string): string | undefined {\n  try {\n    const url = new URL(documentUrl)\n    const port = url.port ? `:${url.port}` : ''\n    return `${url.protocol}//${url.hostname}${port}`\n  } catch {\n    return undefined\n  }\n}\n\n/**\n * Gets the fallback URL from window.location.origin if available.\n */\nfunction getFallbackUrl(): string | undefined {\n  if (typeof window === 'undefined' || typeof window?.location?.origin !== 'string') {\n    return undefined\n  }\n  return window.location.origin\n}\n\n/**\n * Creates a server object from a URL string, with error handling.\n */\nfunction createServerFromUrl(url: string, context: string): Server | undefined {\n  try {\n    return serverSchema.parse({ url })\n  } catch {\n    console.warn(`Failed to create server from ${context}:`, url)\n    return undefined\n  }\n}\n\n/**\n * Creates a default server using the document URL as the base.\n */\nfunction createDefaultServerFromDocumentUrl(documentUrl: string): Server | undefined {\n  const baseUrl = extractBaseUrlFromDocumentUrl(documentUrl)\n  if (!baseUrl) {\n    return undefined\n  }\n\n  return createServerFromUrl(baseUrl, 'document URL')\n}\n\n/**\n * Creates a default server using the fallback URL (window.location.origin).\n */\nfunction createDefaultServerFromFallback(): Server | undefined {\n  const fallbackUrl = getFallbackUrl()\n  if (!fallbackUrl) {\n    return undefined\n  }\n\n  return createServerFromUrl(fallbackUrl, 'fallback URL')\n}\n\n/**\n * Resolves a relative server URL to an absolute URL using available base URLs.\n * Uses a priority system: baseServerURL > documentUrl > fallbackUrl.\n */\nfunction resolveRelativeServerUrl(serverUrl: string, options: ServerProcessingOptions): string {\n  const { baseServerURL, documentUrl } = options\n\n  // Priority 1: Use provided base server URL\n  if (baseServerURL) {\n    return combineUrlAndPath(baseServerURL, serverUrl)\n  }\n\n  // Priority 2: Extract base URL from document URL\n  if (documentUrl) {\n    const baseUrl = extractBaseUrlFromDocumentUrl(documentUrl)\n    if (baseUrl) {\n      return combineUrlAndPath(baseUrl, serverUrl)\n    }\n  }\n\n  // Priority 3: Use fallback URL (window.location.origin)\n  const fallbackUrl = getFallbackUrl()\n  if (fallbackUrl) {\n    return combineUrlAndPath(fallbackUrl, serverUrl)\n  }\n\n  // If no base URL is available, return the original URL\n  return serverUrl\n}\n\n/**\n * Processes a single server object, handling validation and URL resolution.\n */\nfunction processServerObject(server: ServerObject, options: ServerProcessingOptions): Server | undefined {\n  try {\n    const parsedServer = serverSchema.parse(server)\n\n    // Resolve relative URLs to absolute URLs\n    if (parsedServer.url?.startsWith('/')) {\n      parsedServer.url = resolveRelativeServerUrl(parsedServer.url, options)\n    }\n\n    return parsedServer\n  } catch (error) {\n    console.warn('Invalid server configuration:', server, 'Error:', error)\n    return undefined\n  }\n}\n\n/**\n * Creates a fallback server when no valid servers are available.\n * Uses document URL first, then fallback URL.\n */\nfunction createFallbackServer(options: ServerProcessingOptions): Server | undefined {\n  // Priority 1: Try to create default server from document URL\n  if (options.documentUrl) {\n    const defaultServer = createDefaultServerFromDocumentUrl(options.documentUrl)\n\n    if (defaultServer) {\n      return defaultServer\n    }\n  }\n\n  // Priority 2: Try to create default server from fallback URL\n  return createDefaultServerFromFallback()\n}\n"],
  "mappings": "AAAA,SAAS,iBAAiB;AAC1B,SAAS,yBAAyB;AAGlC,SAAsB,oBAAoB;AAsBnC,SAAS,uBACd,SACA,UAAmC,CAAC,GAC1B;AAEV,MAAI,CAAC,SAAS,QAAQ;AACpB,UAAM,iBAAiB,qBAAqB,OAAO;AACnD,WAAO,iBAAiB,CAAC,cAAc,IAAI,CAAC;AAAA,EAC9C;AAGA,MAAI,CAAC,MAAM,QAAQ,OAAO,GAAG;AAC3B,WAAO,CAAC;AAAA,EACV;AAGA,QAAM,eAAe,QAAQ,IAAI,CAAC,WAAW,oBAAoB,QAAQ,OAAO,CAAC,EAAE,OAAO,SAAS;AAGnG,MAAI,aAAa,WAAW,GAAG;AAC7B,UAAM,iBAAiB,qBAAqB,OAAO;AACnD,WAAO,iBAAiB,CAAC,cAAc,IAAI,CAAC;AAAA,EAC9C;AAEA,SAAO;AACT;AAMA,SAAS,8BAA8B,aAAyC;AAC9E,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,WAAW;AAC/B,UAAM,OAAO,IAAI,OAAO,IAAI,IAAI,IAAI,KAAK;AACzC,WAAO,GAAG,IAAI,QAAQ,KAAK,IAAI,QAAQ,GAAG,IAAI;AAAA,EAChD,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,SAAS,iBAAqC;AAC5C,MAAI,OAAO,WAAW,eAAe,OAAO,QAAQ,UAAU,WAAW,UAAU;AACjF,WAAO;AAAA,EACT;AACA,SAAO,OAAO,SAAS;AACzB;AAKA,SAAS,oBAAoB,KAAa,SAAqC;AAC7E,MAAI;AACF,WAAO,aAAa,MAAM,EAAE,IAAI,CAAC;AAAA,EACnC,QAAQ;AACN,YAAQ,KAAK,gCAAgC,OAAO,KAAK,GAAG;AAC5D,WAAO;AAAA,EACT;AACF;AAKA,SAAS,mCAAmC,aAAyC;AACnF,QAAM,UAAU,8BAA8B,WAAW;AACzD,MAAI,CAAC,SAAS;AACZ,WAAO;AAAA,EACT;AAEA,SAAO,oBAAoB,SAAS,cAAc;AACpD;AAKA,SAAS,kCAAsD;AAC7D,QAAM,cAAc,eAAe;AACnC,MAAI,CAAC,aAAa;AAChB,WAAO;AAAA,EACT;AAEA,SAAO,oBAAoB,aAAa,cAAc;AACxD;AAMA,SAAS,yBAAyB,WAAmB,SAA0C;AAC7F,QAAM,EAAE,eAAe,YAAY,IAAI;AAGvC,MAAI,eAAe;AACjB,WAAO,kBAAkB,eAAe,SAAS;AAAA,EACnD;AAGA,MAAI,aAAa;AACf,UAAM,UAAU,8BAA8B,WAAW;AACzD,QAAI,SAAS;AACX,aAAO,kBAAkB,SAAS,SAAS;AAAA,IAC7C;AAAA,EACF;AAGA,QAAM,cAAc,eAAe;AACnC,MAAI,aAAa;AACf,WAAO,kBAAkB,aAAa,SAAS;AAAA,EACjD;AAGA,SAAO;AACT;AAKA,SAAS,oBAAoB,QAAsB,SAAsD;AACvG,MAAI;AACF,UAAM,eAAe,aAAa,MAAM,MAAM;AAG9C,QAAI,aAAa,KAAK,WAAW,GAAG,GAAG;AACrC,mBAAa,MAAM,yBAAyB,aAAa,KAAK,OAAO;AAAA,IACvE;AAEA,WAAO;AAAA,EACT,SAAS,OAAO;AACd,YAAQ,KAAK,iCAAiC,QAAQ,UAAU,KAAK;AACrE,WAAO;AAAA,EACT;AACF;AAMA,SAAS,qBAAqB,SAAsD;AAElF,MAAI,QAAQ,aAAa;AACvB,UAAM,gBAAgB,mCAAmC,QAAQ,WAAW;AAE5E,QAAI,eAAe;AACjB,aAAO;AAAA,IACT;AAAA,EACF;AAGA,SAAO,gCAAgC;AACzC;",
  "names": []
}
