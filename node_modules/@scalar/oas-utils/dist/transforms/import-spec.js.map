{
  "version": 3,
  "sources": ["../../src/transforms/import-spec.ts"],
  "sourcesContent": ["import { isDefined } from '@scalar/helpers/array/is-defined'\nimport { isHttpMethod } from '@scalar/helpers/http/is-http-method'\nimport { keysOf } from '@scalar/object-utils/arrays'\nimport { type LoadResult, dereference, load, upgrade } from '@scalar/openapi-parser'\nimport type { OpenAPIV3_1 } from '@scalar/openapi-types'\nimport type { ApiReferenceConfiguration } from '@scalar/types/api-reference'\nimport type { SecuritySchemeOauth2 } from '@scalar/types/entities'\nimport {\n  type Oauth2FlowPayload,\n  type SecurityScheme,\n  type SecuritySchemePayload,\n  securitySchemeSchema,\n} from '@scalar/types/entities'\nimport type { UnknownObject } from '@scalar/types/utils'\nimport type { Entries } from 'type-fest'\n\nimport type { SelectedSecuritySchemeUids } from '@/entities/shared/utility'\nimport { type Collection, type CollectionPayload, collectionSchema } from '@/entities/spec/collection'\nimport type { RequestParameterPayload } from '@/entities/spec/parameters'\nimport { type RequestExample, createExampleFromRequest } from '@/entities/spec/request-examples'\nimport { type Request, type RequestPayload, requestSchema } from '@/entities/spec/requests'\nimport { type Server, serverSchema } from '@/entities/spec/server'\nimport { type Tag, tagSchema } from '@/entities/spec/spec-objects'\nimport { schemaModel } from '@/helpers/schema-model'\nimport { getServersFromDocument } from '@/helpers/servers'\n\nconst dereferenceDocument = async (\n  document: string | UnknownObject,\n  { shouldLoad = true }: { shouldLoad?: boolean } = {},\n) => {\n  if (document === null || (typeof document === 'string' && document.trim() === '')) {\n    console.warn('[@scalar/oas-utils] Empty OpenAPI document provided.')\n\n    return {\n      schema: {} as OpenAPIV3_1.Document,\n      errors: [],\n    }\n  }\n\n  let filesystem: LoadResult['filesystem'] | string | UnknownObject = document\n  let loadErrors: LoadResult['errors'] = []\n\n  if (shouldLoad) {\n    // TODO: Plugins for URLs and files with the proxy are missing here.\n    // @see packages/api-reference/src/helpers/parse.ts\n    const response = await load(document).catch((e) => ({\n      errors: [\n        {\n          code: e.code,\n          message: e.message,\n        },\n      ],\n      filesystem: [],\n    }))\n    filesystem = response.filesystem\n    loadErrors = response.errors ?? []\n  }\n\n  const { specification } = upgrade(filesystem)\n  const { schema, errors: derefErrors = [] } = dereference(specification)\n\n  return {\n    schema,\n    errors: [...loadErrors, ...derefErrors],\n  }\n}\n\n/** Takes a string or object and parses it into an openapi spec compliant schema */\nexport const parseSchema = async (\n  originalDocument: string | UnknownObject | undefined,\n  {\n    shouldLoad = true,\n    /** If a dereferenced document is provided, we will skip the dereferencing step. */\n    dereferencedDocument = undefined,\n  }: { shouldLoad?: boolean; dereferencedDocument?: OpenAPIV3_1.Document } = {},\n) => {\n  // Skip, if a dereferenced document is provided\n  const { schema, errors } = dereferencedDocument\n    ? {\n        schema: dereferencedDocument,\n        errors: [],\n      }\n    : // Otherwise, dereference the original document\n      await dereferenceDocument(originalDocument ?? '', {\n        shouldLoad,\n      })\n\n  if (!schema) {\n    console.warn('[@scalar/oas-utils] OpenAPI Parser Warning: Schema is undefined')\n  }\n\n  return {\n    /**\n     * Temporary fix for the parser returning an empty array\n     * TODO: remove this once the parser is fixed\n     */\n    schema: (Array.isArray(schema) ? {} : schema) as OpenAPIV3_1.Document,\n    errors,\n  }\n}\n\n/** Converts selected security requirements to uids */\nexport const getSelectedSecuritySchemeUids = (\n  securityRequirements: (string | string[])[],\n  preferredSecurityNames: (string | string[])[] = [],\n  securitySchemeMap: Record<string, SecurityScheme['uid']>,\n): SelectedSecuritySchemeUids => {\n  // Set the first security requirement if no preferred security schemes are set\n  const names =\n    securityRequirements[0] && !preferredSecurityNames.length ? [securityRequirements[0]] : preferredSecurityNames\n\n  // Map names to uids\n  const uids = names\n    .map((name) =>\n      Array.isArray(name) ? name.map((k) => securitySchemeMap[k]).filter(isDefined) : securitySchemeMap[name],\n    )\n    .filter(isDefined)\n\n  return uids\n}\n\n/** Create a \"uid\" from a slug */\nexport const getSlugUid = (slug: string) => `slug-uid-${slug}` as Collection['uid']\n\nexport type ImportSpecToWorkspaceArgs = Pick<CollectionPayload, 'documentUrl' | 'watchMode'> &\n  Pick<ApiReferenceConfiguration, 'authentication' | 'baseServerURL' | 'servers' | 'slug'> & {\n    /** The dereferenced document */\n    dereferencedDocument?: OpenAPIV3_1.Document\n    /** Sets the preferred security scheme on the collection instead of the requests */\n    useCollectionSecurity?: boolean\n    /** Call the load step from the parser */\n    shouldLoad?: boolean\n  }\n\n/**\n * Imports an OpenAPI document and converts it to workspace entities (Collection, Request, Server, etc.)\n *\n * The imported entities maintain a close mapping to the original OpenAPI specification to enable:\n * - Bi-directional translation between spec and workspace entities\n * - Preservation of specification details and structure\n * - Accurate representation of relationships between components\n *\n * Relationships between entities are maintained through unique identifiers (UIDs) which allow:\n * - Flexible organization at different levels (workspace, collection, request)\n * - Proper linking between related components\n * - Easy lookup and reference of dependent entities\n */\nexport async function importSpecToWorkspace(\n  content: string | UnknownObject | undefined,\n  {\n    /** If a dereferenced document is provided, we will skip the dereferencing step. */\n    dereferencedDocument,\n    authentication,\n    baseServerURL,\n    documentUrl,\n    servers: configuredServers,\n    useCollectionSecurity = false,\n    slug,\n    shouldLoad,\n    watchMode = false,\n  }: ImportSpecToWorkspaceArgs = {},\n): Promise<\n  | {\n      error: false\n      collection: Collection\n      requests: Request[]\n      schema: OpenAPIV3_1.Document\n      examples: RequestExample[]\n      servers: Server[]\n      tags: Tag[]\n      securitySchemes: SecurityScheme[]\n    }\n  | { error: true; importWarnings: string[]; collection: undefined }\n> {\n  const { schema, errors } = await parseSchema(content, { shouldLoad, dereferencedDocument })\n  const importWarnings: string[] = [...errors.map((e) => e.message)]\n\n  if (!schema) {\n    return { importWarnings, error: true, collection: undefined }\n  }\n  // ---------------------------------------------------------------------------\n  // Some entities will be broken out as individual lists for modification in the workspace\n  const start = performance.now()\n  const requests: Request[] = []\n\n  // Add the base server url to collection servers\n  const collectionServers: Server[] = getServersFromDocument(configuredServers || schema.servers, {\n    baseServerURL,\n    documentUrl,\n  })\n\n  // Store operation servers\n  const operationServers: Server[] = []\n\n  /**\n   * List of all tag strings. For non compliant specs we may need to\n   * add top level tag objects for missing tag objects\n   */\n  const tagNames: Set<string> = new Set()\n\n  // ---------------------------------------------------------------------------\n  // SECURITY HANDLING\n\n  const security = schema.components?.securitySchemes ?? schema?.securityDefinitions ?? {}\n\n  // @ts-expect-error - Toss out a deprecated warning for the old authentication state\n  if (authentication?.oAuth2 || authentication?.apiKey || authentication?.http) {\n    console.warn(\n      `DEPRECATION WARNING: It looks like you're using legacy authentication config. Please migrate to use the updated config. See https://github.com/scalar/scalar/blob/main/documentation/configuration.md#authentication-partial This will be removed in a future version.`,\n    )\n  }\n\n  const securitySchemes = (Object.entries(security) as Entries<Record<string, OpenAPIV3_1.SecuritySchemeObject>>)\n    .map?.(([nameKey, _scheme]) => {\n      // Apply any transforms we need before parsing\n      const payload = {\n        ..._scheme,\n        // Add the new auth config overrides, we keep the old code below for backwards compatibility\n        ...(authentication?.securitySchemes?.[nameKey] ?? {}),\n        nameKey,\n      } as SecuritySchemePayload\n\n      // For oauth2 we need to add the type to the flows + prefill from authentication\n      if (payload.type === 'oauth2' && payload.flows) {\n        const flowKeys = Object.keys(payload.flows) as Array<keyof typeof payload.flows>\n\n        flowKeys.forEach((key) => {\n          if (!payload.flows?.[key] || _scheme.type !== 'oauth2') {\n            return\n          }\n          const authFlow = (authentication?.securitySchemes?.[nameKey] as SecuritySchemeOauth2)?.flows?.[key] ?? {}\n\n          // This part handles setting of flows via the new auth config, the rest can be removed in a future version\n          payload.flows[key] = {\n            ...(_scheme.flows?.[key] ?? {}),\n            ...authFlow,\n          } satisfies Oauth2FlowPayload\n\n          const flow = payload.flows[key] as Oauth2FlowPayload\n\n          // Set the type\n          flow.type = key\n\n          // Prefill values from authorization config - old deprecated config\n          // @ts-expect-error - deprecated\n          if (authentication?.oAuth2) {\n            // @ts-expect-error - deprecated\n            if (authentication.oAuth2.accessToken) {\n              // @ts-expect-error - deprecated\n              flow.token = authentication.oAuth2.accessToken\n            }\n\n            // @ts-expect-error - deprecated\n            if (authentication.oAuth2.clientId) {\n              // @ts-expect-error - deprecated\n              flow['x-scalar-client-id'] = authentication.oAuth2.clientId\n            }\n\n            // @ts-expect-error - deprecated\n            if (authentication.oAuth2.scopes) {\n              // @ts-expect-error - deprecated\n              flow.selectedScopes = authentication.oAuth2.scopes\n            }\n\n            if (flow.type === 'password') {\n              // @ts-expect-error - deprecated\n              flow.username = authentication.oAuth2.username\n              // @ts-expect-error - deprecated\n              flow.password = authentication.oAuth2.password\n            }\n          }\n\n          // Convert scopes to an object\n          if (Array.isArray(flow.scopes)) {\n            flow.scopes = flow.scopes.reduce((prev, s) => ({ ...prev, [s]: '' }), {})\n          }\n\n          // Handle x-defaultClientId\n          if (flow['x-defaultClientId']) {\n            flow['x-scalar-client-id'] = flow['x-defaultClientId']\n          }\n        })\n      }\n      // Otherwise we just prefill  - old deprecated config\n      else if (authentication) {\n        // ApiKey\n        // @ts-expect-error - deprecated\n        if (payload.type === 'apiKey' && authentication.apiKey?.token) {\n          // @ts-expect-error - deprecated\n          payload.value = authentication.apiKey.token\n        }\n        // HTTP\n        else if (payload.type === 'http') {\n          // @ts-expect-error - deprecated\n          if (payload.scheme === 'basic' && authentication.http?.basic) {\n            // @ts-expect-error - deprecated\n            payload.username = authentication.http.basic.username ?? ''\n            // @ts-expect-error - deprecated\n            payload.password = authentication.http.basic.password ?? ''\n          }\n          // Bearer\n          // @ts-expect-error - deprecated\n          else if (payload.scheme === 'bearer' && authentication.http?.bearer?.token) {\n            // @ts-expect-error - deprecated\n            payload.token = authentication.http.bearer.token ?? ''\n          }\n        }\n      }\n\n      const scheme = schemaModel(payload, securitySchemeSchema, false)\n      if (!scheme) {\n        importWarnings.push(`Security scheme ${nameKey} is invalid.`)\n      }\n\n      return scheme\n    })\n    .filter((v) => !!v)\n\n  // Map of security scheme names to UIDs\n  const securitySchemeMap: Record<string, SecurityScheme['uid']> = {}\n  securitySchemes.forEach((s) => {\n    securitySchemeMap[s.nameKey] = s.uid\n  })\n\n  // ---------------------------------------------------------------------------\n  // REQUEST HANDLING\n\n  keysOf(schema.paths ?? {}).forEach((pathString) => {\n    const path = schema?.paths?.[pathString]\n\n    if (!path) {\n      return\n    }\n    // Path level servers must be saved\n    const pathServers = serverSchema.array().parse(path.servers ?? [])\n    for (const server of pathServers) {\n      collectionServers.push(server)\n    }\n\n    // Creates a sorted array of methods based on the path object.\n    const methods = Object.keys(path).filter(isHttpMethod)\n\n    methods.forEach((method) => {\n      const operation = path[method]\n      if (!operation) {\n        return\n      }\n\n      const operationLevelServers = serverSchema.array().parse(operation.servers ?? [])\n\n      for (const server of operationLevelServers) {\n        operationServers.push(server)\n      }\n\n      // We will save a list of all tags to ensure they exists at the top level\n      // TODO: make sure we add any loose requests with no tags to the collection children\n      operation.tags?.forEach((t: string) => tagNames.add(t))\n\n      // Remove security here and add it correctly below\n      const { security: operationSecurity, ...operationWithoutSecurity } = operation\n\n      const securityRequirements: (string | string[])[] = (operationSecurity ?? schema.security ?? [])\n        .map((s: OpenAPIV3_1.SecurityRequirementObject) => {\n          const keys = Object.keys(s)\n          return keys.length > 1 ? keys : keys[0]\n        })\n        .filter(isDefined)\n\n      // Filter the preferred security schemes to only include the ones that are in the security requirements\n      const preferredSecurityNames = [authentication?.preferredSecurityScheme ?? []].flat().filter((name) => {\n        // Match up complex security requirements, array to array\n        if (Array.isArray(name)) {\n          // We match every element in the array\n          return securityRequirements.some(\n            (r) => Array.isArray(r) && r.length === name.length && r.every((v, i) => v === name[i]),\n          )\n        }\n        return securityRequirements.includes(name)\n      })\n\n      // Set the initially selected security scheme\n      const selectedSecuritySchemeUids =\n        securityRequirements.length && !useCollectionSecurity\n          ? getSelectedSecuritySchemeUids(securityRequirements, preferredSecurityNames, securitySchemeMap)\n          : []\n\n      const requestPayload: RequestPayload = {\n        ...operationWithoutSecurity,\n        method,\n        path: pathString,\n        security: operationSecurity,\n        selectedServerUid: operationLevelServers?.[0]?.uid,\n        selectedSecuritySchemeUids,\n        // Merge path and operation level parameters\n        parameters: [...(path?.parameters ?? []), ...(operation.parameters ?? [])] as RequestParameterPayload[],\n        servers: [...pathServers, ...operationLevelServers].map((s) => s.uid),\n      }\n\n      // Remove any examples from the request payload as they conflict with our examples property and are not valid\n      if (requestPayload.examples) {\n        console.warn('[@scalar/api-client] operation.examples is not a valid openapi property')\n        delete requestPayload.examples\n      }\n\n      // Save parse the request\n      const request = schemaModel(requestPayload, requestSchema, false)\n\n      if (!request) {\n        importWarnings.push(`${method} Request at ${path} is invalid.`)\n      } else {\n        requests.push(request)\n      }\n    })\n  })\n\n  // ---------------------------------------------------------------------------\n  // TAG HANDLING\n\n  // TODO: We may need to handle de-duping tags\n  const tags = schemaModel(schema?.tags ?? [], tagSchema.array(), false) ?? []\n\n  // Delete any tag names that already have a definition\n  tags.forEach((t) => tagNames.delete(t.name))\n\n  // Add an entry for any tags that are used but do not have a definition\n  tagNames.forEach((name) => name && tags.push(tagSchema.parse({ name })))\n\n  // Tag name to UID map\n  const tagMap: Record<string, Tag> = {}\n  tags.forEach((t) => {\n    tagMap[t.name] = t\n  })\n\n  // Add all tags by default. We will remove nested ones\n  const collectionChildren = new Set<Collection['children'][number]>(tags.map((t) => t.uid))\n\n  // Nested folders go before any requests\n  tags.forEach((t) => {\n    t['x-scalar-children']?.forEach((c) => {\n      // Add the uid to the appropriate parent.children\n      const nestedUid = tagMap[c.tagName]?.uid\n\n      if (nestedUid) {\n        t.children.push(nestedUid)\n\n        // Remove the nested uid from the root folder\n        collectionChildren.delete(nestedUid)\n      }\n    })\n  })\n\n  // Add the request UIDs to the tag children (or collection root)\n  requests.forEach((r) => {\n    if (r.tags?.length) {\n      r.tags.forEach((t) => {\n        tagMap[t]?.children.push(r.uid)\n      })\n    } else {\n      collectionChildren.add(r.uid)\n    }\n  })\n\n  // ---------------------------------------------------------------------------\n\n  const examples: RequestExample[] = []\n\n  // Ensure each request has at least 1 example\n  requests.forEach((request) => {\n    // TODO: Need to handle parsing examples\n    // if (request['x-scalar-examples']) return\n\n    // Create the initial example\n    const example = createExampleFromRequest(request, 'Default Example')\n\n    examples.push(example)\n    request.examples.push(example.uid)\n  })\n\n  // ---------------------------------------------------------------------------\n  // Generate Collection\n\n  // Grab the security requirements for this operation\n  const securityRequirements: SelectedSecuritySchemeUids = (schema.security ?? [])\n    .map((s: OpenAPIV3_1.SecurityRequirementObject) => {\n      const keys = Object.keys(s)\n      return keys.length > 1 ? keys : keys[0]\n    })\n    .filter(isDefined)\n\n  // Here we do not filter these as we let the preferredSecurityScheme override the requirements\n  const preferredSecurityNames = [authentication?.preferredSecurityScheme ?? []].flat()\n\n  // Set the initially selected security scheme\n  const selectedSecuritySchemeUids =\n    (securityRequirements.length || preferredSecurityNames?.length) && useCollectionSecurity\n      ? getSelectedSecuritySchemeUids(securityRequirements, preferredSecurityNames, securitySchemeMap)\n      : []\n\n  // Set the uid as a prefixed slug if we have one\n  const slugObj = slug?.length ? { uid: getSlugUid(slug) } : {}\n\n  const collection = collectionSchema.parse({\n    ...slugObj,\n    ...schema,\n    watchMode,\n    documentUrl,\n    useCollectionSecurity,\n    requests: requests.map((r) => r.uid),\n    servers: collectionServers.map((s) => s.uid),\n    tags: tags.map((t) => t.uid),\n    children: [...collectionChildren],\n    security: schema.security ?? [{}],\n    selectedServerUid: collectionServers?.[0]?.uid,\n    selectedSecuritySchemeUids,\n    components: {\n      ...schema.components,\n    },\n    securitySchemes: securitySchemes.map((s) => s.uid),\n  })\n\n  const end = performance.now()\n  console.log(`workspace: ${Math.round(end - start)} ms`)\n\n  /**\n   * Servers and requests will be saved in top level maps and indexed via UID to\n   * maintain specification relationships\n   */\n  return {\n    error: false,\n    servers: [...collectionServers, ...operationServers],\n    schema,\n    requests,\n    examples,\n    collection,\n    tags,\n    securitySchemes,\n  }\n}\n"],
  "mappings": "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",
  "names": ["securityRequirements", "preferredSecurityNames", "selectedSecuritySchemeUids"]
}
