import { tagObjectSchema } from '../entities/workspace/spec/spec.js';
import { schemaModel } from '../helpers/schema-model.js';
import { load, dereference } from '@scalar/openapi-parser';
import { createRequest } from '../entities/workspace/spec/requests.js';
import { createFolder } from '../entities/workspace/folder/folder.js';
import { createServer } from '../entities/workspace/server/server.js';
import { createCollection } from '../entities/workspace/collection/collection.js';

const PARAM_DICTIONARY = {
    cookie: 'cookies',
    header: 'headers',
    path: 'path',
    query: 'query',
};
/** Import an OpenAPI spec file and convert it to workspace entities */
const importSpecToWorkspace = async (spec, overloadServers) => {
    const importWarnings = [];
    const requests = [];
    // TODO: `parsedSpec` can have circular reference and will break.
    // We always have to use the original document.
    const { filesystem } = await load(spec);
    const { schema, errors } = await dereference(filesystem);
    if (errors?.length || !schema) {
        console.warn('Please open an issue on https://github.com/scalar/scalar\n', 'Scalar OpenAPI Parser Warning:\n', errors);
    }
    // Keep a list of all tags used in requests so we can reference them later
    const requestTags = new Set();
    Object.entries(schema?.paths || {}).forEach(([pathString, path]) => {
        if (!path)
            return;
        const methods = [
            'get',
            'put',
            'post',
            'delete',
            'options',
            'head',
            'patch',
            'trace',
        ];
        methods.forEach((method) => {
            const operation = path[method];
            if (!operation)
                return;
            if ('$ref' in operation) {
                importWarnings.push(`${method.toUpperCase}:${pathString} - Importing of $ref paths is not yet supported`);
                return;
            }
            const parameters = {
                path: {},
                query: {},
                headers: {},
                cookies: {},
            };
            // An operation can have component level parameters as well :)
            const pathAndOperationParameters = [
                ...(path.parameters || []),
                ...(operation.parameters || []),
            ].filter((p) => p);
            // Loop over params to set request params
            pathAndOperationParameters.forEach((_param) => {
                const param = _param;
                if ('name' in param &&
                    PARAM_DICTIONARY[param.in]) {
                    parameters[
                    // Map cookie -> and header -> headers
                    PARAM_DICTIONARY[param.in]][param.name] = param;
                }
            });
            const request = createRequest({
                method: method.toUpperCase(),
                path: pathString,
                tags: operation.tags || ['default'],
                description: operation.description,
                operationId: operation.operationId,
                security: operation.security,
                summary: operation.summary || pathString,
                externalDocs: operation.externalDocs,
                requestBody: operation.requestBody,
                parameters,
            });
            request.tags?.forEach((t) => requestTags.add(t));
            requests.push(request);
        });
    });
    // todo workaround till we rethink how we do createTags
    const tags = schemaModel(schema?.tags, tagObjectSchema.array(), false) ?? [
        { name: 'default' },
    ];
    // If there are request tags that are only defined in
    requestTags.forEach((requestTag) => {
        if (!tags.some((tag) => tag.name === requestTag)) {
            // Warn the user about implicit tags
            importWarnings.push(`The tag *${requestTags}* is does not have an explicit tag object in the specification file. `);
            tags.push({ name: requestTag });
        }
    });
    // TODO: Consider if we want this for production or just for data mocking
    // Create a basic folder structure from tags
    const folders = [];
    tags.forEach((t) => {
        const folder = createFolder({
            ...t,
            childUids: requests
                .filter((r) => r.tags?.includes(t.name))
                .map((r) => r.uid),
        });
        folders.push(folder);
    });
    // Toss in a default server if there aren't any
    const unparsedServers = overloadServers ??
        (schema?.servers?.length
            ? schema.servers
            : [
                {
                    url: typeof window !== 'undefined'
                        ? window.location.origin
                        : 'http://localhost',
                    description: 'Replace with your API server',
                },
            ]);
    const servers = unparsedServers.map((server) => createServer(server));
    const collection = createCollection({
        spec: {
            openapi: schema?.openapi,
            info: schema?.info,
            security: schema?.security || schema?.securityDefinitions,
            externalDocs: schema?.externalDocs,
            serverUids: servers.map(({ uid }) => uid),
            tags,
        },
        selectedServerUid: servers[0].uid,
        // We default to having all the requests in the root folder
        childUids: folders.map(({ uid }) => uid),
    });
    const components = schema?.components;
    const securityDefinitions = schema?.securityDefinitions;
    return {
        tags,
        folders,
        servers,
        requests,
        collection,
        components,
        securityDefinitions,
    };
};

export { importSpecToWorkspace };
