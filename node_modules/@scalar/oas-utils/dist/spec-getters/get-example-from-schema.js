import { isDefined } from "@scalar/helpers/array/is-defined";
import { getRaw } from "@scalar/json-magic/magic-proxy";
import { getResolvedRef } from "@scalar/workspace-store/helpers/get-resolved-ref";
import { unpackOverridesProxy } from "@scalar/workspace-store/helpers/overrides-proxy";
const MAX_LEVELS_DEEP = 10;
const MAX_PROPERTIES = 10;
const DEFAULT_ADDITIONAL_PROPERTIES_NAME = "additionalProperty";
const currentISOString = (/* @__PURE__ */ new Date()).toISOString();
const currentDateString = currentISOString.split("T")[0];
const currentTimeString = currentISOString.split("T")[1].split(".")[0];
const genericExampleValues = {
  "date-time": currentISOString,
  "date": currentDateString,
  "email": "hello@example.com",
  "hostname": "example.com",
  // https://tools.ietf.org/html/rfc6531#section-3.3
  "idn-email": "jane.doe@example.com",
  // https://tools.ietf.org/html/rfc5890#section-2.3.2.3
  "idn-hostname": "example.com",
  "ipv4": "127.0.0.1",
  "ipv6": "51d4:7fab:bfbf:b7d7:b2cb:d4b4:3dad:d998",
  "iri-reference": "/entitiy/1",
  // https://tools.ietf.org/html/rfc3987
  "iri": "https://example.com/entity/123",
  "json-pointer": "/nested/objects",
  "password": "super-secret",
  "regex": "/[a-z]/",
  // https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01
  "relative-json-pointer": "1/nested/objects",
  // full-time in https://tools.ietf.org/html/rfc3339#section-5.6
  "time": currentTimeString,
  // either a URI or relative-reference https://tools.ietf.org/html/rfc3986#section-4.1
  "uri-reference": "../folder",
  "uri-template": "https://example.com/{id}",
  "uri": "https://example.com",
  "uuid": "123e4567-e89b-12d3-a456-426614174000",
  "object-id": "6592008029c8c3e4dc76256c"
};
const guessFromFormat = (schema, makeUpRandomData = false, fallback = "") => {
  if ("type" in schema && schema.type === "string" && "format" in schema && schema.format === "binary") {
    return new File([""], "filename");
  }
  if (makeUpRandomData && "format" in schema && schema.format) {
    return genericExampleValues[schema.format] ?? fallback;
  }
  return fallback;
};
const resultCache = /* @__PURE__ */ new WeakMap();
const requiredNamesCache = /* @__PURE__ */ new WeakMap();
const getRequiredNames = (parentSchema) => {
  if (!parentSchema) {
    return void 0;
  }
  const cached = requiredNamesCache.get(parentSchema);
  if (cached) {
    return cached;
  }
  if ("required" in parentSchema) {
    const required = parentSchema.required;
    if (Array.isArray(required) && required.length > 0) {
      const set = new Set(required);
      requiredNamesCache.set(parentSchema, set);
      return set;
    }
  }
  return void 0;
};
const cache = (schema, result) => {
  if (typeof result !== "object" || result === null) {
    return result;
  }
  resultCache.set(getRaw(unpackOverridesProxy(schema)), result);
  return result;
};
const isComposed = (schema) => !!(schema.allOf || schema.oneOf || schema.anyOf);
const shouldOmitProperty = (schema, parentSchema, propertyName, options) => {
  if (options?.omitEmptyAndOptionalProperties !== true) {
    return false;
  }
  const isContainer = "type" in schema && (schema.type === "object" || schema.type === "array") || isComposed(schema);
  if (isContainer) {
    return false;
  }
  if ("examples" in schema && Array.isArray(schema.examples) && schema.examples.length > 0 || "example" in schema && schema.example !== void 0 || "default" in schema && schema.default !== void 0 || "const" in schema && schema.const !== void 0 || "enum" in schema && Array.isArray(schema.enum) && schema.enum.length > 0) {
    return false;
  }
  const name = propertyName ?? schema.title ?? "";
  const requiredNames = getRequiredNames(parentSchema);
  const isRequired = requiredNames ? requiredNames.has(name) : false;
  return !isRequired;
};
const mergeExamples = (baseValue, newValue) => {
  if (Array.isArray(baseValue) && Array.isArray(newValue)) {
    return [...baseValue, ...newValue];
  }
  if (baseValue && typeof baseValue === "object" && newValue && typeof newValue === "object") {
    return { ...baseValue, ...newValue };
  }
  return newValue;
};
const handleObjectSchema = (schema, options, level, seen) => {
  const response = {};
  if ("properties" in schema && schema.properties) {
    const propertyNames = Object.keys(schema.properties);
    const limit = level > 3 ? Math.min(MAX_PROPERTIES, propertyNames.length) : propertyNames.length;
    for (let i = 0; i < limit; i++) {
      const propertyName = propertyNames[i];
      const propertySchema = getResolvedRef(schema.properties[propertyName]);
      if (!propertySchema) {
        continue;
      }
      const propertyXmlName = options?.xml && "xml" in propertySchema ? propertySchema.xml?.name : void 0;
      const value = getExampleFromSchema(propertySchema, options, {
        level: level + 1,
        parentSchema: schema,
        name: propertyName,
        seen
      });
      if (typeof value !== "undefined") {
        response[propertyXmlName ?? propertyName] = value;
      }
    }
    if (level > 3 && propertyNames.length > MAX_PROPERTIES) {
      response["..."] = "[Additional Properties Truncated]";
    }
  }
  if ("patternProperties" in schema && schema.patternProperties) {
    for (const pattern of Object.keys(schema.patternProperties)) {
      const propertySchema = getResolvedRef(schema.patternProperties[pattern]);
      if (!propertySchema) {
        continue;
      }
      response[pattern] = getExampleFromSchema(propertySchema, options, {
        level: level + 1,
        parentSchema: schema,
        name: pattern,
        seen
      });
    }
  }
  if ("additionalProperties" in schema && schema.additionalProperties !== void 0 && schema.additionalProperties !== false) {
    const additional = getResolvedRef(schema.additionalProperties);
    const isAnyType = schema.additionalProperties === true || typeof schema.additionalProperties === "object" && Object.keys(schema.additionalProperties).length === 0;
    const additionalName = typeof additional === "object" && "x-additionalPropertiesName" in additional && typeof additional["x-additionalPropertiesName"] === "string" && additional["x-additionalPropertiesName"].trim().length > 0 ? additional["x-additionalPropertiesName"].trim() : DEFAULT_ADDITIONAL_PROPERTIES_NAME;
    response[additionalName] = isAnyType ? "anything" : typeof additional === "object" ? getExampleFromSchema(additional, options, {
      level: level + 1,
      seen
    }) : "anything";
  }
  if (schema.oneOf?.[0]) {
    Object.assign(
      response,
      getExampleFromSchema(getResolvedRef(schema.oneOf[0]), options, {
        level: level + 1,
        seen
      })
    );
  } else if (schema.anyOf?.[0]) {
    Object.assign(
      response,
      getExampleFromSchema(getResolvedRef(schema.anyOf[0]), options, {
        level: level + 1,
        seen
      })
    );
  } else if (Array.isArray(schema.allOf) && schema.allOf.length > 0) {
    let merged = response;
    for (const item of schema.allOf) {
      const ex = getExampleFromSchema(getResolvedRef(item), options, {
        level: level + 1,
        parentSchema: schema,
        seen
      });
      merged = mergeExamples(merged, ex);
    }
    if (merged && typeof merged === "object") {
      Object.assign(response, merged);
    }
  }
  if (options?.xml && "xml" in schema && schema.xml?.name && level === 0) {
    const wrapped = {};
    wrapped[schema.xml.name] = response;
    return cache(schema, wrapped);
  }
  return cache(schema, response);
};
const handleArraySchema = (schema, options, level, seen) => {
  const items = "items" in schema ? getResolvedRef(schema.items) : void 0;
  const itemsXmlTagName = items && typeof items === "object" && "xml" in items ? items.xml?.name : void 0;
  const wrapItems = !!(options?.xml && "xml" in schema && schema.xml?.wrapped && itemsXmlTagName);
  if (schema.example !== void 0) {
    return cache(schema, wrapItems ? { [itemsXmlTagName]: schema.example } : schema.example);
  }
  if (items && typeof items === "object") {
    if (Array.isArray(items.allOf) && items.allOf.length > 0) {
      const allOf = items.allOf.filter(isDefined);
      const first = getResolvedRef(allOf[0]);
      if (first && typeof first === "object" && "type" in first && first.type === "object") {
        const combined = { type: "object", allOf };
        const merged = getExampleFromSchema(combined, options, {
          level: level + 1,
          parentSchema: schema,
          seen
        });
        return cache(schema, wrapItems ? [{ [itemsXmlTagName]: merged }] : [merged]);
      }
      const examples = allOf.map(
        (s) => getExampleFromSchema(getResolvedRef(s), options, {
          level: level + 1,
          parentSchema: schema,
          seen
        })
      ).filter(isDefined);
      return cache(
        schema,
        wrapItems ? examples.map((e) => ({ [itemsXmlTagName]: e })) : examples
      );
    }
    const union = items.anyOf || items.oneOf;
    if (union && union.length > 0) {
      const first = union[0];
      const ex = getExampleFromSchema(getResolvedRef(first), options, {
        level: level + 1,
        parentSchema: schema,
        seen
      });
      return cache(schema, wrapItems ? [{ [itemsXmlTagName]: ex }] : [ex]);
    }
  }
  const isObject = items && typeof items === "object" && ("type" in items && items.type === "object" || "properties" in items);
  const isArray = items && typeof items === "object" && ("type" in items && items.type === "array" || "items" in items);
  if (items && typeof items === "object" && ("type" in items && items.type || isObject || isArray)) {
    const ex = getExampleFromSchema(items, options, {
      level: level + 1,
      seen
    });
    return cache(schema, wrapItems ? [{ [itemsXmlTagName]: ex }] : [ex]);
  }
  return cache(schema, []);
};
const getPrimitiveValue = (schema, makeUpRandomData, emptyString) => {
  if ("type" in schema && schema.type && !Array.isArray(schema.type)) {
    switch (schema.type) {
      case "string":
        return guessFromFormat(schema, makeUpRandomData, emptyString ?? "");
      case "boolean":
        return true;
      case "integer":
        return "minimum" in schema && typeof schema.minimum === "number" ? schema.minimum : 1;
      case "number":
        return "minimum" in schema && typeof schema.minimum === "number" ? schema.minimum : 1;
      case "array":
        return [];
      default:
        return void 0;
    }
  }
  return void 0;
};
const getUnionPrimitiveValue = (schema, makeUpRandomData, emptyString) => {
  if ("type" in schema && Array.isArray(schema.type)) {
    if (schema.type.includes("null")) {
      return null;
    }
    const first = schema.type[0];
    if (first) {
      switch (first) {
        case "string":
          return guessFromFormat(schema, makeUpRandomData, emptyString ?? "");
        case "boolean":
          return true;
        case "integer":
          return "minimum" in schema && typeof schema.minimum === "number" ? schema.minimum : 1;
        case "number":
          return "minimum" in schema && typeof schema.minimum === "number" ? schema.minimum : 1;
        case "null":
          return null;
        default:
          return void 0;
      }
    }
  }
  return void 0;
};
const getExampleFromSchema = (schema, options, args) => {
  const { level = 0, parentSchema, name, seen = /* @__PURE__ */ new WeakSet() } = args ?? {};
  const _schema = getResolvedRef(schema);
  if (!isDefined(_schema)) {
    return void 0;
  }
  const targetValue = getRaw(unpackOverridesProxy(_schema));
  if (seen.has(targetValue)) {
    return void 0;
  }
  seen.add(targetValue);
  if (resultCache.has(targetValue)) {
    seen.delete(targetValue);
    return resultCache.get(targetValue);
  }
  if (level > MAX_LEVELS_DEEP) {
    seen.delete(targetValue);
    return "[Max Depth Exceeded]";
  }
  const makeUpRandomData = !!options?.emptyString;
  if (_schema.deprecated || options?.mode === "write" && _schema.readOnly || options?.mode === "read" && _schema.writeOnly || shouldOmitProperty(_schema, parentSchema, name, options)) {
    seen.delete(targetValue);
    return void 0;
  }
  if ("x-variable" in _schema && _schema["x-variable"]) {
    const value = options?.variables?.[_schema["x-variable"]];
    if (value !== void 0) {
      if ("type" in _schema && (_schema.type === "number" || _schema.type === "integer")) {
        seen.delete(targetValue);
        return cache(_schema, Number(value));
      }
      seen.delete(targetValue);
      return cache(_schema, value);
    }
  }
  if (Array.isArray(_schema.examples) && _schema.examples.length > 0) {
    seen.delete(targetValue);
    return cache(_schema, _schema.examples[0]);
  }
  if (_schema.example !== void 0) {
    seen.delete(targetValue);
    return cache(_schema, _schema.example);
  }
  if (_schema.default !== void 0) {
    seen.delete(targetValue);
    return cache(_schema, _schema.default);
  }
  if (_schema.const !== void 0) {
    seen.delete(targetValue);
    return cache(_schema, _schema.const);
  }
  if (Array.isArray(_schema.enum) && _schema.enum.length > 0) {
    seen.delete(targetValue);
    return cache(_schema, _schema.enum[0]);
  }
  if ("properties" in _schema || "type" in _schema && _schema.type === "object") {
    const result = handleObjectSchema(_schema, options, level, seen);
    seen.delete(targetValue);
    return result;
  }
  if ("type" in _schema && _schema.type === "array" || "items" in _schema) {
    const result = handleArraySchema(_schema, options, level, seen);
    seen.delete(targetValue);
    return result;
  }
  const primitive = getPrimitiveValue(_schema, makeUpRandomData, options?.emptyString);
  if (primitive !== void 0) {
    seen.delete(targetValue);
    return cache(_schema, primitive);
  }
  const discriminate = _schema.oneOf || _schema.anyOf;
  if (Array.isArray(discriminate) && discriminate.length > 0) {
    for (const item of discriminate) {
      const resolved = getResolvedRef(item);
      if (resolved && (!("type" in resolved) || resolved.type !== "null")) {
        seen.delete(targetValue);
        return cache(
          _schema,
          getExampleFromSchema(resolved, options, {
            level: level + 1,
            seen
          })
        );
      }
    }
    seen.delete(targetValue);
    return cache(_schema, null);
  }
  if (Array.isArray(_schema.allOf) && _schema.allOf.length > 0) {
    let merged = void 0;
    const items = _schema.allOf;
    for (const item of items) {
      const ex = getExampleFromSchema(item, options, {
        level: level + 1,
        parentSchema: _schema,
        seen
      });
      if (merged === void 0) {
        merged = ex;
      } else if (merged && typeof merged === "object" && ex && typeof ex === "object") {
        merged = mergeExamples(merged, ex);
      } else if (ex !== void 0) {
        merged = ex;
      }
    }
    seen.delete(targetValue);
    return cache(_schema, merged ?? null);
  }
  const unionPrimitive = getUnionPrimitiveValue(_schema, makeUpRandomData, options?.emptyString);
  if (unionPrimitive !== void 0) {
    seen.delete(targetValue);
    return cache(_schema, unionPrimitive);
  }
  seen.delete(targetValue);
  return cache(_schema, null);
};
export {
  getExampleFromSchema
};
//# sourceMappingURL=get-example-from-schema.js.map
