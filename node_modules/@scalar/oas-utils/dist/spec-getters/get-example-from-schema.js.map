{
  "version": 3,
  "sources": ["../../src/spec-getters/get-example-from-schema.ts"],
  "sourcesContent": ["import { isDefined } from '@scalar/helpers/array/is-defined'\nimport { getRaw } from '@scalar/json-magic/magic-proxy'\nimport type { OpenAPIV3_1 } from '@scalar/openapi-types'\nimport { getResolvedRef } from '@scalar/workspace-store/helpers/get-resolved-ref'\nimport { unpackOverridesProxy } from '@scalar/workspace-store/helpers/overrides-proxy'\n\n/** Maximum recursion depth to prevent infinite loops in circular references */\nconst MAX_LEVELS_DEEP = 10\n\n/**\n * Maximum properties to include after level 3 to prevent exponential growth\n * in deeply nested object structures\n */\nconst MAX_PROPERTIES = 10\n\n/** Default name used for additional properties when no custom name is provided */\nconst DEFAULT_ADDITIONAL_PROPERTIES_NAME = 'additionalProperty'\n\n/**\n * Pre-computed date/time values to avoid expensive Date operations on every call.\n * These are calculated once at module load time for better performance.\n */\nconst currentISOString = new Date().toISOString()\nconst currentDateString = currentISOString.split('T')[0]!\nconst currentTimeString = currentISOString.split('T')[1]!.split('.')[0]!\n\n/**\n * Mapping of OpenAPI string formats to example values.\n * Used to generate realistic examples for different string formats.\n */\nconst genericExampleValues: Record<string, string> = {\n  'date-time': currentISOString,\n  'date': currentDateString,\n  'email': 'hello@example.com',\n  'hostname': 'example.com',\n  // https://tools.ietf.org/html/rfc6531#section-3.3\n  'idn-email': 'jane.doe@example.com',\n  // https://tools.ietf.org/html/rfc5890#section-2.3.2.3\n  'idn-hostname': 'example.com',\n  'ipv4': '127.0.0.1',\n  'ipv6': '51d4:7fab:bfbf:b7d7:b2cb:d4b4:3dad:d998',\n  'iri-reference': '/entitiy/1',\n  // https://tools.ietf.org/html/rfc3987\n  'iri': 'https://example.com/entity/123',\n  'json-pointer': '/nested/objects',\n  'password': 'super-secret',\n  'regex': '/[a-z]/',\n  // https://tools.ietf.org/html/draft-handrews-relative-json-pointer-01\n  'relative-json-pointer': '1/nested/objects',\n  // full-time in https://tools.ietf.org/html/rfc3339#section-5.6\n  'time': currentTimeString,\n  // either a URI or relative-reference https://tools.ietf.org/html/rfc3986#section-4.1\n  'uri-reference': '../folder',\n  'uri-template': 'https://example.com/{id}',\n  'uri': 'https://example.com',\n  'uuid': '123e4567-e89b-12d3-a456-426614174000',\n  'object-id': '6592008029c8c3e4dc76256c',\n}\n\n/**\n * Generate example values for string types based on their format.\n * Special handling for binary format which returns a File object.\n */\nconst guessFromFormat = (\n  schema: OpenAPIV3_1.SchemaObject,\n  makeUpRandomData: boolean = false,\n  fallback: string = '',\n): string | File => {\n  // Handle binary format specially - return a File object\n  if ('type' in schema && schema.type === 'string' && 'format' in schema && schema.format === 'binary') {\n    return new File([''], 'filename')\n  }\n\n  // Return format-specific example if we have one and are making up data\n  if (makeUpRandomData && 'format' in schema && schema.format) {\n    return genericExampleValues[schema.format] ?? fallback\n  }\n\n  return fallback\n}\n\n/**\n * WeakMap cache for memoizing resolved example results.\n * Uses the resolved schema object as the key for efficient lookups.\n */\nconst resultCache = new WeakMap<object, unknown>()\n\n/** Cache required property names per parent schema for O(1) membership checks */\nconst requiredNamesCache = new WeakMap<object, ReadonlySet<string>>()\n\n/**\n * Retrieves the set of required property names from a schema.\n * Caches the result in a WeakMap for efficient lookups.\n */\nconst getRequiredNames = (parentSchema: OpenAPIV3_1.SchemaObject | undefined): ReadonlySet<string> | undefined => {\n  if (!parentSchema) {\n    return undefined\n  }\n\n  const cached = requiredNamesCache.get(parentSchema)\n  if (cached) {\n    return cached\n  }\n\n  if ('required' in parentSchema) {\n    const required = parentSchema.required\n    if (Array.isArray(required) && required.length > 0) {\n      const set = new Set<string>(required)\n      requiredNamesCache.set(parentSchema, set)\n      return set\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Cache the result for a schema if it is an object type.\n * Primitive values are not cached to avoid unnecessary WeakMap operations.\n */\nconst cache = (schema: OpenAPIV3_1.SchemaObject, result: unknown) => {\n  if (typeof result !== 'object' || result === null) {\n    return result\n  }\n  resultCache.set(getRaw(unpackOverridesProxy(schema)), result)\n  return result\n}\n\n/**\n * Check if a schema uses composition keywords (allOf, oneOf, anyOf).\n * These require special handling for merging or selecting schemas.\n */\nconst isComposed = (schema: OpenAPIV3_1.SchemaObject): boolean => !!(schema.allOf || schema.oneOf || schema.anyOf)\n\n/**\n * Determine if a property should be omitted based on the options.\n * Properties are omitted if they are not required and the option is enabled.\n */\nconst shouldOmitProperty = (\n  schema: OpenAPIV3_1.SchemaObject,\n  parentSchema: OpenAPIV3_1.SchemaObject | undefined,\n  propertyName: string | undefined,\n  options: { omitEmptyAndOptionalProperties?: boolean } | undefined,\n): boolean => {\n  if (options?.omitEmptyAndOptionalProperties !== true) {\n    return false\n  }\n\n  // Never omit container types (objects/arrays) or composed schemas\n  const isContainer = ('type' in schema && (schema.type === 'object' || schema.type === 'array')) || isComposed(schema)\n  if (isContainer) {\n    return false\n  }\n\n  // Do not omit if explicit example-like values are present\n  if (\n    ('examples' in schema && Array.isArray(schema.examples) && schema.examples.length > 0) ||\n    ('example' in schema && schema.example !== undefined) ||\n    ('default' in schema && schema.default !== undefined) ||\n    ('const' in schema && schema.const !== undefined) ||\n    ('enum' in schema && Array.isArray(schema.enum) && schema.enum.length > 0)\n  ) {\n    return false\n  }\n\n  // Check if the property is required\n  const name = propertyName ?? schema.title ?? ''\n  const requiredNames = getRequiredNames(parentSchema)\n  const isRequired = requiredNames ? requiredNames.has(name) : false\n\n  return !isRequired\n}\n\n/**\n * Merge two example values with predictable semantics.\n * Arrays are concatenated, objects are merged, otherwise the new value wins.\n */\nconst mergeExamples = (baseValue: unknown, newValue: unknown): unknown => {\n  if (Array.isArray(baseValue) && Array.isArray(newValue)) {\n    return [...baseValue, ...newValue]\n  }\n  if (baseValue && typeof baseValue === 'object' && newValue && typeof newValue === 'object') {\n    return { ...(baseValue as Record<string, unknown>), ...(newValue as Record<string, unknown>) }\n  }\n  return newValue\n}\n\n/**\n * Build an example for an object schema, including properties, patternProperties,\n * additionalProperties, and composition (allOf/oneOf/anyOf) merging.\n */\nconst handleObjectSchema = (\n  schema: OpenAPIV3_1.SchemaObject,\n  options: Parameters<typeof getExampleFromSchema>[1],\n  level: number,\n  seen: WeakSet<object>,\n): unknown => {\n  const response: Record<string, unknown> = {}\n\n  if ('properties' in schema && schema.properties) {\n    const propertyNames = Object.keys(schema.properties)\n    const limit = level > 3 ? Math.min(MAX_PROPERTIES, propertyNames.length) : propertyNames.length\n\n    for (let i = 0; i < limit; i++) {\n      const propertyName = propertyNames[i]!\n      const propertySchema = getResolvedRef(schema.properties[propertyName])\n      if (!propertySchema) {\n        continue\n      }\n\n      const propertyXmlName = options?.xml && 'xml' in propertySchema ? propertySchema.xml?.name : undefined\n      const value = getExampleFromSchema(propertySchema, options, {\n        level: level + 1,\n        parentSchema: schema,\n        name: propertyName,\n        seen,\n      })\n\n      if (typeof value !== 'undefined') {\n        response[propertyXmlName ?? propertyName] = value\n      }\n    }\n\n    if (level > 3 && propertyNames.length > MAX_PROPERTIES) {\n      response['...'] = '[Additional Properties Truncated]'\n    }\n  }\n\n  if ('patternProperties' in schema && schema.patternProperties) {\n    for (const pattern of Object.keys(schema.patternProperties)) {\n      const propertySchema = getResolvedRef(schema.patternProperties[pattern])\n      if (!propertySchema) {\n        continue\n      }\n      response[pattern] = getExampleFromSchema(propertySchema, options, {\n        level: level + 1,\n        parentSchema: schema,\n        name: pattern,\n        seen,\n      })\n    }\n  }\n\n  if (\n    'additionalProperties' in schema &&\n    schema.additionalProperties !== undefined &&\n    schema.additionalProperties !== false\n  ) {\n    const additional = getResolvedRef(schema.additionalProperties)\n    const isAnyType =\n      schema.additionalProperties === true ||\n      (typeof schema.additionalProperties === 'object' && Object.keys(schema.additionalProperties).length === 0)\n\n    const additionalName =\n      typeof additional === 'object' &&\n      'x-additionalPropertiesName' in additional &&\n      typeof additional['x-additionalPropertiesName'] === 'string' &&\n      additional['x-additionalPropertiesName'].trim().length > 0\n        ? additional['x-additionalPropertiesName'].trim()\n        : DEFAULT_ADDITIONAL_PROPERTIES_NAME\n\n    response[additionalName] = isAnyType\n      ? 'anything'\n      : typeof additional === 'object'\n        ? getExampleFromSchema(additional, options, {\n            level: level + 1,\n            seen,\n          })\n        : 'anything'\n  }\n\n  // onOf\n  if (schema.oneOf?.[0]) {\n    Object.assign(\n      response,\n      getExampleFromSchema(getResolvedRef(schema.oneOf[0]), options, {\n        level: level + 1,\n        seen,\n      }),\n    )\n  }\n  // anyOf\n  else if (schema.anyOf?.[0]) {\n    Object.assign(\n      response,\n      getExampleFromSchema(getResolvedRef(schema.anyOf[0]), options, {\n        level: level + 1,\n        seen,\n      }),\n    )\n  }\n  // allOf\n  else if (Array.isArray(schema.allOf) && schema.allOf.length > 0) {\n    let merged: unknown = response\n    for (const item of schema.allOf) {\n      const ex = getExampleFromSchema(getResolvedRef(item), options, {\n        level: level + 1,\n        parentSchema: schema,\n        seen,\n      })\n      merged = mergeExamples(merged, ex)\n    }\n    if (merged && typeof merged === 'object') {\n      Object.assign(response, merged as Record<string, unknown>)\n    }\n  }\n\n  if (options?.xml && 'xml' in schema && schema.xml?.name && level === 0) {\n    const wrapped: Record<string, unknown> = {}\n    wrapped[schema.xml.name] = response\n    return cache(schema, wrapped)\n  }\n\n  return cache(schema, response)\n}\n\n/** Build an example for an array schema, including items, allOf, oneOf/anyOf, and XML wrapping */\nconst handleArraySchema = (\n  schema: OpenAPIV3_1.SchemaObject,\n  options: Parameters<typeof getExampleFromSchema>[1],\n  level: number,\n  seen: WeakSet<object>,\n) => {\n  const items = 'items' in schema ? getResolvedRef(schema.items) : undefined\n  const itemsXmlTagName = items && typeof items === 'object' && 'xml' in items ? items.xml?.name : undefined\n  const wrapItems = !!(options?.xml && 'xml' in schema && schema.xml?.wrapped && itemsXmlTagName)\n\n  if (schema.example !== undefined) {\n    return cache(schema, wrapItems ? { [itemsXmlTagName as string]: schema.example } : schema.example)\n  }\n\n  if (items && typeof items === 'object') {\n    if (Array.isArray(items.allOf) && items.allOf.length > 0) {\n      const allOf = items.allOf.filter(isDefined)\n      const first = getResolvedRef(allOf[0])\n\n      if (first && typeof first === 'object' && 'type' in first && first.type === 'object') {\n        const combined: OpenAPIV3_1.SchemaObject = { type: 'object', allOf }\n        const merged = getExampleFromSchema(combined, options, {\n          level: level + 1,\n          parentSchema: schema,\n          seen,\n        })\n        return cache(schema, wrapItems ? [{ [itemsXmlTagName as string]: merged }] : [merged])\n      }\n\n      const examples = allOf\n        .map((s: any) =>\n          getExampleFromSchema(getResolvedRef(s), options, {\n            level: level + 1,\n            parentSchema: schema,\n            seen,\n          }),\n        )\n        .filter(isDefined)\n      return cache(\n        schema,\n        wrapItems ? (examples as unknown[]).map((e) => ({ [itemsXmlTagName as string]: e })) : examples,\n      )\n    }\n\n    const union = items.anyOf || items.oneOf\n    if (union && union.length > 0) {\n      const first = union[0] as OpenAPIV3_1.SchemaObject\n      const ex = getExampleFromSchema(getResolvedRef(first), options, {\n        level: level + 1,\n        parentSchema: schema,\n        seen,\n      })\n      return cache(schema, wrapItems ? [{ [itemsXmlTagName as string]: ex }] : [ex])\n    }\n  }\n\n  const isObject =\n    items && typeof items === 'object' && (('type' in items && items.type === 'object') || 'properties' in items)\n  const isArray =\n    items && typeof items === 'object' && (('type' in items && items.type === 'array') || 'items' in items)\n\n  if (items && typeof items === 'object' && (('type' in items && items.type) || isObject || isArray)) {\n    const ex = getExampleFromSchema(items as OpenAPIV3_1.SchemaObject, options, {\n      level: level + 1,\n      seen,\n    })\n    return cache(schema, wrapItems ? [{ [itemsXmlTagName as string]: ex }] : [ex])\n  }\n\n  return cache(schema, [])\n}\n\n/** Return primitive example value for single-type schemas, or undefined if not primitive */\nconst getPrimitiveValue = (\n  schema: OpenAPIV3_1.SchemaObject,\n  makeUpRandomData: boolean,\n  emptyString: string | undefined,\n) => {\n  if ('type' in schema && schema.type && !Array.isArray(schema.type)) {\n    switch (schema.type) {\n      case 'string':\n        return guessFromFormat(schema, makeUpRandomData, emptyString ?? '')\n      case 'boolean':\n        return true\n      case 'integer':\n        return 'minimum' in schema && typeof schema.minimum === 'number' ? schema.minimum : 1\n      case 'number':\n        return 'minimum' in schema && typeof schema.minimum === 'number' ? schema.minimum : 1\n      case 'array':\n        return []\n      default:\n        return undefined\n    }\n  }\n  return undefined\n}\n\n/** Return primitive example value for union-type schemas (type: string[]) */\nconst getUnionPrimitiveValue = (\n  schema: OpenAPIV3_1.SchemaObject,\n  makeUpRandomData: boolean,\n  emptyString: string | undefined,\n) => {\n  if ('type' in schema && Array.isArray(schema.type)) {\n    if (schema.type.includes('null')) {\n      return null\n    }\n\n    const first = schema.type[0]\n    if (first) {\n      switch (first) {\n        case 'string':\n          return guessFromFormat(schema, makeUpRandomData, emptyString ?? '')\n        case 'boolean':\n          return true\n        case 'integer':\n          return 'minimum' in schema && typeof schema.minimum === 'number' ? schema.minimum : 1\n        case 'number':\n          return 'minimum' in schema && typeof schema.minimum === 'number' ? schema.minimum : 1\n        case 'null':\n          return null\n        default:\n          return undefined\n      }\n    }\n  }\n  return undefined\n}\n\n/**\n * Generate an example value from a given OpenAPI SchemaObject.\n *\n * This function recursively processes OpenAPI schemas to create realistic example data.\n * It handles all OpenAPI schema types including primitives, objects, arrays, and\n * composition schemas (allOf, oneOf, anyOf).\n * Uses a tonne of caching for maximum performance.\n *\n * @param schema - The OpenAPI SchemaObject to generate an example from.\n * @param options - Options to customize example generation.\n * @param level - The current recursion depth.\n * @param parentSchema - The parent schema, if any.\n * @param name - The name of the property being processed.\n * @returns An example value for the given schema.\n *\n * @deprecated Use the one from `@scalar/api-client/v2/blocks/operation-code-sample` instead.\n */\nexport const getExampleFromSchema = (\n  schema: OpenAPIV3_1.SchemaObject,\n  options?: {\n    /** Fallback string for empty string values. */\n    emptyString?: string\n    /** Whether to use XML tag names as keys. */\n    xml?: boolean\n    /** Whether to show read-only/write-only properties. */\n    mode?: 'read' | 'write'\n    /** Dynamic variables which can replace values via x-variable. */\n    variables?: Record<string, unknown>\n    /** Whether to omit empty and optional properties. */\n    omitEmptyAndOptionalProperties?: boolean\n  },\n  args?: Partial<{\n    level: number\n    parentSchema: OpenAPIV3_1.SchemaObject\n    name: string\n    seen: WeakSet<object>\n  }>,\n): any => {\n  const { level = 0, parentSchema, name, seen = new WeakSet() } = args ?? {}\n\n  // Resolve any $ref references to get the actual schema\n  const _schema = getResolvedRef(schema)\n  if (!isDefined(_schema)) {\n    return undefined\n  }\n\n  // Unpack from all proxies to get the raw schema object for cycle detection\n  const targetValue = getRaw(unpackOverridesProxy(_schema))\n  if (seen.has(targetValue)) {\n    return undefined\n  }\n  seen.add(targetValue)\n\n  // Check cache first for performance - avoid recomputing the same schema\n  if (resultCache.has(targetValue)) {\n    seen.delete(targetValue)\n    return resultCache.get(targetValue)\n  }\n\n  // Prevent infinite recursion in circular references\n  if (level > MAX_LEVELS_DEEP) {\n    seen.delete(targetValue)\n    return '[Max Depth Exceeded]'\n  }\n\n  // Determine if we should generate realistic example data\n  const makeUpRandomData = !!options?.emptyString\n\n  // Early exits for schemas that should not be included (deprecated, readOnly, writeOnly, omitEmptyAndOptionalProperties)\n  if (\n    _schema.deprecated ||\n    (options?.mode === 'write' && _schema.readOnly) ||\n    (options?.mode === 'read' && _schema.writeOnly) ||\n    shouldOmitProperty(_schema, parentSchema, name, options)\n  ) {\n    seen.delete(targetValue)\n    return undefined\n  }\n\n  // Handle custom variables (x-variable extension)\n  if ('x-variable' in _schema && _schema['x-variable']) {\n    const value = options?.variables?.[_schema['x-variable']]\n    if (value !== undefined) {\n      // Type coercion for numeric types\n      if ('type' in _schema && (_schema.type === 'number' || _schema.type === 'integer')) {\n        seen.delete(targetValue)\n        return cache(_schema, Number(value))\n      }\n      seen.delete(targetValue)\n      return cache(_schema, value)\n    }\n  }\n\n  // Priority order: examples > example > default > const > enum\n  if (Array.isArray(_schema.examples) && _schema.examples.length > 0) {\n    seen.delete(targetValue)\n    return cache(_schema, _schema.examples[0])\n  }\n  if (_schema.example !== undefined) {\n    seen.delete(targetValue)\n    return cache(_schema, _schema.example)\n  }\n  if (_schema.default !== undefined) {\n    seen.delete(targetValue)\n    return cache(_schema, _schema.default)\n  }\n  if (_schema.const !== undefined) {\n    seen.delete(targetValue)\n    return cache(_schema, _schema.const)\n  }\n  if (Array.isArray(_schema.enum) && _schema.enum.length > 0) {\n    seen.delete(targetValue)\n    return cache(_schema, _schema.enum[0])\n  }\n\n  // Handle object types - check for properties to identify objects\n  if ('properties' in _schema || ('type' in _schema && _schema.type === 'object')) {\n    const result = handleObjectSchema(_schema, options, level, seen)\n    seen.delete(targetValue)\n    return result\n  }\n\n  // Handle array types\n  if (('type' in _schema && _schema.type === 'array') || 'items' in _schema) {\n    const result = handleArraySchema(_schema, options, level, seen)\n    seen.delete(targetValue)\n    return result\n  }\n\n  // Handle primitive types without allocating temporary objects\n  const primitive = getPrimitiveValue(_schema, makeUpRandomData, options?.emptyString)\n  if (primitive !== undefined) {\n    seen.delete(targetValue)\n    return cache(_schema, primitive)\n  }\n\n  // Handle composition schemas (oneOf, anyOf) at root level\n  const discriminate = _schema.oneOf || _schema.anyOf\n  if (Array.isArray(discriminate) && discriminate.length > 0) {\n    // Find the first non-null type without allocating intermediate arrays\n    for (const item of discriminate) {\n      const resolved = getResolvedRef(item)\n      if (resolved && (!('type' in resolved) || resolved.type !== 'null')) {\n        seen.delete(targetValue)\n        return cache(\n          _schema,\n          getExampleFromSchema(resolved, options, {\n            level: level + 1,\n            seen,\n          }),\n        )\n      }\n    }\n    seen.delete(targetValue)\n    return cache(_schema, null)\n  }\n\n  // Handle allOf at root level (non-object/array schemas)\n  if (Array.isArray(_schema.allOf) && _schema.allOf.length > 0) {\n    let merged: unknown = undefined\n    const items = _schema.allOf\n    for (const item of items) {\n      const ex = getExampleFromSchema(item as OpenAPIV3_1.SchemaObject, options, {\n        level: level + 1,\n        parentSchema: _schema,\n        seen,\n      })\n      if (merged === undefined) {\n        merged = ex\n      } else if (merged && typeof merged === 'object' && ex && typeof ex === 'object') {\n        merged = mergeExamples(merged, ex)\n      } else if (ex !== undefined) {\n        // Prefer the latest defined primitive value\n        merged = ex\n      }\n    }\n    seen.delete(targetValue)\n    return cache(_schema, merged ?? null)\n  }\n\n  // Handle union types (array of types)\n  const unionPrimitive = getUnionPrimitiveValue(_schema, makeUpRandomData, options?.emptyString)\n  if (unionPrimitive !== undefined) {\n    seen.delete(targetValue)\n    return cache(_schema, unionPrimitive)\n  }\n\n  // Default fallback\n  seen.delete(targetValue)\n  return cache(_schema, null)\n}\n"],
  "mappings": "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",
  "names": []
}
