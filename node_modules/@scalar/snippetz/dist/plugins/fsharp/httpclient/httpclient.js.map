{
  "version": 3,
  "sources": ["../../../../src/plugins/fsharp/httpclient/httpclient.ts"],
  "sourcesContent": ["import type { Plugin } from '@scalar/types/snippetz'\n\n/**\n * F# HttpClient plugin for generating HTTP request code\n */\nexport const fsharpHttpclient: Plugin = {\n  target: 'fsharp',\n  client: 'httpclient',\n  title: 'HttpClient',\n  generate: (request, _) => {\n    if (!request) {\n      return ''\n    }\n\n    const finalUrl = buildUrlWithQueryString(request.url, request.queryString)\n    let code = ''\n\n    // Initialize HttpRequestMessage\n    code += generateHttpRequestMessage(request.method, finalUrl)\n\n    // Add headers if present\n    if (request.headers && request.headers.length > 0) {\n      code += generateHeadersCode(request.headers)\n    }\n\n    // Add request body if present\n    if (request.postData) {\n      code += generatePostDataCode(request.postData)\n    }\n\n    // Configure client with cookies if present\n    if (request.cookies && request.cookies.length > 0 && request.url) {\n      code += generateCookiesCode(request.cookies, request.url)\n      code += 'let client = new HttpClient(handler)\\n'\n    } else {\n      code += 'let client = new HttpClient()\\n'\n    }\n\n    // Send the request\n    code += 'let! result = client.SendAsync(httpRequestMessage)\\n'\n\n    return code\n  },\n}\n\n/**\n * Builds a query string from an array of query parameters\n */\nfunction buildQueryString(queryParams: { name: string; value: string }[]): string {\n  if (!queryParams || queryParams.length === 0) {\n    return ''\n  }\n\n  const params = queryParams.map((param) => `${param.name}=${param.value}`)\n  return '?' + params.join('&')\n}\n\n/**\n * Combines base URL with query string if present\n */\nfunction buildUrlWithQueryString(baseUrl: string | undefined, queryParams?: { name: string; value: string }[]): string {\n  if (!baseUrl) {\n    return ''\n  }\n\n  if (!queryParams || queryParams.length === 0) {\n    return baseUrl\n  }\n\n  return baseUrl + buildQueryString(queryParams)\n}\n\n/**\n * Generates the HttpRequestMessage initialization code\n */\nfunction generateHttpRequestMessage(method: string | undefined, url: string): string {\n  return `let httpRequestMessage = new HttpRequestMessage(\n  HttpMethod(\"${method}\"),\n  new Uri(\"${escapeString(url)}\")\n)\\n\\n`\n}\n\n/**\n * Generates code to add headers to the HttpRequestMessage\n */\nfunction generateHeadersCode(headers: { name: string; value: string }[]): string {\n  let code = ''\n  for (const header of headers) {\n    code += `httpRequestMessage.Headers.Add(\"${escapeString(header.name ?? '')}\", \"${escapeString(header.value ?? '')}\")\\n`\n  }\n  code += '\\n'\n  return code\n}\n\n/**\n * Generates code to configure cookies for the HttpClient\n */\nfunction generateCookiesCode(cookies: { name: string; value: string }[], url: string): string {\n  let code = 'let cookieContainer = CookieContainer()\\n'\n  for (const cookie of cookies) {\n    code += `cookieContainer.Add(Uri(\"${escapeString(url)}\"), Cookie(\"${escapeString(cookie.name ?? '')}\", \"${escapeString(cookie.value ?? '')}\"))\\n`\n  }\n\n  code += 'use handler = new HttpClientHandler()\\n'\n  code += 'handler.CookieContainer <- cookieContainer\\n\\n'\n\n  return code\n}\n\n/**\n * Generates code to set the request content based on postData\n */\nfunction generatePostDataCode(postData: any): string {\n  if (!postData) {\n    return ''\n  }\n\n  let code = ''\n\n  switch (postData.mimeType) {\n    case 'multipart/form-data':\n      code += generateMultipartFormDataCode(postData)\n      break\n    case 'application/x-www-form-urlencoded':\n      code += generateUrlEncodedFormDataCode(postData)\n      break\n    case 'application/json':\n      code += generateJsonContentCode(postData)\n      break\n    default:\n      code += generateGenericContentCode(postData, postData.mimeType)\n      break\n  }\n\n  code += 'httpRequestMessage.Content <- content\\n\\n'\n  return code\n}\n\n/**\n * Generates code for generic content types\n */\nfunction generateGenericContentCode(postData: any, contentType: string): string {\n  let code = `let content = new StringContent(\"${escapeString(postData.text ?? '')}\", Encoding.UTF8, \"${escapeString(contentType ?? '')}\")\\n`\n  code += `content.Headers.ContentType <- MediaTypeHeaderValue(\"${escapeString(contentType ?? '')}\")\\n`\n  return code\n}\n\n/**\n * Generates code for multipart/form-data content\n */\nfunction generateMultipartFormDataCode(postData: any): string {\n  let code = 'let content = new MultipartFormDataContent()\\n'\n\n  let fileIndex = 0\n  for (const param of postData.params) {\n    if (param.value === 'BINARY') {\n      const escapedFileName = escapeString(param.fileName ?? '')\n      code += `let fileStreamContent_${fileIndex} = new StreamContent(File.OpenRead(\"${escapedFileName}\"))\\n`\n      code += `fileStreamContent_${fileIndex}.Headers.ContentType <- MediaTypeHeaderValue(\"${escapeString(param.contentType ?? '')}\")\\n`\n      code += `content.Add(fileStreamContent_${fileIndex}, \"${escapedFileName}\", \"${escapedFileName}\")\\n`\n      fileIndex++\n    } else {\n      code += `content.Add(new StringContent(\"${escapeString(param.value ?? '')}\"), \"${escapeString(param.name ?? '')}\")\\n`\n    }\n  }\n  return code\n}\n\n/**\n * Generates code for JSON content\n */\nfunction generateJsonContentCode(postData: any): string {\n  let prettyJson: string\n  try {\n    prettyJson = JSON.stringify(JSON.parse(postData.text ?? '{}'), null, 2)\n  } catch {\n    // If JSON parsing fails, use the raw text as-is\n    prettyJson = postData.text ?? '{}'\n  }\n  return `let content = new StringContent(\"\"\"${prettyJson}\"\"\", Encoding.UTF8, \"application/json\")\\n`\n}\n\n/**\n * Generates code for application/x-www-form-urlencoded content\n */\nfunction generateUrlEncodedFormDataCode(postData: any): string {\n  let code = 'let formUrlEncodedContentDictionary = new Dictionary<string, string>()\\n'\n  for (const param of postData.params) {\n    code += `formUrlEncodedContentDictionary.Add(\"${escapeString(param.name ?? '')}\", \"${escapeString(param.value ?? '')}\")\\n`\n  }\n\n  code += 'let content = new FormUrlEncodedContent(formUrlEncodedContentDictionary)\\n'\n  return code\n}\n\n/**\n * Escapes special characters for F# string literals\n */\nfunction escapeString(str: string | undefined): string {\n  if (str == null) {\n    return ''\n  }\n  return str\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n    .replace(/\\n/g, '\\\\n') // Escape newlines\n    .replace(/\\r/g, '\\\\r') // Escape carriage returns\n    .replace(/\\t/g, '\\\\t') // Escape tabs\n}\n"],
  "mappings": "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",
  "names": []
}
