{
  "version": 3,
  "sources": ["../../../../src/plugins/csharp/httpclient/httpclient.ts"],
  "sourcesContent": ["import type { Plugin, PluginConfiguration } from '@scalar/types/snippetz'\nimport { encode } from 'js-base64'\n\nimport { createSearchParams } from '@/libs/http'\n\n/**\n * csharp/httpclient\n */\nexport const csharpHttpclient: Plugin = {\n  target: 'csharp',\n  client: 'httpclient',\n  title: 'HttpClient',\n  generate(request, configuration) {\n    // Defaults\n    const normalizedRequest = {\n      method: 'GET',\n      url: '',\n      ...request,\n    }\n\n    // Normalization\n    normalizedRequest.method = normalizedRequest.method.toUpperCase()\n\n    // Build URL with query string\n    const searchParams = createSearchParams(normalizedRequest.queryString)\n    const queryString = searchParams.size ? `?${searchParams.toString()}` : ''\n\n    const url = `${normalizedRequest.url}${queryString}`\n\n    // Start building the snippet\n    const lines: string[] = []\n\n    // HttpClient declaration\n    lines.push('using var client = new HttpClient();')\n    lines.push('')\n\n    // HttpRequestMessage\n    const httpMethod = getHttpMethod(normalizedRequest.method)\n    lines.push(`var request = new HttpRequestMessage(${httpMethod}, \"${url}\");`)\n\n    // Headers and auth\n    addHeadersAndAuth(lines, normalizedRequest, configuration)\n\n    // Body content\n    addBodyContent(lines, normalizedRequest)\n\n    // Send request and read response\n    lines.push('')\n    lines.push('using var response = await client.SendAsync(request);')\n\n    return lines.join('\\n')\n  },\n}\n\n/**\n * Convert HTTP method to HttpMethod constant\n */\nfunction getHttpMethod(method: string): string {\n  switch (method) {\n    case 'GET':\n      return 'HttpMethod.Get'\n    case 'POST':\n      return 'HttpMethod.Post'\n    case 'PUT':\n      return 'HttpMethod.Put'\n    case 'DELETE':\n      return 'HttpMethod.Delete'\n    case 'PATCH':\n      return 'HttpMethod.Patch'\n    case 'HEAD':\n      return 'HttpMethod.Head'\n    case 'OPTIONS':\n      return 'HttpMethod.Options'\n    default:\n      return `new HttpMethod(\"${method}\")`\n  }\n}\n\n/**\n * Add headers and authentication to the request\n */\nfunction addHeadersAndAuth(lines: string[], request: any, configuration?: PluginConfiguration): void {\n  const headers = request.headers || []\n  const cookies = request.cookies || []\n\n  // Check for explicit Authorization header first\n  const authHeader = headers.find((h: any) => h.name.toLowerCase() === 'authorization')\n\n  if (authHeader) {\n    const [scheme, parameter] = authHeader.value.split(' ', 2)\n    if (scheme && parameter) {\n      lines.push(`request.Headers.Authorization = new AuthenticationHeaderValue(\"${scheme}\", \"${parameter}\");`)\n    }\n  } else if (configuration?.auth?.username && configuration?.auth?.password) {\n    // Use configuration auth if no explicit header\n    const credentials = encode(`${configuration.auth.username}:${configuration.auth.password}`)\n    lines.push(`request.Headers.Authorization = new AuthenticationHeaderValue(\"Basic\", \"${credentials}\");`)\n  }\n\n  // Process other headers (keep only the last value for duplicates)\n  const processedHeaders = new Map<string, string>()\n  for (const header of headers) {\n    const name = header.name\n    const value = header.value\n\n    if (name.toLowerCase() === 'authorization') {\n      // Already handled above\n      continue\n    }\n\n    processedHeaders.set(name, value)\n  }\n\n  for (const [name, value] of processedHeaders) {\n    if (name.toLowerCase() === 'accept' && isMediaType(value)) {\n      lines.push(`request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(\"${value}\"));`)\n    } else if (name.toLowerCase() === 'content-type' && request.postData) {\n      // Content-Type will be set on content object\n      continue\n    } else {\n      lines.push(`request.Headers.TryAddWithoutValidation(\"${name}\", \"${value}\");`)\n    }\n  }\n\n  // Add cookies\n  if (cookies.length > 0) {\n    const cookieString = cookies.map((cookie: any) => `${cookie.name}=${cookie.value}`).join('; ')\n    lines.push(`request.Headers.TryAddWithoutValidation(\"Cookie\", \"${cookieString}\");`)\n  }\n}\n\n/**\n * Add body content to the request\n */\nfunction addBodyContent(lines: string[], request: any): void {\n  if (!request.postData) {\n    return\n  }\n\n  const { mimeType, text, params } = request.postData\n\n  if (mimeType === 'application/json' && text) {\n    try {\n      const jsonData = JSON.parse(text)\n      const prettyJson = JSON.stringify(jsonData, null, 2)\n      const rawStringLiteral = createRawStringLiteral(prettyJson)\n      lines.push('request.Content = new StringContent(')\n      lines.push(`${rawStringLiteral},`)\n      lines.push('System.Text.Encoding.UTF8, \"application/json\");')\n    } catch {\n      const rawStringLiteral = createRawStringLiteral(text)\n      lines.push('request.Content = new StringContent(')\n      lines.push(`${rawStringLiteral},`)\n      lines.push('System.Text.Encoding.UTF8, \"application/json\");')\n    }\n  } else if (mimeType === 'application/x-www-form-urlencoded' && params) {\n    // Check for duplicate field names\n    const fieldNames = params.map((p: any) => p.name)\n    const hasDuplicates = fieldNames.length !== new Set(fieldNames).size\n\n    if (hasDuplicates) {\n      // Use List<KeyValuePair> for duplicates\n      lines.push('var formParams = new List<KeyValuePair<string, string>>')\n      lines.push('{')\n      for (const param of params) {\n        lines.push(`  new(\"${param.name}\", \"${param.value}\"),`)\n      }\n      lines.push('};')\n      lines.push('request.Content = new FormUrlEncodedContent(formParams);')\n    } else {\n      // Use Dictionary for clean syntax\n      lines.push('var formParams = new Dictionary<string, string>')\n      lines.push('{')\n      for (const param of params) {\n        lines.push(`  [\"${param.name}\"] = \"${param.value}\",`)\n      }\n      lines.push('};')\n      lines.push('request.Content = new FormUrlEncodedContent(formParams);')\n    }\n  } else if (mimeType === 'multipart/form-data' && params) {\n    lines.push('var content = new MultipartFormDataContent();')\n    for (const param of params) {\n      if (param.fileName !== undefined) {\n        lines.push(\n          `content.Add(new StreamContent(File.OpenRead(\"${param.fileName}\")), \"${param.name}\", \"${param.fileName}\");`,\n        )\n      } else {\n        lines.push(`content.Add(new StringContent(\"${param.value}\"), \"${param.name}\");`)\n      }\n    }\n    lines.push('request.Content = content;')\n  } else if (mimeType === 'application/octet-stream' && text) {\n    lines.push(\n      'var content = new ByteArrayContent(System.Text.Encoding.UTF8.GetBytes(\"' + text.replace(/\"/g, '\\\\\"') + '\"));',\n    )\n    lines.push('content.Headers.ContentType = new MediaTypeHeaderValue(\"application/octet-stream\");')\n    lines.push('request.Content = content;')\n  } else if (text) {\n    // Fallback for other content types\n    const rawStringLiteral = createRawStringLiteral(text)\n    lines.push('request.Content = new StringContent(')\n    lines.push(`${rawStringLiteral},`)\n    lines.push(`System.Text.Encoding.UTF8, \"${mimeType}\");`)\n  }\n}\n\n/**\n * Create a C# raw string literal with minimal quote count\n */\nfunction createRawStringLiteral(text: string): string {\n  // Find the minimum number of quotes needed\n  let quoteCount = 3\n  while (text.includes('\"'.repeat(quoteCount))) {\n    quoteCount++\n  }\n\n  const quotes = '\"'.repeat(quoteCount)\n  return `${quotes}\\n${text}\\n${quotes}`\n}\n\n/**\n * Check if a value looks like a media type\n */\nfunction isMediaType(value: string): boolean {\n  return /^[a-zA-Z0-9][a-zA-Z0-9!#$&\\-\\^_]*\\/[a-zA-Z0-9][a-zA-Z0-9!#$&\\-\\^_]*(\\s*;\\s*[a-zA-Z0-9][a-zA-Z0-9!#$&\\-\\^_]*=.*)?$/.test(\n    value,\n  )\n}\n"],
  "mappings": "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",
  "names": []
}
