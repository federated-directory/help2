{
  "version": 3,
  "sources": ["../../../src/httpsnippet-lite/helpers/escape.ts"],
  "sourcesContent": ["type EscapeOptions = {\n  /**\n   * The delimiter that will be used to wrap the string (and so must be escaped\n   * when used within the string).\n   * Defaults to \"\n   */\n  delimiter?: string\n  /**\n   * The char to use to escape the delimiter and other special characters.\n   * Defaults to \\\n   */\n  escapeChar?: string\n  /**\n   * Whether newlines (\\n and \\r) should be escaped within the string.\n   * Defaults to true.\n   */\n  escapeNewlines?: boolean\n}\n\n/**\n * Escape characters within a value to make it safe to insert directly into a\n * snippet. Takes options which define the escape requirements.\n *\n * This is closely based on the JSON-stringify string serialization algorithm,\n * but generalized for other string delimiters (e.g. \" or ') and different escape\n * characters (e.g. Powershell uses `)\n *\n * See https://tc39.es/ecma262/multipage/structured-data.html#sec-quotejsonstring\n * for the complete original algorithm.\n */\nexport function escapeString(rawValue: string, options: EscapeOptions = {}) {\n  const { delimiter = '\"', escapeChar = '\\\\', escapeNewlines = true } = options\n  const stringValue = rawValue.toString()\n  return [...stringValue]\n    .map((c) => {\n      if (c === '\\b') {\n        return `${escapeChar}b`\n      }\n      if (c === '\\t') {\n        return `${escapeChar}t`\n      }\n      if (c === '\\n') {\n        if (escapeNewlines) {\n          return `${escapeChar}n`\n        }\n        return c // Don't just continue, or this is caught by < \\u0020\n      }\n      if (c === '\\f') {\n        return `${escapeChar}f`\n      }\n      if (c === '\\r') {\n        if (escapeNewlines) {\n          return `${escapeChar}r`\n        }\n        return c // Don't just continue, or this is caught by < \\u0020\n      }\n      if (c === escapeChar) {\n        return escapeChar + escapeChar\n      }\n      if (c === delimiter) {\n        return escapeChar + delimiter\n      }\n      if (c < '\\u0020' || c > '\\u007E') {\n        // Delegate the trickier non-ASCII cases to the normal algorithm. Some of these\n        // are escaped as \\uXXXX, whilst others are represented literally. Since we're\n        // using this primarily for header values that are generally (though not 100%\n        // strictly?) ASCII-only, this should almost never happen.\n        return JSON.stringify(c).slice(1, -1)\n      }\n      return c\n    })\n    .join('')\n}\n/**\n * Make a string value safe to insert literally into a snippet within single quotes,\n * by escaping problematic characters, including single quotes inside the string,\n * backslashes, newlines, and other special characters.\n *\n * If value is not a string, it will be stringified with .toString() first.\n */\nexport const escapeForSingleQuotes = (value: string): string => escapeString(value, { delimiter: \"'\" })\n/**\n * Make a string value safe to insert literally into a snippet within double quotes,\n * by escaping problematic characters, including double quotes inside the string,\n * backslashes, newlines, and other special characters.\n *\n * If value is not a string, it will be stringified with .toString() first.\n */\nexport const escapeForDoubleQuotes = (value: string): string => escapeString(value, { delimiter: '\"' })\n"],
  "mappings": "AA8BO,SAAS,aAAa,UAAkB,UAAyB,CAAC,GAAG;AAC1E,QAAM,EAAE,YAAY,KAAK,aAAa,MAAM,iBAAiB,KAAK,IAAI;AACtE,QAAM,cAAc,SAAS,SAAS;AACtC,SAAO,CAAC,GAAG,WAAW,EACnB,IAAI,CAAC,MAAM;AACV,QAAI,MAAM,MAAM;AACd,aAAO,GAAG,UAAU;AAAA,IACtB;AACA,QAAI,MAAM,KAAM;AACd,aAAO,GAAG,UAAU;AAAA,IACtB;AACA,QAAI,MAAM,MAAM;AACd,UAAI,gBAAgB;AAClB,eAAO,GAAG,UAAU;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AACA,QAAI,MAAM,MAAM;AACd,aAAO,GAAG,UAAU;AAAA,IACtB;AACA,QAAI,MAAM,MAAM;AACd,UAAI,gBAAgB;AAClB,eAAO,GAAG,UAAU;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AACA,QAAI,MAAM,YAAY;AACpB,aAAO,aAAa;AAAA,IACtB;AACA,QAAI,MAAM,WAAW;AACnB,aAAO,aAAa;AAAA,IACtB;AACA,QAAI,IAAI,OAAY,IAAI,KAAU;AAKhC,aAAO,KAAK,UAAU,CAAC,EAAE,MAAM,GAAG,EAAE;AAAA,IACtC;AACA,WAAO;AAAA,EACT,CAAC,EACA,KAAK,EAAE;AACZ;AAQO,MAAM,wBAAwB,CAAC,UAA0B,aAAa,OAAO,EAAE,WAAW,IAAI,CAAC;AAQ/F,MAAM,wBAAwB,CAAC,UAA0B,aAAa,OAAO,EAAE,WAAW,IAAI,CAAC;",
  "names": []
}
