const buildString = (length, str) => str.repeat(length);
const concatArray = (arr, pretty, indentation, indentLevel) => {
  const currentIndent = buildString(indentLevel, indentation);
  const closingBraceIndent = buildString(indentLevel - 1, indentation);
  const join = pretty ? `,
${currentIndent}` : ", ";
  if (pretty) {
    return `[
${currentIndent}${arr.join(join)}
${closingBraceIndent}]`;
  }
  return `[${arr.join(join)}]`;
};
const literalDeclaration = (name, parameters, opts) => `let ${name} = ${literalRepresentation(parameters, opts)}`;
const literalRepresentation = (value, opts, indentLevelInput) => {
  const indentLevel = indentLevelInput === void 0 ? 1 : indentLevelInput + 1;
  switch (Object.prototype.toString.call(value)) {
    case "[object Number]":
      return value;
    case "[object Array]": {
      let pretty = false;
      const valuesRepresentation = value.map((v) => {
        if (Object.prototype.toString.call(v) === "[object Object]") {
          pretty = Object.keys(v).length > 1;
        }
        return literalRepresentation(v, opts, indentLevel);
      });
      return concatArray(valuesRepresentation, pretty, opts.indent, indentLevel);
    }
    case "[object Object]": {
      const keyValuePairs = [];
      const _value = value;
      for (const key in _value) {
        if (Object.hasOwn(_value, key)) {
          keyValuePairs.push(`"${key}": ${literalRepresentation(_value[key], opts, indentLevel)}`);
        }
      }
      return concatArray(keyValuePairs, opts.pretty && keyValuePairs.length > 1, opts.indent, indentLevel);
    }
    case "[object Boolean]":
      return value.toString();
    default:
      if (value === null || value === void 0) {
        return "";
      }
      return `"${value.toString().replace(/"/g, '\\"')}"`;
  }
};
export {
  literalDeclaration
};
//# sourceMappingURL=helpers.js.map
