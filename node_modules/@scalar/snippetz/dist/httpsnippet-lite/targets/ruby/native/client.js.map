{
  "version": 3,
  "sources": ["../../../../../src/httpsnippet-lite/targets/ruby/native/client.ts"],
  "sourcesContent": ["import { CodeBuilder } from '@/httpsnippet-lite/helpers/code-builder'\nimport { escapeForSingleQuotes } from '@/httpsnippet-lite/helpers/escape'\nimport type { Client } from '@/httpsnippet-lite/targets/target'\n\nexport const native: Client = {\n  info: {\n    key: 'native',\n    title: 'net::http',\n    link: 'http://ruby-doc.org/stdlib-2.2.1/libdoc/net/http/rdoc/Net/HTTP.html',\n    description: 'Ruby HTTP client',\n  },\n  convert: ({ uriObj, method: rawMethod, fullUrl, postData, allHeaders }, options = {}) => {\n    const { insecureSkipVerify = false } = options\n    const { push, blank, join } = new CodeBuilder()\n    push(\"require 'uri'\")\n    push(\"require 'net/http'\")\n    blank()\n    // To support custom methods we check for the supported methods\n    // and if doesn't exist then we build a custom class for it\n    const method = rawMethod.toUpperCase()\n    const methods = [\n      'GET',\n      'POST',\n      'HEAD',\n      'DELETE',\n      'PATCH',\n      'PUT',\n      'OPTIONS',\n      'COPY',\n      'LOCK',\n      'UNLOCK',\n      'MOVE',\n      'TRACE',\n    ]\n    const capMethod = method.charAt(0) + method.substring(1).toLowerCase()\n    if (!methods.includes(method)) {\n      push(`class Net::HTTP::${capMethod} < Net::HTTPRequest`)\n      push(`  METHOD = '${method.toUpperCase()}'`)\n      push(\n        `  REQUEST_HAS_BODY = '${(postData === null || postData === void 0 ? void 0 : postData.text) ? 'true' : 'false'}'`,\n      )\n      push('  RESPONSE_HAS_BODY = true')\n      push('end')\n      blank()\n    }\n    push(`url = URI(\"${fullUrl}\")`)\n    blank()\n    push('http = Net::HTTP.new(url.host, url.port)')\n    if (uriObj.protocol === 'https:') {\n      push('http.use_ssl = true')\n      if (insecureSkipVerify) {\n        push('http.verify_mode = OpenSSL::SSL::VERIFY_NONE')\n      }\n    }\n    blank()\n    push(`request = Net::HTTP::${capMethod}.new(url)`)\n    const headers = Object.keys(allHeaders)\n    if (headers.length) {\n      headers.forEach((key) => {\n        push(`request[\"${key}\"] = '${escapeForSingleQuotes(allHeaders[key] as string)}'`)\n      })\n    }\n    if (postData === null || postData === void 0 ? void 0 : postData.text) {\n      push(`request.body = ${JSON.stringify(postData!.text)}`)\n    }\n    blank()\n    push('response = http.request(request)')\n    push('puts response.read_body')\n    return join()\n  },\n}\n"],
  "mappings": "AAAA,SAAS,mBAAmB;AAC5B,SAAS,6BAA6B;AAG/B,MAAM,SAAiB;AAAA,EAC5B,MAAM;AAAA,IACJ,KAAK;AAAA,IACL,OAAO;AAAA,IACP,MAAM;AAAA,IACN,aAAa;AAAA,EACf;AAAA,EACA,SAAS,CAAC,EAAE,QAAQ,QAAQ,WAAW,SAAS,UAAU,WAAW,GAAG,UAAU,CAAC,MAAM;AACvF,UAAM,EAAE,qBAAqB,MAAM,IAAI;AACvC,UAAM,EAAE,MAAM,OAAO,KAAK,IAAI,IAAI,YAAY;AAC9C,SAAK,eAAe;AACpB,SAAK,oBAAoB;AACzB,UAAM;AAGN,UAAM,SAAS,UAAU,YAAY;AACrC,UAAM,UAAU;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,UAAM,YAAY,OAAO,OAAO,CAAC,IAAI,OAAO,UAAU,CAAC,EAAE,YAAY;AACrE,QAAI,CAAC,QAAQ,SAAS,MAAM,GAAG;AAC7B,WAAK,oBAAoB,SAAS,qBAAqB;AACvD,WAAK,eAAe,OAAO,YAAY,CAAC,GAAG;AAC3C;AAAA,QACE,0BAA0B,aAAa,QAAQ,aAAa,SAAS,SAAS,SAAS,QAAQ,SAAS,OAAO;AAAA,MACjH;AACA,WAAK,4BAA4B;AACjC,WAAK,KAAK;AACV,YAAM;AAAA,IACR;AACA,SAAK,cAAc,OAAO,IAAI;AAC9B,UAAM;AACN,SAAK,0CAA0C;AAC/C,QAAI,OAAO,aAAa,UAAU;AAChC,WAAK,qBAAqB;AAC1B,UAAI,oBAAoB;AACtB,aAAK,8CAA8C;AAAA,MACrD;AAAA,IACF;AACA,UAAM;AACN,SAAK,wBAAwB,SAAS,WAAW;AACjD,UAAM,UAAU,OAAO,KAAK,UAAU;AACtC,QAAI,QAAQ,QAAQ;AAClB,cAAQ,QAAQ,CAAC,QAAQ;AACvB,aAAK,YAAY,GAAG,SAAS,sBAAsB,WAAW,GAAG,CAAW,CAAC,GAAG;AAAA,MAClF,CAAC;AAAA,IACH;AACA,QAAI,aAAa,QAAQ,aAAa,SAAS,SAAS,SAAS,MAAM;AACrE,WAAK,kBAAkB,KAAK,UAAU,SAAU,IAAI,CAAC,EAAE;AAAA,IACzD;AACA,UAAM;AACN,SAAK,kCAAkC;AACvC,SAAK,yBAAyB;AAC9B,WAAO,KAAK;AAAA,EACd;AACF;",
  "names": []
}
