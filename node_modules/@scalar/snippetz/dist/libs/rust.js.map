{
  "version": 3,
  "sources": ["../../src/libs/rust.ts"],
  "sourcesContent": ["/**\n * Escapes a string for use in Rust string literals\n * Handles quotes, backslashes, newlines, and other special characters\n */\nfunction escapeString(str: string): string {\n  return str\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes first\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n    .replace(/\\n/g, '\\\\n') // Escape newlines\n    .replace(/\\r/g, '\\\\r') // Escape carriage returns\n    .replace(/\\t/g, '\\\\t') // Escape tabs\n    .replace(/\\0/g, '\\\\0') // Escape null bytes\n}\n\n/**\n * Formats and escapes a string safely for use in Rust string literals.\n * The returned value is the escaped string, surrounded by double quotes,\n * making it ready for direct insertion into Rust source code.\n */\nexport function wrapInDoubleQuotes(str: string): string {\n  return `\"${escapeString(str)}\"`\n}\n\n/**\n * Produces an indented string using 4 spaces per indent level,\n * in accordance with rustfmt style guidelines.\n * Useful for code generation scenarios requiring precise formatting.\n */\nexport function indent(level: number, text: string): string {\n  const spaces = ' '.repeat(level * 4)\n  return `${spaces}${text}`\n}\n\n/**\n * Formats a Rust chained method call with standard 4-space indentation.\n * Useful for fluent API or builder patterns in generated Rust code.\n */\nexport function createChain(method: string, ...args: string[]): string {\n  return indent(1, `.${method}(${args.join(', ')})`)\n}\n\n/**\n * Properly formats a JSON snippet for Rust's `serde_json::json!` macro,\n * applying idiomatic 4-space indentation to each line for improved readability.\n */\nexport function formatJson(jsonText: string): string {\n  try {\n    const jsonData = JSON.parse(jsonText)\n    const prettyJson = JSON.stringify(jsonData, null, 4)\n\n    // Split into lines and add proper indentation for Rust\n    const lines = prettyJson.split('\\n')\n    const rustLines = lines.map((line, index) => {\n      if (index === 0) {\n        // First line (opening brace)\n        return line\n      }\n      if (index === lines.length - 1) {\n        // Last line (closing brace)\n        return indent(1, line)\n      }\n      // Middle lines\n      return indent(1, line)\n    })\n\n    return rustLines.join('\\n')\n  } catch {\n    // If JSON parsing fails, return the original text\n    return jsonText\n  }\n}\n"],
  "mappings": "AAIA,SAAS,aAAa,KAAqB;AACzC,SAAO,IACJ,QAAQ,OAAO,MAAM,EACrB,QAAQ,MAAM,KAAK,EACnB,QAAQ,OAAO,KAAK,EACpB,QAAQ,OAAO,KAAK,EACpB,QAAQ,OAAO,KAAK,EACpB,QAAQ,OAAO,KAAK;AACzB;AAOO,SAAS,mBAAmB,KAAqB;AACtD,SAAO,IAAI,aAAa,GAAG,CAAC;AAC9B;AAOO,SAAS,OAAO,OAAe,MAAsB;AAC1D,QAAM,SAAS,IAAI,OAAO,QAAQ,CAAC;AACnC,SAAO,GAAG,MAAM,GAAG,IAAI;AACzB;AAMO,SAAS,YAAY,WAAmB,MAAwB;AACrE,SAAO,OAAO,GAAG,IAAI,MAAM,IAAI,KAAK,KAAK,IAAI,CAAC,GAAG;AACnD;AAMO,SAAS,WAAW,UAA0B;AACnD,MAAI;AACF,UAAM,WAAW,KAAK,MAAM,QAAQ;AACpC,UAAM,aAAa,KAAK,UAAU,UAAU,MAAM,CAAC;AAGnD,UAAM,QAAQ,WAAW,MAAM,IAAI;AACnC,UAAM,YAAY,MAAM,IAAI,CAAC,MAAM,UAAU;AAC3C,UAAI,UAAU,GAAG;AAEf,eAAO;AAAA,MACT;AACA,UAAI,UAAU,MAAM,SAAS,GAAG;AAE9B,eAAO,OAAO,GAAG,IAAI;AAAA,MACvB;AAEA,aAAO,OAAO,GAAG,IAAI;AAAA,IACvB,CAAC;AAED,WAAO,UAAU,KAAK,IAAI;AAAA,EAC5B,QAAQ;AAEN,WAAO;AAAA,EACT;AACF;",
  "names": []
}
