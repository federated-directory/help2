{
  "version": 3,
  "sources": ["../src/convert.ts"],
  "sourcesContent": ["import type { OpenAPIV3_1 } from '@scalar/openapi-types'\n\nimport { processAuth } from '@/helpers/auth'\nimport { processContact } from '@/helpers/contact'\nimport { processExternalDocs } from '@/helpers/external-docs'\nimport { processLicense } from '@/helpers/license'\nimport { processLogo } from '@/helpers/logo'\nimport { processItem } from '@/helpers/path-items'\nimport { pruneDocument } from '@/helpers/prune-document'\nimport { analyzeServerDistribution } from '@/helpers/servers'\nimport { normalizePath } from '@/helpers/urls'\n\nimport type { Description, Item, ItemGroup, PostmanCollection } from './types'\n\nconst OPERATION_KEYS: readonly (keyof OpenAPIV3_1.PathItemObject)[] = [\n  'get',\n  'put',\n  'post',\n  'delete',\n  'options',\n  'head',\n  'patch',\n  'trace',\n]\n\nconst normalizeDescription = (description?: Description): string | undefined => {\n  if (typeof description === 'string') {\n    return description\n  }\n\n  return description?.content\n}\n\nconst parseCollectionInput = (postmanCollection: PostmanCollection | string): unknown => {\n  if (typeof postmanCollection !== 'string') {\n    return postmanCollection\n  }\n\n  try {\n    return JSON.parse(postmanCollection) as PostmanCollection\n  } catch (error) {\n    const details = error instanceof Error ? error.message : 'Unknown parse error'\n    const parseError = new Error(`Invalid Postman collection JSON: ${details}`)\n    parseError.name = 'PostmanCollectionParseError'\n    throw parseError\n  }\n}\n\nconst validateCollectionShape = (collection: unknown): PostmanCollection => {\n  if (!collection || typeof collection !== 'object') {\n    throw new Error('Invalid Postman collection: expected an object')\n  }\n\n  const candidate = collection as Partial<PostmanCollection>\n\n  if (!candidate.info) {\n    throw new Error('Missing required info on Postman collection')\n  }\n\n  if (!candidate.item || !Array.isArray(candidate.item)) {\n    throw new Error('Invalid Postman collection: item must be an array')\n  }\n\n  if (typeof candidate.info !== 'object') {\n    throw new Error('Invalid Postman collection: info must be an object')\n  }\n\n  if (!candidate.info.name) {\n    throw new Error('Missing required info.name on Postman collection')\n  }\n\n  if (!candidate.info.schema) {\n    throw new Error('Invalid Postman collection: missing info.schema')\n  }\n\n  if (candidate.variable && !Array.isArray(candidate.variable)) {\n    throw new Error('Invalid Postman collection: variable must be an array when provided')\n  }\n\n  return candidate as PostmanCollection\n}\n\n/**\n * Extracts tags from Postman collection folders.\n * We keep folder nesting using \" > \" so tag names stay readable while preserving hierarchy.\n * Requests do not produce tags; only folders are reflected as tags.\n */\nconst isItemGroup = (item: Item | ItemGroup): item is ItemGroup => 'item' in item && Array.isArray(item.item)\n\nconst extractTags = (items: PostmanCollection['item']): OpenAPIV3_1.TagObject[] => {\n  const collectTags = (item: Item | ItemGroup, parentPath: string = ''): OpenAPIV3_1.TagObject[] => {\n    if (!isItemGroup(item)) {\n      return []\n    }\n\n    const nextPath = item.name ? (parentPath ? `${parentPath} > ${item.name}` : item.name) : parentPath\n    const description = normalizeDescription(item.description)\n    const currentTag: OpenAPIV3_1.TagObject[] = item.name?.length\n      ? [\n          {\n            name: nextPath,\n            ...(description && { description }),\n          },\n        ]\n      : []\n\n    return [...currentTag, ...item.item.flatMap((subItem) => collectTags(subItem, nextPath))]\n  }\n\n  return items.flatMap((item) => collectTags(item))\n}\n\nconst mergeSecuritySchemes = (\n  openapi: OpenAPIV3_1.Document,\n  securitySchemes?: OpenAPIV3_1.ComponentsObject['securitySchemes'],\n): void => {\n  if (!securitySchemes || Object.keys(securitySchemes).length === 0) {\n    return\n  }\n\n  openapi.components = openapi.components || {}\n  openapi.components.securitySchemes = {\n    ...(openapi.components.securitySchemes ?? {}),\n    ...securitySchemes,\n  }\n}\n\nconst mergePathItem = (\n  paths: OpenAPIV3_1.PathsObject,\n  normalizedPathKey: string,\n  pathItem: OpenAPIV3_1.PathItemObject,\n): void => {\n  const targetPath = (paths[normalizedPathKey] ?? {}) as OpenAPIV3_1.PathItemObject\n\n  for (const [key, value] of Object.entries(pathItem) as [\n    keyof OpenAPIV3_1.PathItemObject,\n    OpenAPIV3_1.PathItemObject[keyof OpenAPIV3_1.PathItemObject],\n  ][]) {\n    if (value === undefined) {\n      continue\n    }\n\n    const isOperationKey = OPERATION_KEYS.includes(key)\n\n    if (isOperationKey && targetPath[key]) {\n      const operationName = typeof key === 'string' ? key.toUpperCase() : String(key)\n      console.warn(\n        `Duplicate operation detected for ${operationName} ${normalizedPathKey}. Last operation will overwrite previous.`,\n      )\n    }\n\n    targetPath[key] = value\n  }\n\n  paths[normalizedPathKey] = targetPath\n}\n\nconst cleanupOperations = (paths: OpenAPIV3_1.PathsObject): void => {\n  Object.values(paths).forEach((pathItem) => {\n    if (!pathItem) {\n      return\n    }\n\n    OPERATION_KEYS.forEach((operationKey) => {\n      const operation = pathItem[operationKey]\n      if (!operation) {\n        return\n      }\n\n      if ('parameters' in operation && operation.parameters?.length === 0) {\n        delete operation.parameters\n      }\n\n      if ('requestBody' in operation && operation.requestBody && 'content' in operation.requestBody) {\n        const content = operation.requestBody.content\n        if (content && 'text/plain' in content) {\n          const text = content['text/plain']\n          if (!text?.schema || (text.schema && Object.keys(text.schema).length === 0)) {\n            content['text/plain'] = {}\n          }\n        }\n      }\n\n      if (!operation.description) {\n        delete operation.description\n      }\n    })\n  })\n}\n\n/**\n * Converts a Postman Collection to an OpenAPI 3.1.0 document.\n * This function processes the collection's information, servers, authentication,\n * and items to create a corresponding OpenAPI structure.\n */\nexport function convert(postmanCollection: PostmanCollection | string): OpenAPIV3_1.Document {\n  const collection = validateCollectionShape(parseCollectionInput(postmanCollection))\n\n  // Extract title from collection info, fallback to 'API' if not provided\n  const title = collection.info.name || 'API'\n\n  // Look for version in collection variables, default to '1.0.0'\n  const version = (collection.variable?.find((v) => v.key === 'version')?.value as string) || '1.0.0'\n\n  // Handle different description formats in Postman\n  const description = normalizeDescription(collection.info.description) || ''\n\n  // Process license and contact information\n  const license = processLicense(collection)\n  const contact = processContact(collection)\n\n  // Process logo information\n  const logo = processLogo(collection)\n\n  // Initialize the OpenAPI document with required fields\n  const openapi: OpenAPIV3_1.Document = {\n    openapi: '3.1.0',\n    info: {\n      title,\n      version,\n      ...(description && { description }),\n      ...(license && { license }),\n      ...(contact && { contact }),\n      ...(logo && { 'x-logo': logo }),\n    },\n    paths: {},\n  }\n\n  // Process external docs\n  const externalDocs = processExternalDocs(collection)\n  if (externalDocs) {\n    openapi.externalDocs = externalDocs\n  }\n\n  // Process authentication if present in the collection\n  if (collection.auth) {\n    const { securitySchemes, security } = processAuth(collection.auth)\n    mergeSecuritySchemes(openapi, securitySchemes)\n    openapi.security = security\n  }\n\n  // Process each item in the collection and merge into OpenAPI spec\n  const allServerUsage: Array<{\n    serverUrl: string\n    path: string\n    method: 'get' | 'put' | 'post' | 'delete' | 'options' | 'head' | 'patch' | 'trace'\n  }> = []\n\n  if (collection.item) {\n    // Extract tags from folders\n    const tags = extractTags(collection.item)\n    if (tags.length > 0) {\n      openapi.tags = tags\n    }\n\n    collection.item.forEach((item) => {\n      const { paths: itemPaths, components: itemComponents, serverUsage } = processItem(item)\n\n      // Collect server usage information\n      allServerUsage.push(...serverUsage)\n\n      // Merge paths from the current item\n      openapi.paths = openapi.paths || {}\n      for (const [pathKey, pathItem] of Object.entries(itemPaths)) {\n        // Convert colon-style params to curly brace style\n        const normalizedPathKey = normalizePath(pathKey)\n\n        if (!pathItem) {\n          continue\n        }\n\n        mergePathItem(openapi.paths, normalizedPathKey, pathItem)\n      }\n\n      // Merge security schemes from the current item\n      if (itemComponents?.securitySchemes) {\n        mergeSecuritySchemes(openapi, itemComponents.securitySchemes)\n      }\n    })\n  }\n\n  // Extract all unique paths from the document\n  const allUniquePaths = new Set<string>()\n  if (openapi.paths) {\n    for (const pathKey of Object.keys(openapi.paths)) {\n      allUniquePaths.add(pathKey)\n    }\n  }\n\n  // Analyze server distribution and place servers at appropriate levels\n  const serverPlacement = analyzeServerDistribution(allServerUsage, allUniquePaths)\n\n  // Add servers to document level\n  if (serverPlacement.document.length > 0) {\n    openapi.servers = serverPlacement.document\n  }\n\n  // Add servers to path items\n  if (openapi.paths) {\n    for (const [path, servers] of serverPlacement.pathItems.entries()) {\n      const normalizedPathKey = normalizePath(path)\n      const pathItem = openapi.paths[normalizedPathKey]\n      if (pathItem) {\n        pathItem.servers = servers\n      }\n    }\n\n    // Add servers to operations\n    for (const [path, methods] of serverPlacement.operations.entries()) {\n      const normalizedPathKey = normalizePath(path)\n      const pathItem = openapi.paths[normalizedPathKey]\n      if (!pathItem) {\n        continue\n      }\n      for (const [method, servers] of methods.entries()) {\n        if (method in pathItem) {\n          const operation = pathItem[method as keyof typeof pathItem]\n          if (operation && typeof operation === 'object' && 'responses' in operation) {\n            operation.servers = servers\n          }\n        }\n      }\n    }\n  }\n\n  // Clean up the generated paths\n  if (openapi.paths) {\n    cleanupOperations(openapi.paths)\n  }\n\n  // Remove empty components object\n  if (Object.keys(openapi.components || {}).length === 0) {\n    delete openapi.components\n  }\n\n  return pruneDocument(openapi)\n}\n"],
  "mappings": "AAEA,SAAS,mBAAmB;AAC5B,SAAS,sBAAsB;AAC/B,SAAS,2BAA2B;AACpC,SAAS,sBAAsB;AAC/B,SAAS,mBAAmB;AAC5B,SAAS,mBAAmB;AAC5B,SAAS,qBAAqB;AAC9B,SAAS,iCAAiC;AAC1C,SAAS,qBAAqB;AAI9B,MAAM,iBAAgE;AAAA,EACpE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEA,MAAM,uBAAuB,CAAC,gBAAkD;AAC9E,MAAI,OAAO,gBAAgB,UAAU;AACnC,WAAO;AAAA,EACT;AAEA,SAAO,aAAa;AACtB;AAEA,MAAM,uBAAuB,CAAC,sBAA2D;AACvF,MAAI,OAAO,sBAAsB,UAAU;AACzC,WAAO;AAAA,EACT;AAEA,MAAI;AACF,WAAO,KAAK,MAAM,iBAAiB;AAAA,EACrC,SAAS,OAAO;AACd,UAAM,UAAU,iBAAiB,QAAQ,MAAM,UAAU;AACzD,UAAM,aAAa,IAAI,MAAM,oCAAoC,OAAO,EAAE;AAC1E,eAAW,OAAO;AAClB,UAAM;AAAA,EACR;AACF;AAEA,MAAM,0BAA0B,CAAC,eAA2C;AAC1E,MAAI,CAAC,cAAc,OAAO,eAAe,UAAU;AACjD,UAAM,IAAI,MAAM,gDAAgD;AAAA,EAClE;AAEA,QAAM,YAAY;AAElB,MAAI,CAAC,UAAU,MAAM;AACnB,UAAM,IAAI,MAAM,6CAA6C;AAAA,EAC/D;AAEA,MAAI,CAAC,UAAU,QAAQ,CAAC,MAAM,QAAQ,UAAU,IAAI,GAAG;AACrD,UAAM,IAAI,MAAM,mDAAmD;AAAA,EACrE;AAEA,MAAI,OAAO,UAAU,SAAS,UAAU;AACtC,UAAM,IAAI,MAAM,oDAAoD;AAAA,EACtE;AAEA,MAAI,CAAC,UAAU,KAAK,MAAM;AACxB,UAAM,IAAI,MAAM,kDAAkD;AAAA,EACpE;AAEA,MAAI,CAAC,UAAU,KAAK,QAAQ;AAC1B,UAAM,IAAI,MAAM,iDAAiD;AAAA,EACnE;AAEA,MAAI,UAAU,YAAY,CAAC,MAAM,QAAQ,UAAU,QAAQ,GAAG;AAC5D,UAAM,IAAI,MAAM,qEAAqE;AAAA,EACvF;AAEA,SAAO;AACT;AAOA,MAAM,cAAc,CAAC,SAA8C,UAAU,QAAQ,MAAM,QAAQ,KAAK,IAAI;AAE5G,MAAM,cAAc,CAAC,UAA8D;AACjF,QAAM,cAAc,CAAC,MAAwB,aAAqB,OAAgC;AAChG,QAAI,CAAC,YAAY,IAAI,GAAG;AACtB,aAAO,CAAC;AAAA,IACV;AAEA,UAAM,WAAW,KAAK,OAAQ,aAAa,GAAG,UAAU,MAAM,KAAK,IAAI,KAAK,KAAK,OAAQ;AACzF,UAAM,cAAc,qBAAqB,KAAK,WAAW;AACzD,UAAM,aAAsC,KAAK,MAAM,SACnD;AAAA,MACE;AAAA,QACE,MAAM;AAAA,QACN,GAAI,eAAe,EAAE,YAAY;AAAA,MACnC;AAAA,IACF,IACA,CAAC;AAEL,WAAO,CAAC,GAAG,YAAY,GAAG,KAAK,KAAK,QAAQ,CAAC,YAAY,YAAY,SAAS,QAAQ,CAAC,CAAC;AAAA,EAC1F;AAEA,SAAO,MAAM,QAAQ,CAAC,SAAS,YAAY,IAAI,CAAC;AAClD;AAEA,MAAM,uBAAuB,CAC3B,SACA,oBACS;AACT,MAAI,CAAC,mBAAmB,OAAO,KAAK,eAAe,EAAE,WAAW,GAAG;AACjE;AAAA,EACF;AAEA,UAAQ,aAAa,QAAQ,cAAc,CAAC;AAC5C,UAAQ,WAAW,kBAAkB;AAAA,IACnC,GAAI,QAAQ,WAAW,mBAAmB,CAAC;AAAA,IAC3C,GAAG;AAAA,EACL;AACF;AAEA,MAAM,gBAAgB,CACpB,OACA,mBACA,aACS;AACT,QAAM,aAAc,MAAM,iBAAiB,KAAK,CAAC;AAEjD,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,QAAQ,GAG7C;AACH,QAAI,UAAU,QAAW;AACvB;AAAA,IACF;AAEA,UAAM,iBAAiB,eAAe,SAAS,GAAG;AAElD,QAAI,kBAAkB,WAAW,GAAG,GAAG;AACrC,YAAM,gBAAgB,OAAO,QAAQ,WAAW,IAAI,YAAY,IAAI,OAAO,GAAG;AAC9E,cAAQ;AAAA,QACN,oCAAoC,aAAa,IAAI,iBAAiB;AAAA,MACxE;AAAA,IACF;AAEA,eAAW,GAAG,IAAI;AAAA,EACpB;AAEA,QAAM,iBAAiB,IAAI;AAC7B;AAEA,MAAM,oBAAoB,CAAC,UAAyC;AAClE,SAAO,OAAO,KAAK,EAAE,QAAQ,CAAC,aAAa;AACzC,QAAI,CAAC,UAAU;AACb;AAAA,IACF;AAEA,mBAAe,QAAQ,CAAC,iBAAiB;AACvC,YAAM,YAAY,SAAS,YAAY;AACvC,UAAI,CAAC,WAAW;AACd;AAAA,MACF;AAEA,UAAI,gBAAgB,aAAa,UAAU,YAAY,WAAW,GAAG;AACnE,eAAO,UAAU;AAAA,MACnB;AAEA,UAAI,iBAAiB,aAAa,UAAU,eAAe,aAAa,UAAU,aAAa;AAC7F,cAAM,UAAU,UAAU,YAAY;AACtC,YAAI,WAAW,gBAAgB,SAAS;AACtC,gBAAM,OAAO,QAAQ,YAAY;AACjC,cAAI,CAAC,MAAM,UAAW,KAAK,UAAU,OAAO,KAAK,KAAK,MAAM,EAAE,WAAW,GAAI;AAC3E,oBAAQ,YAAY,IAAI,CAAC;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AAEA,UAAI,CAAC,UAAU,aAAa;AAC1B,eAAO,UAAU;AAAA,MACnB;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;AAOO,SAAS,QAAQ,mBAAqE;AAC3F,QAAM,aAAa,wBAAwB,qBAAqB,iBAAiB,CAAC;AAGlF,QAAM,QAAQ,WAAW,KAAK,QAAQ;AAGtC,QAAM,UAAW,WAAW,UAAU,KAAK,CAAC,MAAM,EAAE,QAAQ,SAAS,GAAG,SAAoB;AAG5F,QAAM,cAAc,qBAAqB,WAAW,KAAK,WAAW,KAAK;AAGzE,QAAM,UAAU,eAAe,UAAU;AACzC,QAAM,UAAU,eAAe,UAAU;AAGzC,QAAM,OAAO,YAAY,UAAU;AAGnC,QAAM,UAAgC;AAAA,IACpC,SAAS;AAAA,IACT,MAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA,GAAI,eAAe,EAAE,YAAY;AAAA,MACjC,GAAI,WAAW,EAAE,QAAQ;AAAA,MACzB,GAAI,WAAW,EAAE,QAAQ;AAAA,MACzB,GAAI,QAAQ,EAAE,UAAU,KAAK;AAAA,IAC/B;AAAA,IACA,OAAO,CAAC;AAAA,EACV;AAGA,QAAM,eAAe,oBAAoB,UAAU;AACnD,MAAI,cAAc;AAChB,YAAQ,eAAe;AAAA,EACzB;AAGA,MAAI,WAAW,MAAM;AACnB,UAAM,EAAE,iBAAiB,SAAS,IAAI,YAAY,WAAW,IAAI;AACjE,yBAAqB,SAAS,eAAe;AAC7C,YAAQ,WAAW;AAAA,EACrB;AAGA,QAAM,iBAID,CAAC;AAEN,MAAI,WAAW,MAAM;AAEnB,UAAM,OAAO,YAAY,WAAW,IAAI;AACxC,QAAI,KAAK,SAAS,GAAG;AACnB,cAAQ,OAAO;AAAA,IACjB;AAEA,eAAW,KAAK,QAAQ,CAAC,SAAS;AAChC,YAAM,EAAE,OAAO,WAAW,YAAY,gBAAgB,YAAY,IAAI,YAAY,IAAI;AAGtF,qBAAe,KAAK,GAAG,WAAW;AAGlC,cAAQ,QAAQ,QAAQ,SAAS,CAAC;AAClC,iBAAW,CAAC,SAAS,QAAQ,KAAK,OAAO,QAAQ,SAAS,GAAG;AAE3D,cAAM,oBAAoB,cAAc,OAAO;AAE/C,YAAI,CAAC,UAAU;AACb;AAAA,QACF;AAEA,sBAAc,QAAQ,OAAO,mBAAmB,QAAQ;AAAA,MAC1D;AAGA,UAAI,gBAAgB,iBAAiB;AACnC,6BAAqB,SAAS,eAAe,eAAe;AAAA,MAC9D;AAAA,IACF,CAAC;AAAA,EACH;AAGA,QAAM,iBAAiB,oBAAI,IAAY;AACvC,MAAI,QAAQ,OAAO;AACjB,eAAW,WAAW,OAAO,KAAK,QAAQ,KAAK,GAAG;AAChD,qBAAe,IAAI,OAAO;AAAA,IAC5B;AAAA,EACF;AAGA,QAAM,kBAAkB,0BAA0B,gBAAgB,cAAc;AAGhF,MAAI,gBAAgB,SAAS,SAAS,GAAG;AACvC,YAAQ,UAAU,gBAAgB;AAAA,EACpC;AAGA,MAAI,QAAQ,OAAO;AACjB,eAAW,CAAC,MAAM,OAAO,KAAK,gBAAgB,UAAU,QAAQ,GAAG;AACjE,YAAM,oBAAoB,cAAc,IAAI;AAC5C,YAAM,WAAW,QAAQ,MAAM,iBAAiB;AAChD,UAAI,UAAU;AACZ,iBAAS,UAAU;AAAA,MACrB;AAAA,IACF;AAGA,eAAW,CAAC,MAAM,OAAO,KAAK,gBAAgB,WAAW,QAAQ,GAAG;AAClE,YAAM,oBAAoB,cAAc,IAAI;AAC5C,YAAM,WAAW,QAAQ,MAAM,iBAAiB;AAChD,UAAI,CAAC,UAAU;AACb;AAAA,MACF;AACA,iBAAW,CAAC,QAAQ,OAAO,KAAK,QAAQ,QAAQ,GAAG;AACjD,YAAI,UAAU,UAAU;AACtB,gBAAM,YAAY,SAAS,MAA+B;AAC1D,cAAI,aAAa,OAAO,cAAc,YAAY,eAAe,WAAW;AAC1E,sBAAU,UAAU;AAAA,UACtB;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,MAAI,QAAQ,OAAO;AACjB,sBAAkB,QAAQ,KAAK;AAAA,EACjC;AAGA,MAAI,OAAO,KAAK,QAAQ,cAAc,CAAC,CAAC,EAAE,WAAW,GAAG;AACtD,WAAO,QAAQ;AAAA,EACjB;AAEA,SAAO,cAAc,OAAO;AAC9B;",
  "names": []
}
