{
  "version": 3,
  "sources": ["../../src/helpers/parameters.ts"],
  "sourcesContent": ["import type { OpenAPIV3_1 } from '@scalar/openapi-types'\n\nimport type { Header, Request } from '@/types'\n\nimport { inferSchemaType } from './schemas'\n\n/**\n * Extracts parameters from a Postman request and converts them to OpenAPI parameter objects.\n * Processes query, path, and header parameters from the request URL and headers.\n */\nexport function extractParameters(request: Request): OpenAPIV3_1.ParameterObject[] {\n  const parameters: OpenAPIV3_1.ParameterObject[] = []\n  const parameterMap: Map<string, OpenAPIV3_1.ParameterObject> = new Map()\n\n  if (typeof request === 'string' || !request.url) {\n    return parameters\n  }\n\n  const url = typeof request.url === 'string' ? { raw: request.url } : request.url\n\n  // Process query parameters\n  if (url.query) {\n    url.query.forEach((param) => {\n      const paramObj = createParameterObject(param, 'query')\n      if (paramObj.name) {\n        parameterMap.set(paramObj.name, paramObj)\n      }\n    })\n  }\n\n  // Process path parameters\n  if (url.variable) {\n    url.variable.forEach((param) => {\n      const paramObj = createParameterObject(param, 'path')\n      if (paramObj.name) {\n        parameterMap.set(paramObj.name, paramObj)\n      }\n    })\n  }\n\n  // Include variables extracted from url.path array\n  if (url.path) {\n    const pathArray = Array.isArray(url.path) ? url.path : [url.path]\n    const extractedVariables = extractPathVariablesFromPathArray(pathArray)\n    extractedVariables.forEach((varName) => {\n      if (!parameterMap.has(varName)) {\n        parameterMap.set(varName, {\n          name: varName,\n          in: 'path',\n          required: true,\n          schema: {\n            type: 'string',\n          },\n        })\n      }\n    })\n  }\n\n  // Process header parameters\n  if (request.header && Array.isArray(request.header)) {\n    request.header.forEach((header: Header) => {\n      const paramObj = createParameterObject(header, 'header')\n      if (paramObj.name) {\n        parameterMap.set(paramObj.name, paramObj)\n      }\n    })\n  }\n\n  return Array.from(parameterMap.values())\n}\n\n/**\n * Helper function to extract variables from the url.path array.\n */\nfunction extractPathVariablesFromPathArray(pathArray: (string | { type: string; value: string })[]): string[] {\n  const variables: string[] = []\n  const variableRegex = /{{\\s*([\\w.-]+)\\s*}}/\n\n  pathArray.forEach((segment) => {\n    const segmentString = typeof segment === 'string' ? segment : segment.value\n    const match = segmentString.match(variableRegex)\n    if (match?.[1]) {\n      variables.push(match[1])\n    }\n  })\n\n  return variables\n}\n\n/**\n * Creates an OpenAPI parameter object from a Postman parameter.\n */\nexport function createParameterObject(param: any, paramIn: 'query' | 'path' | 'header'): OpenAPIV3_1.ParameterObject {\n  const parameter: OpenAPIV3_1.ParameterObject = {\n    name: param.key || '',\n    in: paramIn,\n    description: param.description,\n  }\n\n  // Path parameters are always required in OpenAPI\n  if (paramIn === 'path') {\n    parameter.required = true\n  } else if (paramIn === 'query') {\n    // Check if the parameter is required based on description or name\n    const isRequired =\n      param.description?.toLowerCase().includes('[required]') || (param.key && param.key.toLowerCase() === 'required')\n\n    if (isRequired) {\n      parameter.required = true\n      // Remove '[required]' from the description\n      if (parameter.description) {\n        parameter.description = parameter.description.replace(/\\[required\\]/gi, '').trim()\n      }\n    }\n  }\n\n  if (param.value !== undefined) {\n    parameter.example = param.value\n    // For path parameters, prefer string type unless value is explicitly a number type\n    // This prevents converting string IDs like \"testId\" to integers\n    if (paramIn === 'path') {\n      // Path parameters are typically strings (IDs, slugs, etc.)\n      // Only use number/integer if the value is actually a number type, not a string\n      if (typeof param.value === 'number') {\n        parameter.schema = inferSchemaType(param.value)\n      } else {\n        // For strings (including empty strings), default to string type\n        parameter.schema = { type: 'string' }\n      }\n    } else {\n      parameter.schema = inferSchemaType(param.value)\n    }\n  } else {\n    parameter.schema = { type: 'string' } // Default to string if no value is provided\n  }\n\n  // Add x-scalar-disabled extension if parameter is disabled\n  if (param.disabled === true) {\n    // @ts-expect-error - x-scalar-disabled is not a valid parameter object property\n    parameter['x-scalar-disabled'] = true\n  }\n\n  return parameter\n}\n"],
  "mappings": "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",
  "names": []
}
