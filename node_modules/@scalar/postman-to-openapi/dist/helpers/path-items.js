import { processAuth } from "./auth.js";
import { parseMdTable } from "./markdown.js";
import { extractParameters } from "./parameters.js";
import { processPostResponseScripts } from "./post-response-scripts.js";
import { processPreRequestScripts } from "./pre-request-scripts.js";
import { extractRequestBody } from "./request-body.js";
import { extractResponses } from "./responses.js";
import { extractPathFromUrl, extractPathParameterNames, extractServerFromUrl, normalizePath } from "./urls.js";
function ensureRequestBodyContent(requestBody) {
  const content = requestBody.content ?? {};
  if (Object.keys(content).length === 0) {
    requestBody.content = {
      "text/plain": {}
    };
    return;
  }
  if ("text/plain" in content) {
    const textContent = content["text/plain"];
    if (!textContent?.schema || textContent.schema && Object.keys(textContent.schema).length === 0) {
      content["text/plain"] = {};
    }
  }
}
function processItem(item, parentTags = [], parentPath = "") {
  const paths = {};
  const components = {};
  const serverUsage = [];
  if ("item" in item && Array.isArray(item.item)) {
    const newParentTags = item.name ? [...parentTags, item.name] : parentTags;
    item.item.forEach((childItem) => {
      const childResult = processItem(childItem, newParentTags, `${parentPath}/${item.name || ""}`);
      for (const [pathKey, pathItem2] of Object.entries(childResult.paths)) {
        if (!paths[pathKey]) {
          paths[pathKey] = pathItem2;
        } else {
          paths[pathKey] = {
            ...paths[pathKey],
            ...pathItem2
          };
        }
      }
      if (childResult.components.securitySchemes) {
        components.securitySchemes = {
          ...components.securitySchemes,
          ...childResult.components.securitySchemes
        };
      }
      serverUsage.push(...childResult.serverUsage);
    });
    return { paths, components, serverUsage };
  }
  if (!("request" in item)) {
    return { paths, components, serverUsage };
  }
  const { request, name, response } = item;
  const method = (typeof request === "string" ? "get" : request.method || "get").toLowerCase();
  const requestUrl = typeof request === "string" ? request : typeof request.url === "string" ? request.url : request.url?.raw ?? "";
  const path = extractPathFromUrl(requestUrl);
  const normalizedPath = normalizePath(path);
  const serverUrl = extractServerFromUrl(requestUrl);
  if (serverUrl) {
    serverUsage.push({
      serverUrl,
      path: normalizedPath,
      method
    });
  }
  const pathParameterNames = extractPathParameterNames(normalizedPath);
  const { operationId, summary } = extractOperationInfo(name);
  const description = typeof request === "string" ? "" : typeof request.description === "string" ? request.description : request.description?.content ?? "";
  const operationObject = {
    tags: parentTags.length > 0 ? [parentTags.join(" > ")] : void 0,
    summary,
    description,
    responses: extractResponses(response || [], item),
    parameters: []
  };
  const preRequestScript = processPreRequestScripts(item.event);
  if (preRequestScript) {
    operationObject["x-pre-request"] = preRequestScript;
  }
  const postResponseScript = processPostResponseScripts(item.event);
  if (postResponseScript) {
    operationObject["x-post-response"] = postResponseScript;
  }
  if (operationId) {
    operationObject.operationId = operationId;
  }
  const extractedParameters = extractParameters(request);
  const mergedParameters = /* @__PURE__ */ new Map();
  extractedParameters.forEach((param) => {
    if (param.name) {
      if (param.in === "path" && !pathParameterNames.includes(param.name)) {
        return;
      }
      mergedParameters.set(param.name, param);
    }
  });
  if (operationObject.description) {
    const { descriptionWithoutTable, parametersFromTable } = parseParametersFromDescription(operationObject.description);
    operationObject.description = descriptionWithoutTable.trim();
    parametersFromTable.forEach((param) => {
      if (param.name) {
        if (param.in === "path" && !pathParameterNames.includes(param.name)) {
          return;
        }
        mergedParameters.set(param.name, param);
      }
    });
  }
  if (mergedParameters.size > 0) {
    operationObject.parameters = Array.from(mergedParameters.values());
  }
  if (typeof request !== "string" && request.auth) {
    if (!operationObject.security) {
      operationObject.security = [];
    }
    const { securitySchemes, security } = processAuth(request.auth);
    if (!components.securitySchemes) {
      components.securitySchemes = {};
    }
    components.securitySchemes = {
      ...components.securitySchemes,
      ...securitySchemes
    };
    operationObject.security.push(...security);
  }
  if (typeof request !== "string" && request.body) {
    const requestBody = extractRequestBody(request.body);
    ensureRequestBodyContent(requestBody);
    if (requestBody.content && Object.keys(requestBody.content).length > 0) {
      operationObject.requestBody = requestBody;
    }
  }
  if (!paths[path]) {
    paths[path] = {};
  }
  const pathItem = paths[path];
  pathItem[method] = operationObject;
  return { paths, components, serverUsage };
}
function parseParametersFromDescription(description) {
  const lines = description.split("\n");
  let inTable = false;
  const tableLines = [];
  const descriptionLines = [];
  for (const line of lines) {
    if (line.trim().startsWith("|")) {
      while (descriptionLines.length > 0 && (descriptionLines[descriptionLines.length - 1]?.trim() === "" || descriptionLines[descriptionLines.length - 1]?.trim().startsWith("#"))) {
        descriptionLines.pop();
      }
      inTable = true;
    }
    if (inTable) {
      tableLines.push(line);
      if (!line.trim().startsWith("|") && !line.trim().match(/^-+$/)) {
        inTable = false;
      }
    } else {
      descriptionLines.push(line);
    }
  }
  const tableMarkdown = tableLines.join("\n");
  const parsedTable = parseMdTable(tableMarkdown);
  const parametersFromTable = Object.values(parsedTable).map((paramData) => {
    const row = paramData;
    if (row.object !== "query" && row.object !== "header" && row.object !== "path") {
      return void 0;
    }
    if (!row.name) {
      return void 0;
    }
    const param = {
      name: row.name,
      in: row.object,
      description: row.description,
      required: row.required === "true",
      schema: { type: row.type || "string" }
    };
    if (row.example) {
      param.example = row.example;
    }
    return param;
  }).filter((param) => Boolean(param));
  const descriptionWithoutTable = descriptionLines.join("\n");
  return { descriptionWithoutTable, parametersFromTable };
}
function extractOperationInfo(name) {
  if (!name) {
    return { operationId: void 0, summary: void 0 };
  }
  const match = name.match(/\[([^[\]]{0,1000})\]$/);
  if (!match) {
    return { operationId: void 0, summary: name };
  }
  const operationId = match[1];
  const lastBracketIndex = name.lastIndexOf("[");
  const summary = name.substring(0, lastBracketIndex).trim();
  return { operationId, summary };
}
export {
  processItem
};
//# sourceMappingURL=path-items.js.map
