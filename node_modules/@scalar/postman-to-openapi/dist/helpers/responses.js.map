{
  "version": 3,
  "sources": ["../../src/helpers/responses.ts"],
  "sourcesContent": ["import type { OpenAPIV3_1 } from '@scalar/openapi-types'\n\nimport type { HeaderList, Item, Response } from '@/types'\n\nimport { inferSchemaFromExample } from './schemas'\nimport { extractStatusCodesFromTests } from './status-codes'\n\n/**\n * Extracts and converts Postman response objects to OpenAPI response objects.\n * Processes response status codes, descriptions, headers, and body content,\n * inferring schemas from example responses when possible.\n */\nexport function extractResponses(responses: Response[], item?: Item): OpenAPIV3_1.ResponsesObject | undefined {\n  // Extract status codes from tests\n  const statusCodes = item ? extractStatusCodesFromTests(item) : []\n\n  // Create a map of status codes to descriptions from responses\n  const responseMap = responses.reduce((acc, response) => {\n    const statusCode = response.code?.toString() || 'default'\n    acc[statusCode] = {\n      description: response.status || 'Successful response',\n      headers: extractHeaders(response.header),\n      content: {\n        'application/json': {\n          schema: inferSchemaFromExample(response.body || ''),\n          examples: {\n            default: tryParseJson(response.body || ''),\n          },\n        },\n      },\n    }\n    return acc\n  }, {} as OpenAPIV3_1.ResponsesObject)\n\n  // Add status codes from tests if not already present\n  statusCodes.forEach((code) => {\n    const codeStr = code.toString()\n    if (!responseMap[codeStr]) {\n      responseMap[codeStr] = {\n        description: 'Successful response',\n        content: {\n          'application/json': {},\n        },\n      }\n    }\n  })\n\n  if (Object.keys(responseMap).length === 0) {\n    return undefined\n  }\n\n  return responseMap\n}\n\nfunction extractHeaders(\n  headers: HeaderList | string | null | undefined,\n): { [key: string]: OpenAPIV3_1.HeaderObject } | undefined {\n  if (!headers || typeof headers === 'string') {\n    return undefined\n  }\n  const openapiHeaders: { [key: string]: OpenAPIV3_1.HeaderObject } = {}\n  if (Array.isArray(headers)) {\n    headers.forEach((header) => {\n      openapiHeaders[header.key] = {\n        schema: {\n          type: 'string',\n          examples: [header.value],\n        },\n      }\n    })\n  }\n  return openapiHeaders\n}\n\nfunction tryParseJson(jsonString: string): Record<string, unknown> {\n  try {\n    return JSON.parse(jsonString) as Record<string, unknown>\n  } catch (_e) {\n    return { rawContent: jsonString }\n  }\n}\n"],
  "mappings": "AAIA,SAAS,8BAA8B;AACvC,SAAS,mCAAmC;AAOrC,SAAS,iBAAiB,WAAuB,MAAsD;AAE5G,QAAM,cAAc,OAAO,4BAA4B,IAAI,IAAI,CAAC;AAGhE,QAAM,cAAc,UAAU,OAAO,CAAC,KAAK,aAAa;AACtD,UAAM,aAAa,SAAS,MAAM,SAAS,KAAK;AAChD,QAAI,UAAU,IAAI;AAAA,MAChB,aAAa,SAAS,UAAU;AAAA,MAChC,SAAS,eAAe,SAAS,MAAM;AAAA,MACvC,SAAS;AAAA,QACP,oBAAoB;AAAA,UAClB,QAAQ,uBAAuB,SAAS,QAAQ,EAAE;AAAA,UAClD,UAAU;AAAA,YACR,SAAS,aAAa,SAAS,QAAQ,EAAE;AAAA,UAC3C;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAgC;AAGpC,cAAY,QAAQ,CAAC,SAAS;AAC5B,UAAM,UAAU,KAAK,SAAS;AAC9B,QAAI,CAAC,YAAY,OAAO,GAAG;AACzB,kBAAY,OAAO,IAAI;AAAA,QACrB,aAAa;AAAA,QACb,SAAS;AAAA,UACP,oBAAoB,CAAC;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AAED,MAAI,OAAO,KAAK,WAAW,EAAE,WAAW,GAAG;AACzC,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEA,SAAS,eACP,SACyD;AACzD,MAAI,CAAC,WAAW,OAAO,YAAY,UAAU;AAC3C,WAAO;AAAA,EACT;AACA,QAAM,iBAA8D,CAAC;AACrE,MAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,YAAQ,QAAQ,CAAC,WAAW;AAC1B,qBAAe,OAAO,GAAG,IAAI;AAAA,QAC3B,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU,CAAC,OAAO,KAAK;AAAA,QACzB;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAEA,SAAS,aAAa,YAA6C;AACjE,MAAI;AACF,WAAO,KAAK,MAAM,UAAU;AAAA,EAC9B,SAAS,IAAI;AACX,WAAO,EAAE,YAAY,WAAW;AAAA,EAClC;AACF;",
  "names": []
}
