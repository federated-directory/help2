{
  "version": 3,
  "sources": ["../../src/helpers/path-items.ts"],
  "sourcesContent": ["import type { OpenAPIV3_1 } from '@scalar/openapi-types'\n\nimport type { Item, ItemGroup } from '@/types'\n\nimport { processAuth } from './auth'\nimport { parseMdTable } from './markdown'\nimport { extractParameters } from './parameters'\nimport { processPostResponseScripts } from './post-response-scripts'\nimport { processPreRequestScripts } from './pre-request-scripts'\nimport { extractRequestBody } from './request-body'\nimport { extractResponses } from './responses'\nimport { extractPathFromUrl, extractPathParameterNames, extractServerFromUrl, normalizePath } from './urls'\n\ntype HttpMethods = 'get' | 'put' | 'post' | 'delete' | 'options' | 'head' | 'patch' | 'trace'\n\n/**\n * Information about server usage for an operation.\n */\nexport type ServerUsage = {\n  serverUrl: string\n  path: string\n  method: HttpMethods\n}\n\nfunction ensureRequestBodyContent(requestBody: OpenAPIV3_1.RequestBodyObject): void {\n  const content = requestBody.content ?? {}\n\n  if (Object.keys(content).length === 0) {\n    requestBody.content = {\n      'text/plain': {},\n    }\n    return\n  }\n\n  if ('text/plain' in content) {\n    const textContent = content['text/plain']\n    if (!textContent?.schema || (textContent.schema && Object.keys(textContent.schema).length === 0)) {\n      content['text/plain'] = {}\n    }\n  }\n}\n\n/**\n * Processes a Postman collection item or item group and returns\n * the corresponding OpenAPI paths and components.\n * Handles nested item groups, extracts request details, and generates corresponding\n * OpenAPI path items and operations.\n */\nexport function processItem(\n  item: Item | ItemGroup,\n  parentTags: string[] = [],\n  parentPath: string = '',\n): {\n  paths: OpenAPIV3_1.PathsObject\n  components: OpenAPIV3_1.ComponentsObject\n  serverUsage: ServerUsage[]\n} {\n  const paths: OpenAPIV3_1.PathsObject = {}\n  const components: OpenAPIV3_1.ComponentsObject = {}\n  const serverUsage: ServerUsage[] = []\n\n  if ('item' in item && Array.isArray(item.item)) {\n    const newParentTags = item.name ? [...parentTags, item.name] : parentTags\n    item.item.forEach((childItem) => {\n      const childResult = processItem(childItem, newParentTags, `${parentPath}/${item.name || ''}`)\n      // Merge child paths and components\n      for (const [pathKey, pathItem] of Object.entries(childResult.paths)) {\n        if (!paths[pathKey]) {\n          paths[pathKey] = pathItem\n        } else {\n          paths[pathKey] = {\n            ...paths[pathKey],\n            ...pathItem,\n          }\n        }\n      }\n\n      // Merge components.securitySchemes\n      if (childResult.components.securitySchemes) {\n        components.securitySchemes = {\n          ...components.securitySchemes,\n          ...childResult.components.securitySchemes,\n        }\n      }\n\n      // Merge server usage\n      serverUsage.push(...childResult.serverUsage)\n    })\n    return { paths, components, serverUsage }\n  }\n\n  if (!('request' in item)) {\n    return { paths, components, serverUsage }\n  }\n\n  const { request, name, response } = item\n  const method = (typeof request === 'string' ? 'get' : request.method || 'get').toLowerCase() as HttpMethods\n\n  const requestUrl =\n    typeof request === 'string' ? request : typeof request.url === 'string' ? request.url : (request.url?.raw ?? '')\n\n  const path = extractPathFromUrl(requestUrl)\n\n  // Normalize path parameters from ':param' to '{param}'\n  const normalizedPath = normalizePath(path)\n\n  // Extract server URL from request URL\n  const serverUrl = extractServerFromUrl(requestUrl)\n  if (serverUrl) {\n    serverUsage.push({\n      serverUrl,\n      path: normalizedPath,\n      method,\n    })\n  }\n\n  // Extract path parameter names\n  const pathParameterNames = extractPathParameterNames(normalizedPath)\n\n  // Extract operation ID if present\n  const { operationId, summary } = extractOperationInfo(name)\n\n  const description =\n    typeof request === 'string'\n      ? ''\n      : typeof request.description === 'string'\n        ? request.description\n        : (request.description?.content ?? '')\n\n  const operationObject: OpenAPIV3_1.OperationObject = {\n    tags: parentTags.length > 0 ? [parentTags.join(' > ')] : undefined,\n    summary,\n    description,\n    responses: extractResponses(response || [], item),\n    parameters: [],\n  }\n\n  // Add pre-request scripts if present\n  const preRequestScript = processPreRequestScripts(item.event)\n  if (preRequestScript) {\n    operationObject['x-pre-request'] = preRequestScript\n  }\n\n  // Add post-response scripts if present\n  const postResponseScript = processPostResponseScripts(item.event)\n  if (postResponseScript) {\n    operationObject['x-post-response'] = postResponseScript\n  }\n\n  // Only add operationId if it was explicitly provided\n  if (operationId) {\n    operationObject.operationId = operationId\n  }\n\n  // Extract parameters from the request (query, path, header)\n  // This should always happen, regardless of whether a description exists\n  const extractedParameters = extractParameters(request)\n\n  // Merge parameters, giving priority to those from the Markdown table if description exists\n  const mergedParameters = new Map<string, OpenAPIV3_1.ParameterObject>()\n\n  // Add extracted parameters, filtering out path parameters not in the path\n  extractedParameters.forEach((param) => {\n    if (param.name) {\n      if (param.in === 'path' && !pathParameterNames.includes(param.name)) {\n        return\n      }\n      mergedParameters.set(param.name, param)\n    }\n  })\n\n  // Parse parameters from the description's Markdown table if description exists\n  if (operationObject.description) {\n    const { descriptionWithoutTable, parametersFromTable } = parseParametersFromDescription(operationObject.description)\n    operationObject.description = descriptionWithoutTable.trim()\n\n    // Add parameters from table, filtering out path parameters not in the path\n    // These take priority over extracted parameters\n    parametersFromTable.forEach((param) => {\n      if (param.name) {\n        if (param.in === 'path' && !pathParameterNames.includes(param.name)) {\n          return\n        }\n        mergedParameters.set(param.name, param)\n      }\n    })\n  }\n\n  // Set parameters if we have any\n  if (mergedParameters.size > 0) {\n    operationObject.parameters = Array.from(mergedParameters.values())\n  }\n\n  if (typeof request !== 'string' && request.auth) {\n    if (!operationObject.security) {\n      operationObject.security = []\n    }\n    const { securitySchemes, security } = processAuth(request.auth)\n\n    if (!components.securitySchemes) {\n      components.securitySchemes = {}\n    }\n    components.securitySchemes = {\n      ...components.securitySchemes,\n      ...securitySchemes,\n    }\n\n    operationObject.security.push(...security)\n  }\n\n  // Allow request bodies for all methods (including GET) if body is present\n  if (typeof request !== 'string' && request.body) {\n    const requestBody = extractRequestBody(request.body)\n    ensureRequestBodyContent(requestBody)\n    // Only add requestBody if it has content\n    if (requestBody.content && Object.keys(requestBody.content).length > 0) {\n      operationObject.requestBody = requestBody\n    }\n  }\n\n  if (!paths[path]) {\n    paths[path] = {}\n  }\n  const pathItem = paths[path] as OpenAPIV3_1.PathItemObject\n  pathItem[method] = operationObject\n\n  return { paths, components, serverUsage }\n}\n\n// Helper function to parse parameters from the description if it is markdown\ntype ParameterRow = {\n  object?: 'query' | 'header' | 'path' | string\n  name?: string\n  description?: string\n  required?: string\n  type?: string\n  example?: string\n}\n\nfunction parseParametersFromDescription(description: string): {\n  descriptionWithoutTable: string\n  parametersFromTable: OpenAPIV3_1.ParameterObject[]\n} {\n  const lines = description.split('\\n')\n  let inTable = false\n  const tableLines: string[] = []\n  const descriptionLines: string[] = []\n\n  for (const line of lines) {\n    // Detect the start of the table\n    if (line.trim().startsWith('|')) {\n      // Remove any preceding headers or empty lines before the table\n      while (\n        descriptionLines.length > 0 &&\n        (descriptionLines[descriptionLines.length - 1]?.trim() === '' ||\n          descriptionLines[descriptionLines.length - 1]?.trim().startsWith('#'))\n      ) {\n        descriptionLines.pop()\n      }\n\n      // Start collecting table lines\n      inTable = true\n    }\n\n    if (inTable) {\n      tableLines.push(line)\n      // Detect the end of the table (any line that doesn't start with '|', excluding the alignment line)\n      if (!line.trim().startsWith('|') && !line.trim().match(/^-+$/)) {\n        inTable = false\n      }\n    } else {\n      descriptionLines.push(line)\n    }\n  }\n\n  const tableMarkdown = tableLines.join('\\n')\n  const parsedTable = parseMdTable(tableMarkdown)\n  const parametersFromTable = Object.values(parsedTable)\n    .map((paramData) => {\n      const row = paramData as ParameterRow\n      if (row.object !== 'query' && row.object !== 'header' && row.object !== 'path') {\n        return undefined\n      }\n\n      if (!row.name) {\n        return undefined\n      }\n\n      const param: OpenAPIV3_1.ParameterObject = {\n        name: row.name,\n        in: row.object,\n        description: row.description,\n        required: row.required === 'true',\n        schema: { type: row.type || 'string' },\n      }\n\n      if (row.example) {\n        param.example = row.example\n      }\n\n      return param\n    })\n    .filter((param): param is OpenAPIV3_1.ParameterObject => Boolean(param))\n\n  const descriptionWithoutTable = descriptionLines.join('\\n')\n  return { descriptionWithoutTable, parametersFromTable }\n}\n\n// Instead of using regex with \\s*, let's split this into two steps\nfunction extractOperationInfo(name: string | undefined) {\n  if (!name) {\n    return { operationId: undefined, summary: undefined }\n  }\n\n  // First check if the string ends with something in brackets\n  const match = name.match(/\\[([^[\\]]{0,1000})\\]$/)\n  if (!match) {\n    return { operationId: undefined, summary: name }\n  }\n\n  // Get the operation ID from inside brackets\n  const operationId = match[1]\n\n  // Trim the brackets part from the end using string operations instead of regex\n  const lastBracketIndex = name.lastIndexOf('[')\n  const summary = name.substring(0, lastBracketIndex).trim()\n\n  return { operationId, summary }\n}\n"],
  "mappings": "AAIA,SAAS,mBAAmB;AAC5B,SAAS,oBAAoB;AAC7B,SAAS,yBAAyB;AAClC,SAAS,kCAAkC;AAC3C,SAAS,gCAAgC;AACzC,SAAS,0BAA0B;AACnC,SAAS,wBAAwB;AACjC,SAAS,oBAAoB,2BAA2B,sBAAsB,qBAAqB;AAanG,SAAS,yBAAyB,aAAkD;AAClF,QAAM,UAAU,YAAY,WAAW,CAAC;AAExC,MAAI,OAAO,KAAK,OAAO,EAAE,WAAW,GAAG;AACrC,gBAAY,UAAU;AAAA,MACpB,cAAc,CAAC;AAAA,IACjB;AACA;AAAA,EACF;AAEA,MAAI,gBAAgB,SAAS;AAC3B,UAAM,cAAc,QAAQ,YAAY;AACxC,QAAI,CAAC,aAAa,UAAW,YAAY,UAAU,OAAO,KAAK,YAAY,MAAM,EAAE,WAAW,GAAI;AAChG,cAAQ,YAAY,IAAI,CAAC;AAAA,IAC3B;AAAA,EACF;AACF;AAQO,SAAS,YACd,MACA,aAAuB,CAAC,GACxB,aAAqB,IAKrB;AACA,QAAM,QAAiC,CAAC;AACxC,QAAM,aAA2C,CAAC;AAClD,QAAM,cAA6B,CAAC;AAEpC,MAAI,UAAU,QAAQ,MAAM,QAAQ,KAAK,IAAI,GAAG;AAC9C,UAAM,gBAAgB,KAAK,OAAO,CAAC,GAAG,YAAY,KAAK,IAAI,IAAI;AAC/D,SAAK,KAAK,QAAQ,CAAC,cAAc;AAC/B,YAAM,cAAc,YAAY,WAAW,eAAe,GAAG,UAAU,IAAI,KAAK,QAAQ,EAAE,EAAE;AAE5F,iBAAW,CAAC,SAASA,SAAQ,KAAK,OAAO,QAAQ,YAAY,KAAK,GAAG;AACnE,YAAI,CAAC,MAAM,OAAO,GAAG;AACnB,gBAAM,OAAO,IAAIA;AAAA,QACnB,OAAO;AACL,gBAAM,OAAO,IAAI;AAAA,YACf,GAAG,MAAM,OAAO;AAAA,YAChB,GAAGA;AAAA,UACL;AAAA,QACF;AAAA,MACF;AAGA,UAAI,YAAY,WAAW,iBAAiB;AAC1C,mBAAW,kBAAkB;AAAA,UAC3B,GAAG,WAAW;AAAA,UACd,GAAG,YAAY,WAAW;AAAA,QAC5B;AAAA,MACF;AAGA,kBAAY,KAAK,GAAG,YAAY,WAAW;AAAA,IAC7C,CAAC;AACD,WAAO,EAAE,OAAO,YAAY,YAAY;AAAA,EAC1C;AAEA,MAAI,EAAE,aAAa,OAAO;AACxB,WAAO,EAAE,OAAO,YAAY,YAAY;AAAA,EAC1C;AAEA,QAAM,EAAE,SAAS,MAAM,SAAS,IAAI;AACpC,QAAM,UAAU,OAAO,YAAY,WAAW,QAAQ,QAAQ,UAAU,OAAO,YAAY;AAE3F,QAAM,aACJ,OAAO,YAAY,WAAW,UAAU,OAAO,QAAQ,QAAQ,WAAW,QAAQ,MAAO,QAAQ,KAAK,OAAO;AAE/G,QAAM,OAAO,mBAAmB,UAAU;AAG1C,QAAM,iBAAiB,cAAc,IAAI;AAGzC,QAAM,YAAY,qBAAqB,UAAU;AACjD,MAAI,WAAW;AACb,gBAAY,KAAK;AAAA,MACf;AAAA,MACA,MAAM;AAAA,MACN;AAAA,IACF,CAAC;AAAA,EACH;AAGA,QAAM,qBAAqB,0BAA0B,cAAc;AAGnE,QAAM,EAAE,aAAa,QAAQ,IAAI,qBAAqB,IAAI;AAE1D,QAAM,cACJ,OAAO,YAAY,WACf,KACA,OAAO,QAAQ,gBAAgB,WAC7B,QAAQ,cACP,QAAQ,aAAa,WAAW;AAEzC,QAAM,kBAA+C;AAAA,IACnD,MAAM,WAAW,SAAS,IAAI,CAAC,WAAW,KAAK,KAAK,CAAC,IAAI;AAAA,IACzD;AAAA,IACA;AAAA,IACA,WAAW,iBAAiB,YAAY,CAAC,GAAG,IAAI;AAAA,IAChD,YAAY,CAAC;AAAA,EACf;AAGA,QAAM,mBAAmB,yBAAyB,KAAK,KAAK;AAC5D,MAAI,kBAAkB;AACpB,oBAAgB,eAAe,IAAI;AAAA,EACrC;AAGA,QAAM,qBAAqB,2BAA2B,KAAK,KAAK;AAChE,MAAI,oBAAoB;AACtB,oBAAgB,iBAAiB,IAAI;AAAA,EACvC;AAGA,MAAI,aAAa;AACf,oBAAgB,cAAc;AAAA,EAChC;AAIA,QAAM,sBAAsB,kBAAkB,OAAO;AAGrD,QAAM,mBAAmB,oBAAI,IAAyC;AAGtE,sBAAoB,QAAQ,CAAC,UAAU;AACrC,QAAI,MAAM,MAAM;AACd,UAAI,MAAM,OAAO,UAAU,CAAC,mBAAmB,SAAS,MAAM,IAAI,GAAG;AACnE;AAAA,MACF;AACA,uBAAiB,IAAI,MAAM,MAAM,KAAK;AAAA,IACxC;AAAA,EACF,CAAC;AAGD,MAAI,gBAAgB,aAAa;AAC/B,UAAM,EAAE,yBAAyB,oBAAoB,IAAI,+BAA+B,gBAAgB,WAAW;AACnH,oBAAgB,cAAc,wBAAwB,KAAK;AAI3D,wBAAoB,QAAQ,CAAC,UAAU;AACrC,UAAI,MAAM,MAAM;AACd,YAAI,MAAM,OAAO,UAAU,CAAC,mBAAmB,SAAS,MAAM,IAAI,GAAG;AACnE;AAAA,QACF;AACA,yBAAiB,IAAI,MAAM,MAAM,KAAK;AAAA,MACxC;AAAA,IACF,CAAC;AAAA,EACH;AAGA,MAAI,iBAAiB,OAAO,GAAG;AAC7B,oBAAgB,aAAa,MAAM,KAAK,iBAAiB,OAAO,CAAC;AAAA,EACnE;AAEA,MAAI,OAAO,YAAY,YAAY,QAAQ,MAAM;AAC/C,QAAI,CAAC,gBAAgB,UAAU;AAC7B,sBAAgB,WAAW,CAAC;AAAA,IAC9B;AACA,UAAM,EAAE,iBAAiB,SAAS,IAAI,YAAY,QAAQ,IAAI;AAE9D,QAAI,CAAC,WAAW,iBAAiB;AAC/B,iBAAW,kBAAkB,CAAC;AAAA,IAChC;AACA,eAAW,kBAAkB;AAAA,MAC3B,GAAG,WAAW;AAAA,MACd,GAAG;AAAA,IACL;AAEA,oBAAgB,SAAS,KAAK,GAAG,QAAQ;AAAA,EAC3C;AAGA,MAAI,OAAO,YAAY,YAAY,QAAQ,MAAM;AAC/C,UAAM,cAAc,mBAAmB,QAAQ,IAAI;AACnD,6BAAyB,WAAW;AAEpC,QAAI,YAAY,WAAW,OAAO,KAAK,YAAY,OAAO,EAAE,SAAS,GAAG;AACtE,sBAAgB,cAAc;AAAA,IAChC;AAAA,EACF;AAEA,MAAI,CAAC,MAAM,IAAI,GAAG;AAChB,UAAM,IAAI,IAAI,CAAC;AAAA,EACjB;AACA,QAAM,WAAW,MAAM,IAAI;AAC3B,WAAS,MAAM,IAAI;AAEnB,SAAO,EAAE,OAAO,YAAY,YAAY;AAC1C;AAYA,SAAS,+BAA+B,aAGtC;AACA,QAAM,QAAQ,YAAY,MAAM,IAAI;AACpC,MAAI,UAAU;AACd,QAAM,aAAuB,CAAC;AAC9B,QAAM,mBAA6B,CAAC;AAEpC,aAAW,QAAQ,OAAO;AAExB,QAAI,KAAK,KAAK,EAAE,WAAW,GAAG,GAAG;AAE/B,aACE,iBAAiB,SAAS,MACzB,iBAAiB,iBAAiB,SAAS,CAAC,GAAG,KAAK,MAAM,MACzD,iBAAiB,iBAAiB,SAAS,CAAC,GAAG,KAAK,EAAE,WAAW,GAAG,IACtE;AACA,yBAAiB,IAAI;AAAA,MACvB;AAGA,gBAAU;AAAA,IACZ;AAEA,QAAI,SAAS;AACX,iBAAW,KAAK,IAAI;AAEpB,UAAI,CAAC,KAAK,KAAK,EAAE,WAAW,GAAG,KAAK,CAAC,KAAK,KAAK,EAAE,MAAM,MAAM,GAAG;AAC9D,kBAAU;AAAA,MACZ;AAAA,IACF,OAAO;AACL,uBAAiB,KAAK,IAAI;AAAA,IAC5B;AAAA,EACF;AAEA,QAAM,gBAAgB,WAAW,KAAK,IAAI;AAC1C,QAAM,cAAc,aAAa,aAAa;AAC9C,QAAM,sBAAsB,OAAO,OAAO,WAAW,EAClD,IAAI,CAAC,cAAc;AAClB,UAAM,MAAM;AACZ,QAAI,IAAI,WAAW,WAAW,IAAI,WAAW,YAAY,IAAI,WAAW,QAAQ;AAC9E,aAAO;AAAA,IACT;AAEA,QAAI,CAAC,IAAI,MAAM;AACb,aAAO;AAAA,IACT;AAEA,UAAM,QAAqC;AAAA,MACzC,MAAM,IAAI;AAAA,MACV,IAAI,IAAI;AAAA,MACR,aAAa,IAAI;AAAA,MACjB,UAAU,IAAI,aAAa;AAAA,MAC3B,QAAQ,EAAE,MAAM,IAAI,QAAQ,SAAS;AAAA,IACvC;AAEA,QAAI,IAAI,SAAS;AACf,YAAM,UAAU,IAAI;AAAA,IACtB;AAEA,WAAO;AAAA,EACT,CAAC,EACA,OAAO,CAAC,UAAgD,QAAQ,KAAK,CAAC;AAEzE,QAAM,0BAA0B,iBAAiB,KAAK,IAAI;AAC1D,SAAO,EAAE,yBAAyB,oBAAoB;AACxD;AAGA,SAAS,qBAAqB,MAA0B;AACtD,MAAI,CAAC,MAAM;AACT,WAAO,EAAE,aAAa,QAAW,SAAS,OAAU;AAAA,EACtD;AAGA,QAAM,QAAQ,KAAK,MAAM,uBAAuB;AAChD,MAAI,CAAC,OAAO;AACV,WAAO,EAAE,aAAa,QAAW,SAAS,KAAK;AAAA,EACjD;AAGA,QAAM,cAAc,MAAM,CAAC;AAG3B,QAAM,mBAAmB,KAAK,YAAY,GAAG;AAC7C,QAAM,UAAU,KAAK,UAAU,GAAG,gBAAgB,EAAE,KAAK;AAEzD,SAAO,EAAE,aAAa,QAAQ;AAChC;",
  "names": ["pathItem"]
}
