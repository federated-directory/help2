{
  "version": 3,
  "sources": ["../../src/helpers/servers.ts"],
  "sourcesContent": ["import type { OpenAPIV3_1 } from '@scalar/openapi-types'\n\nimport type { ServerUsage } from './path-items'\n\n/**\n * Information about where a server should be placed.\n */\ntype ServerPlacement = {\n  document: OpenAPIV3_1.ServerObject[]\n  pathItems: Map<string, OpenAPIV3_1.ServerObject[]>\n  operations: Map<string, Map<string, OpenAPIV3_1.ServerObject[]>>\n}\n\n/**\n * Creates a unique key for a path/method combination.\n * Used to properly deduplicate operations in a Set since JavaScript Sets\n * compare objects by reference, not by value.\n */\nfunction createOperationKey(path: string, method: string): string {\n  return `${path}::${method}`\n}\n\n/**\n * Parses an operation key back into its path and method components.\n */\nfunction parseOperationKey(key: string): { path: string; method: string } {\n  const separatorIndex = key.lastIndexOf('::')\n  return {\n    path: key.substring(0, separatorIndex),\n    method: key.substring(separatorIndex + 2),\n  }\n}\n\n/**\n * Analyzes server usage and determines the optimal placement level for each server.\n * Placement logic:\n * - If server used in all paths \u2192 document level\n * - If server used in multiple paths \u2192 document level\n * - If server used in multiple operations within 1 path \u2192 path item level\n * - If server used in only 1 operation \u2192 operation level\n */\nexport function analyzeServerDistribution(serverUsage: ServerUsage[], allUniquePaths: Set<string>): ServerPlacement {\n  const placement: ServerPlacement = {\n    document: [],\n    pathItems: new Map(),\n    operations: new Map(),\n  }\n\n  if (serverUsage.length === 0) {\n    return placement\n  }\n\n  // Build a map: serverUrl -> Set<operationKey>\n  // Using string keys instead of objects because JavaScript Sets compare by reference\n  const serverMap = new Map<string, Set<string>>()\n\n  for (const usage of serverUsage) {\n    if (!serverMap.has(usage.serverUrl)) {\n      serverMap.set(usage.serverUrl, new Set())\n    }\n    serverMap.get(usage.serverUrl)!.add(createOperationKey(usage.path, usage.method))\n  }\n\n  // For each server, determine its placement\n  for (const [serverUrl, operationKeys] of serverMap.entries()) {\n    const serverObject: OpenAPIV3_1.ServerObject = { url: serverUrl }\n\n    // Parse operation keys back to path/method pairs\n    const operations = Array.from(operationKeys).map(parseOperationKey)\n\n    // Count unique paths this server appears in\n    const uniquePaths = new Set(operations.map((op) => op.path))\n    const pathCount = uniquePaths.size\n\n    // Check if server covers all paths in the document\n    const coversAllPaths =\n      allUniquePaths.size > 0 &&\n      uniquePaths.size === allUniquePaths.size &&\n      Array.from(uniquePaths).every((path) => allUniquePaths.has(path))\n\n    if (coversAllPaths || pathCount > 1) {\n      // Server used in all paths or multiple paths \u2192 document level\n      placement.document.push(serverObject)\n    } else if (operations.length > 1) {\n      // Server used in multiple operations within 1 path \u2192 path item level\n      const path = operations[0]?.path\n      if (!path) {\n        continue\n      }\n      if (!placement.pathItems.has(path)) {\n        placement.pathItems.set(path, [])\n      }\n      placement.pathItems.get(path)!.push(serverObject)\n    } else {\n      // Server used in only 1 operation \u2192 operation level\n      const operation = operations[0]\n      if (!operation) {\n        continue\n      }\n      // Use nested Map structure: path -> method -> servers\n      if (!placement.operations.has(operation.path)) {\n        placement.operations.set(operation.path, new Map())\n      }\n      const methodsMap = placement.operations.get(operation.path)!\n      if (!methodsMap.has(operation.method)) {\n        methodsMap.set(operation.method, [])\n      }\n      methodsMap.get(operation.method)!.push(serverObject)\n    }\n  }\n\n  return placement\n}\n"],
  "mappings": "AAkBA,SAAS,mBAAmB,MAAc,QAAwB;AAChE,SAAO,GAAG,IAAI,KAAK,MAAM;AAC3B;AAKA,SAAS,kBAAkB,KAA+C;AACxE,QAAM,iBAAiB,IAAI,YAAY,IAAI;AAC3C,SAAO;AAAA,IACL,MAAM,IAAI,UAAU,GAAG,cAAc;AAAA,IACrC,QAAQ,IAAI,UAAU,iBAAiB,CAAC;AAAA,EAC1C;AACF;AAUO,SAAS,0BAA0B,aAA4B,gBAA8C;AAClH,QAAM,YAA6B;AAAA,IACjC,UAAU,CAAC;AAAA,IACX,WAAW,oBAAI,IAAI;AAAA,IACnB,YAAY,oBAAI,IAAI;AAAA,EACtB;AAEA,MAAI,YAAY,WAAW,GAAG;AAC5B,WAAO;AAAA,EACT;AAIA,QAAM,YAAY,oBAAI,IAAyB;AAE/C,aAAW,SAAS,aAAa;AAC/B,QAAI,CAAC,UAAU,IAAI,MAAM,SAAS,GAAG;AACnC,gBAAU,IAAI,MAAM,WAAW,oBAAI,IAAI,CAAC;AAAA,IAC1C;AACA,cAAU,IAAI,MAAM,SAAS,EAAG,IAAI,mBAAmB,MAAM,MAAM,MAAM,MAAM,CAAC;AAAA,EAClF;AAGA,aAAW,CAAC,WAAW,aAAa,KAAK,UAAU,QAAQ,GAAG;AAC5D,UAAM,eAAyC,EAAE,KAAK,UAAU;AAGhE,UAAM,aAAa,MAAM,KAAK,aAAa,EAAE,IAAI,iBAAiB;AAGlE,UAAM,cAAc,IAAI,IAAI,WAAW,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;AAC3D,UAAM,YAAY,YAAY;AAG9B,UAAM,iBACJ,eAAe,OAAO,KACtB,YAAY,SAAS,eAAe,QACpC,MAAM,KAAK,WAAW,EAAE,MAAM,CAAC,SAAS,eAAe,IAAI,IAAI,CAAC;AAElE,QAAI,kBAAkB,YAAY,GAAG;AAEnC,gBAAU,SAAS,KAAK,YAAY;AAAA,IACtC,WAAW,WAAW,SAAS,GAAG;AAEhC,YAAM,OAAO,WAAW,CAAC,GAAG;AAC5B,UAAI,CAAC,MAAM;AACT;AAAA,MACF;AACA,UAAI,CAAC,UAAU,UAAU,IAAI,IAAI,GAAG;AAClC,kBAAU,UAAU,IAAI,MAAM,CAAC,CAAC;AAAA,MAClC;AACA,gBAAU,UAAU,IAAI,IAAI,EAAG,KAAK,YAAY;AAAA,IAClD,OAAO;AAEL,YAAM,YAAY,WAAW,CAAC;AAC9B,UAAI,CAAC,WAAW;AACd;AAAA,MACF;AAEA,UAAI,CAAC,UAAU,WAAW,IAAI,UAAU,IAAI,GAAG;AAC7C,kBAAU,WAAW,IAAI,UAAU,MAAM,oBAAI,IAAI,CAAC;AAAA,MACpD;AACA,YAAM,aAAa,UAAU,WAAW,IAAI,UAAU,IAAI;AAC1D,UAAI,CAAC,WAAW,IAAI,UAAU,MAAM,GAAG;AACrC,mBAAW,IAAI,UAAU,QAAQ,CAAC,CAAC;AAAA,MACrC;AACA,iBAAW,IAAI,UAAU,MAAM,EAAG,KAAK,YAAY;AAAA,IACrD;AAAA,EACF;AAEA,SAAO;AACT;",
  "names": []
}
