{
  "version": 3,
  "sources": ["../../src/arrays/sort.ts"],
  "sourcesContent": ["/** Date sorting for arrays */\nexport function timeSort<T>(a: T, b: T, key?: T extends object ? keyof T : never): number {\n  const valA = ((key ? a[key] : a) ?? '') as string | Date\n  const valB = ((key ? b[key] : b) ?? '') as string | Date\n  return new Date(valA).getTime() - new Date(valB).getTime()\n}\n\n/** Sort alphanumerically */\nexport function alphaSort<T>(a: T, b: T, key?: T extends object ? keyof T : never): number {\n  const valA = String((key ? a[key] : a) ?? '')\n  const valB = String((key ? b[key] : b) ?? '')\n\n  return valA.localeCompare(valB)\n}\n\n/**\n * Immutably sorts an array by a custom order specified in a separate list.\n *\n * This function efficiently sorts an array of objects according to the order\n * provided in a separate array of identifiers. Items found in the order list\n * will appear at the front, sorted by their position in the order list. Items\n * whose identifier is not found in the order list will appear at the end,\n * maintaining their original relative order.\n *\n * Sorting is performed in O(n) time relative to the array size, making this\n * function suitable for large arrays.\n *\n * @template T - The type of the array elements, which must contain an identifier key of type string.\n * @template K - The key of T used as the identifier for sorting.\n * @param arr - The array of objects to be sorted.\n * @param order - The array of string identifiers indicating the desired order.\n * @param idKey - The object key in each element of arr to use for lookup/matching in order.\n * @returns A new sorted array, where items matching the order array come first (in order), and unmatched items follow.\n *\n * @example\n * const items = [\n *   { id: 'a', name: 'Alpha' },\n *   { id: 'b', name: 'Bravo' },\n *   { id: 'c', name: 'Charlie' }\n * ];\n * const order = ['c', 'a'];\n * const sorted = sortByOrder(items, order, 'id');\n * // Result:\n * // [\n * //   { id: 'c', name: 'Charlie' },\n * //   { id: 'a', name: 'Alpha' },\n * //   { id: 'b', name: 'Bravo' }\n * // ]\n */\nexport function sortByOrder<T extends Record<K, string>, K extends keyof T>(arr: T[], order: string[], idKey: K): T[] {\n  // Map the order to keep a single lookup table\n  const orderMap: Record<string, number> = {}\n  order.forEach((e, idx) => (orderMap[e] = idx))\n\n  const sorted: T[] = []\n  const untagged: T[] = []\n\n  arr.forEach((e) => {\n    const sortedIdx = orderMap[e[idKey]] ?? -1\n    if (sortedIdx >= 0) {\n      sorted[sortedIdx] = e\n    } else {\n      untagged.push(e)\n    }\n  })\n\n  return sorted.filter(Boolean).concat(...untagged)\n}\n"],
  "mappings": "AACO,SAAS,SAAY,GAAM,GAAM,KAAkD;AACxF,QAAM,QAAS,MAAM,EAAE,GAAG,IAAI,MAAM;AACpC,QAAM,QAAS,MAAM,EAAE,GAAG,IAAI,MAAM;AACpC,SAAO,IAAI,KAAK,IAAI,EAAE,QAAQ,IAAI,IAAI,KAAK,IAAI,EAAE,QAAQ;AAC3D;AAGO,SAAS,UAAa,GAAM,GAAM,KAAkD;AACzF,QAAM,OAAO,QAAQ,MAAM,EAAE,GAAG,IAAI,MAAM,EAAE;AAC5C,QAAM,OAAO,QAAQ,MAAM,EAAE,GAAG,IAAI,MAAM,EAAE;AAE5C,SAAO,KAAK,cAAc,IAAI;AAChC;AAoCO,SAAS,YAA4D,KAAU,OAAiB,OAAe;AAEpH,QAAM,WAAmC,CAAC;AAC1C,QAAM,QAAQ,CAAC,GAAG,QAAS,SAAS,CAAC,IAAI,GAAI;AAE7C,QAAM,SAAc,CAAC;AACrB,QAAM,WAAgB,CAAC;AAEvB,MAAI,QAAQ,CAAC,MAAM;AACjB,UAAM,YAAY,SAAS,EAAE,KAAK,CAAC,KAAK;AACxC,QAAI,aAAa,GAAG;AAClB,aAAO,SAAS,IAAI;AAAA,IACtB,OAAO;AACL,eAAS,KAAK,CAAC;AAAA,IACjB;AAAA,EACF,CAAC;AAED,SAAO,OAAO,OAAO,OAAO,EAAE,OAAO,GAAG,QAAQ;AAClD;",
  "names": []
}
