{
  "version": 3,
  "sources": ["../../src/mutator-record/mutations.ts"],
  "sourcesContent": ["import { type Path, type PathValue, getNestedValue, setNestedValue } from '../nested'\n\n/** Type safe include */\nexport function includes<T>(arr: readonly T[], x: T): boolean {\n  return arr.includes(x)\n}\n\n/** Nested paths of the data type */\ntype MutationPath<D> = Path<D>\n\n/** Mutation record for a specific value and data type */\ntype MutationRecord<T, D> = {\n  prev: T\n  value: T\n  path: MutationPath<D>\n}\n\n/** Mutation effect function that is run provisioned with the data object */\ntype MutationEffect<T> = (data: T) => void\n\n/** Effect record that holds the possible change trigger keys for the effect to run */\ntype MutationEffectRecord<T> = {\n  /** Side effect name for debug logs */\n  name: string\n  /**\n   * List of path keys to run effect for. Any nested changes will also trigger the side effect\n   * ex. 'foo.bar'\n   */\n  triggers: string[]\n  /**\n   * Side effect function to run. A copy of the updated data value is passed to the handler\n   */\n  effect: MutationEffect<T> // Effect to run\n}\n\n/**\n * Mutation tracker to allow history roll back/forwards\n *\n * Associates a history record with a specific data object and allows rolling back of that\n * specific object history.\n */\nexport class Mutation<DataType> {\n  /** Object reference for the given data to be tracked */\n  parentData: DataType\n  /** Maximum number of record to keep (how many times you can 'undo' a mutation) */\n  maxRecords: number\n  /** List of all mutation records */\n  records: MutationRecord<any, DataType>[] = []\n  /** List of side effect handlers to run whenever the data changes */\n  sideEffects: MutationEffectRecord<DataType>[] = []\n  /** Active mutation index. Allows rolling forward and backwards */\n  idx = 0\n  /** Optional debug messages */\n  debug: boolean\n\n  constructor(parentData: DataType, maxRecords = 5000, debug = false) {\n    this.maxRecords = maxRecords\n    this.parentData = parentData\n    this.debug = debug\n  }\n\n  /** Mutate without saving a record. Private function. */\n  _unsavedMutate<K extends MutationPath<DataType>>(path: K, value: PathValue<DataType, K>) {\n    setNestedValue(this.parentData, path, value)\n    this.runSideEffects(path)\n  }\n\n  /** Side effects must take ONLY an object of the specified type and act on it */\n  addSideEffect(triggers: string[], effect: MutationEffect<DataType>, name: string, immediate = true) {\n    this.sideEffects.push({ triggers, effect, name })\n    if (immediate) {\n      effect(this.parentData)\n      if (this.debug) {\n        console.info(`Running mutation side effect: ${name}`, 'debug')\n      }\n    }\n  }\n\n  /** Runs all side effects that match the path trigger */\n  runSideEffects(path: MutationPath<DataType>) {\n    this.sideEffects.forEach(({ effect, triggers, name }) => {\n      const triggerEffect = triggers.some((trigger) => path.includes(trigger)) || path.length < 1\n      if (triggerEffect) {\n        effect(this.parentData)\n        if (this.debug) {\n          console.info(`Running mutation side effect: ${name}`, 'debug')\n        }\n      }\n    })\n  }\n\n  /** Mutate an object with the new property value and run side effects */\n  mutate<K extends MutationPath<DataType>>(\n    /** Path to nested set */\n    path: K,\n    /** New value to set */\n    value: PathValue<DataType, K>,\n    /** Optional explicit previous value. Otherwise the current value will be used */\n    previousValue: PathValue<DataType, K> | null = null,\n  ) {\n    // If already rolled back then clear roll forward values before assigning new mutation\n    if (this.idx < this.records.length - 1) {\n      this.records.splice(this.idx + 1)\n    }\n\n    // Check for a change\n    const prev = getNestedValue(this.parentData, path)\n    if (prev === value) {\n      return\n    }\n\n    // Save new mutation record with previous value\n    setNestedValue(this.parentData, path, value)\n    this.runSideEffects(path)\n\n    this.records.push({\n      prev: previousValue ?? prev, // Optional explicit previous value\n      value,\n      path,\n    })\n\n    // Save new position to end\n    this.idx = this.records.length - 1\n\n    // If the record has overflowed remove first entry\n    if (this.records.length > this.maxRecords) {\n      this.records.shift()\n    }\n\n    if (this.debug) {\n      console.info(`Set object '${this.idx}' '${path}' to ${value}`, 'debug')\n    }\n  }\n\n  /** Undo the previous mutation */\n  undo() {\n    if (this.idx < 0 || this.records.length < 1) {\n      return false\n    }\n\n    if (this.debug) {\n      console.info('Undoing Mutation', 'debug')\n    }\n\n    const record = this.records[this.idx]\n    this.idx -= 1\n    if (record) {\n      this._unsavedMutate(record.path, record.prev)\n    }\n\n    return true\n  }\n\n  /** Roll forward to the next available mutation if its exists */\n  redo() {\n    if (this.idx > this.records.length - 2) {\n      return false\n    }\n\n    if (this.debug) {\n      console.info('Redoing Mutation', 'debug')\n    }\n\n    const record = this.records[this.idx + 1]\n    this.idx += 1\n    if (record) {\n      this._unsavedMutate(record.path, record.value)\n    }\n\n    return true\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
