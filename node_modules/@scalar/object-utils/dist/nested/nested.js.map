{
  "version": 3,
  "sources": ["../../src/nested/nested.ts"],
  "sourcesContent": ["/**\n * Deep setting\n *\n * Derived from @url https://github.com/react-hook-form/react-hook-form/tree/011fad503cc8d4543892f8e847b9bd58c1d9400f/src/types/path\n *\n */\nimport type { ArrayKey, BrowserNativeObject, IsAny, IsEqual, IsTuple, Primitive, TupleKeys } from './common'\n\n/**\n * Helper function to break apart T1 and check if any are equal to T2\n *\n * See {@link IsEqual}\n */\ntype AnyIsEqual<T1, T2> = T1 extends T2 ? (IsEqual<T1, T2> extends true ? true : never) : never\n\n/**\n * Helper type for recursively constructing paths through a type.\n * This actually constructs the strings and recurses into nested\n * object types.\n *\n * See {@link Path}\n */\ntype PathImpl<K extends string | number, V, TraversedTypes> = V extends Primitive | BrowserNativeObject\n  ? `${K}`\n  : // Check so that we don't recurse into the same type\n    // by ensuring that the types are mutually assignable\n    // mutually required to avoid false positives of subtypes\n    true extends AnyIsEqual<TraversedTypes, V>\n    ? `${K}`\n    : `${K}` | `${K}.${PathInternal<V, TraversedTypes | V>}`\n\n/**\n * Helper type for recursively constructing paths through a type.\n * This obscures the internal type param TraversedTypes from exported contract.\n *\n * See {@link Path}\n */\ntype PathInternal<T, TraversedTypes = T> = T extends ReadonlyArray<infer V>\n  ? IsTuple<T> extends true\n    ? {\n        [K in TupleKeys<T>]-?: PathImpl<K & string, T[K], TraversedTypes>\n      }[TupleKeys<T>]\n    : PathImpl<ArrayKey, V, TraversedTypes>\n  : {\n      [K in keyof T]-?: PathImpl<K & string, T[K], TraversedTypes>\n    }[keyof T]\n\n/**\n * Type which eagerly collects all paths through a type\n * @typeParam T - type which should be introspected\n * @example\n * ```\n * Path<{foo: {bar: string}}> = 'foo' | 'foo.bar'\n * ```\n */\n// We want to explode the union type and process each individually\n// so assignable types don't leak onto the stack from the base.\ntype Path<T> = T extends any ? PathInternal<T> : never\n\n/**\n * Helper type for recursively constructing paths through a type.\n * This actually constructs the strings and recurses into nested\n * object types.\n *\n * See {@link ArrayPath}\n */\ntype ArrayPathImpl<K extends string | number, V, TraversedTypes> = V extends Primitive | BrowserNativeObject\n  ? IsAny<V> extends true\n    ? string\n    : never\n  : V extends ReadonlyArray<infer U>\n    ? U extends Primitive | BrowserNativeObject\n      ? IsAny<V> extends true\n        ? string\n        : never\n      : // Check so that we don't recurse into the same type\n        // by ensuring that the types are mutually assignable\n        // mutually required to avoid false positives of subtypes\n        true extends AnyIsEqual<TraversedTypes, V>\n        ? never\n        : `${K}` | `${K}.${ArrayPathInternal<V, TraversedTypes | V>}`\n    : true extends AnyIsEqual<TraversedTypes, V>\n      ? never\n      : `${K}.${ArrayPathInternal<V, TraversedTypes | V>}`\n\n/**\n * Helper type for recursively constructing paths through a type.\n * This obscures the internal type param TraversedTypes from exported contract.\n *\n * See {@link ArrayPath}\n */\ntype ArrayPathInternal<T, TraversedTypes = T> = T extends ReadonlyArray<infer V>\n  ? IsTuple<T> extends true\n    ? {\n        [K in TupleKeys<T>]-?: ArrayPathImpl<K & string, T[K], TraversedTypes>\n      }[TupleKeys<T>]\n    : ArrayPathImpl<ArrayKey, V, TraversedTypes>\n  : {\n      [K in keyof T]-?: ArrayPathImpl<K & string, T[K], TraversedTypes>\n    }[keyof T]\n\n/**\n * Type which eagerly collects all paths through a type which point to an array\n * type.\n * @typeParam T - type which should be introspected.\n * @example\n * ```\n * Path<{foo: {bar: string[], baz: number[]}}> = 'foo.bar' | 'foo.baz'\n * ```\n */\n// We want to explode the union type and process each individually\n// so assignable types don't leak onto the stack from the base.\ntype ArrayPath<T> = T extends any ? ArrayPathInternal<T> : never\n\n/**\n * Type to evaluate the type which the given path points to.\n * @typeParam T - deeply nested type which is indexed by the path\n * @typeParam P - path into the deeply nested type\n * @example\n * ```\n * PathValue<{foo: {bar: string}}, 'foo.bar'> = string\n * PathValue<[number, string], '1'> = string\n * ```\n */\ntype PathValue<T, P extends Path<T> | ArrayPath<T>> = T extends any\n  ? P extends keyof T\n    ? T[P]\n    : P extends `${infer K}.${infer R}`\n      ? K extends keyof T\n        ? R extends Path<T[K]>\n          ? PathValue<T[K], R>\n          : never\n        : K extends `${ArrayKey}`\n          ? T extends ReadonlyArray<infer V>\n            ? PathValue<V, R & Path<V>>\n            : never\n          : never\n      : P extends `${ArrayKey}`\n        ? T extends ReadonlyArray<infer V>\n          ? V\n          : never\n        : never\n  : never\n\n// ---------------------------------------------------------------------------\n// ---------------------------------------------------------------------------\n// ---------------------------------------------------------------------------\n\n/**\n * Set a nested value from an object using a dot separated path.\n *\n * Basic Path: `'foo.bar'`\n *\n * With Array: `'foo.1.bar'`\n */\nexport function setNestedValue<T, P extends Path<T>>(obj: T, path: P, value: PathValue<T, P>) {\n  const keys = path.split('.')\n\n  // Loop over to get the nested object reference. Then assign the value to it\n  keys.reduce((acc, current, idx) => {\n    if (idx === keys.length - 1) {\n      acc[current] = value\n    }\n\n    return acc[current]\n  }, obj as any)\n\n  return obj\n}\n\n/**\n * Get a nested value from an object using a dot separated path.\n *\n * Basic Path: `'foo.bar'`\n *\n * With Array: `'foo.1.bar'`\n */\nexport function getNestedValue<T, P extends Path<T>>(obj: T, path: P) {\n  const keys = path.split('.')\n\n  // Loop over to get the nested object reference. Then assign the value to it\n  return keys.reduce((acc, current) => {\n    return acc[current]\n  }, obj as any)\n}\n\n/** Export the path and path value types to create other setter functions */\nexport type { Path, PathValue }\n"],
  "mappings": "AA2JO,SAAS,eAAqC,KAAQ,MAAS,OAAwB;AAC5F,QAAM,OAAO,KAAK,MAAM,GAAG;AAG3B,OAAK,OAAO,CAAC,KAAK,SAAS,QAAQ;AACjC,QAAI,QAAQ,KAAK,SAAS,GAAG;AAC3B,UAAI,OAAO,IAAI;AAAA,IACjB;AAEA,WAAO,IAAI,OAAO;AAAA,EACpB,GAAG,GAAU;AAEb,SAAO;AACT;AASO,SAAS,eAAqC,KAAQ,MAAS;AACpE,QAAM,OAAO,KAAK,MAAM,GAAG;AAG3B,SAAO,KAAK,OAAO,CAAC,KAAK,YAAY;AACnC,WAAO,IAAI,OAAO;AAAA,EACpB,GAAG,GAAU;AACf;",
  "names": []
}
