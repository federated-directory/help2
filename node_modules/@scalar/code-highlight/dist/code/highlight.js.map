{
  "version": 3,
  "sources": ["../../src/code/highlight.ts"],
  "sourcesContent": ["import type { Element, Root } from 'hast'\nimport type { LanguageFn } from 'highlight.js'\nimport rehypeParse from 'rehype-parse'\nimport rehypeStringify from 'rehype-stringify'\nimport { type Plugin, unified } from 'unified'\nimport { visit } from 'unist-util-visit'\n\nimport { lowlightLanguageMappings } from '@/constants'\nimport { rehypeHighlight } from '@/rehype-highlight'\n\nimport { codeBlockLinesPlugin } from './line-numbers'\n\n/**\n * Syntax highlights a code string using the `rehype-highlight` library.\n */\nexport function syntaxHighlight(\n  codeString: string,\n  options: {\n    lang: string\n    languages: Record<string, LanguageFn>\n    lineNumbers?: boolean\n    maskCredentials?: string | string[]\n  },\n) {\n  // Simple restriction on credentials to prevent unexpected behavior\n  const credentials = (\n    typeof options?.maskCredentials === 'string' ? [options.maskCredentials] : (options?.maskCredentials ?? [])\n  ).filter((c) => {\n    // Credentials must be at least 3 characters to mask.\n    if (c.length < 3) {\n      return false\n    }\n\n    return true\n  })\n\n  // Classname is used by lowlight to select the language model\n  const className = `language-${lowlightLanguageMappings[options.lang] ?? options.lang}`\n\n  // biome-ignore lint/suspicious/noEmptyBlockStatements: empty plugin\n  const nullPlugin = (() => {}) satisfies Plugin\n\n  const html = unified()\n    // Parses markdown\n    .use(rehypeParse, { fragment: true })\n    // Raw code string must be injected after initial hast parsing\n    // so that HTML code is not parsed into the hast tree\n    .use(injectRawCodeStringPlugin(codeString))\n    // Syntax highlighting\n    .use(rehypeHighlight, {\n      languages: options.languages,\n    })\n    .use(options?.lineNumbers ? codeBlockLinesPlugin : nullPlugin)\n    // Converts the HTML AST to a string\n    .use(rehypeStringify)\n    // Run the pipeline\n    .processSync(`<pre><code class=\"${className}\"></code></pre>`)\n\n  const htmlString = html.toString()\n\n  // Replace any credentials with a wrapper element\n  return credentials.length\n    ? credentials.reduce(\n        (acc, credential) =>\n          acc\n            .split(credential)\n            .join(`<span class=\"credential\"><span class=\"credential-value\">${credential}</span></span>`),\n        htmlString,\n      )\n    : htmlString\n}\n\n/**\n * To prevent unified from parsing any content of the code string we inject\n * it as a raw text node into the AST tree as a child of the code element\n */\nfunction injectRawCodeStringPlugin(rawCodeString: string) {\n  return () => (tree: Root) => {\n    visit(tree, 'element', (node: Element) => {\n      if (node.tagName === 'code') {\n        node.children.push({\n          type: 'text',\n          value: rawCodeString,\n        })\n      }\n    })\n  }\n}\n"],
  "mappings": "AAEA,OAAO,iBAAiB;AACxB,OAAO,qBAAqB;AAC5B,SAAsB,eAAe;AACrC,SAAS,aAAa;AAEtB,SAAS,gCAAgC;AACzC,SAAS,uBAAuB;AAEhC,SAAS,4BAA4B;AAK9B,SAAS,gBACd,YACA,SAMA;AAEA,QAAM,eACJ,OAAO,SAAS,oBAAoB,WAAW,CAAC,QAAQ,eAAe,IAAK,SAAS,mBAAmB,CAAC,GACzG,OAAO,CAAC,MAAM;AAEd,QAAI,EAAE,SAAS,GAAG;AAChB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT,CAAC;AAGD,QAAM,YAAY,YAAY,yBAAyB,QAAQ,IAAI,KAAK,QAAQ,IAAI;AAGpF,QAAM,aAAc,MAAM;AAAA,EAAC;AAE3B,QAAM,OAAO,QAAQ,EAElB,IAAI,aAAa,EAAE,UAAU,KAAK,CAAC,EAGnC,IAAI,0BAA0B,UAAU,CAAC,EAEzC,IAAI,iBAAiB;AAAA,IACpB,WAAW,QAAQ;AAAA,EACrB,CAAC,EACA,IAAI,SAAS,cAAc,uBAAuB,UAAU,EAE5D,IAAI,eAAe,EAEnB,YAAY,qBAAqB,SAAS,iBAAiB;AAE9D,QAAM,aAAa,KAAK,SAAS;AAGjC,SAAO,YAAY,SACf,YAAY;AAAA,IACV,CAAC,KAAK,eACJ,IACG,MAAM,UAAU,EAChB,KAAK,2DAA2D,UAAU,gBAAgB;AAAA,IAC/F;AAAA,EACF,IACA;AACN;AAMA,SAAS,0BAA0B,eAAuB;AACxD,SAAO,MAAM,CAAC,SAAe;AAC3B,UAAM,MAAM,WAAW,CAAC,SAAkB;AACxC,UAAI,KAAK,YAAY,QAAQ;AAC3B,aAAK,SAAS,KAAK;AAAA,UACjB,MAAM;AAAA,UACN,OAAO;AAAA,QACT,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACF;",
  "names": []
}
