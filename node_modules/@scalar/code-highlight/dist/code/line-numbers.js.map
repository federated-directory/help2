{
  "version": 3,
  "sources": ["../../src/code/line-numbers.ts"],
  "sourcesContent": ["import type { Element, ElementContent, Root, Text } from 'hast'\nimport { visit } from 'unist-util-visit'\n\n// ---------------------------------------------------------------------------\n// Line Numbering plugin\n\nfunction isText(element?: ElementContent): element is Text {\n  return element?.type === 'text'\n}\n\nfunction isElement(node?: ElementContent): node is Element {\n  return node?.type === 'element'\n}\n\nfunction textElement(value: string): Text {\n  return { type: 'text', value }\n}\n\nfunction lineBreak(): Text {\n  return { type: 'text', value: '\\n' }\n}\n\n/**\n * Adds lines to code blocks\n */\nexport function codeBlockLinesPlugin() {\n  return (tree: Root) => {\n    visit(tree, 'element', (node: Element, _i, parent: Root | Element | null) => {\n      if (parent?.type === 'element' && parent.tagName === 'pre' && node.tagName === 'code') {\n        let numLines = 0\n\n        // Wraps each line in a span\n        node.children = addLines(node)\n\n        // Adds a line break to the end of each line\n        node.children.forEach((child: ElementContent) => {\n          if (child.type === 'element' && child.tagName === 'span') {\n            const lastChild: ElementContent | undefined = child.children[child.children.length - 1]\n\n            if (lastChild && (!isText(lastChild) || (isText(lastChild) && !hasLineBreak(lastChild)))) {\n              child.children.push(lineBreak())\n              numLines++\n            }\n          }\n        })\n\n        // We need to maintain a count of the total lines to allow space for the labels\n        node.properties.style = [`--line-count: ${numLines};`, `--line-digits: ${numLines.toString().length};`]\n      }\n    })\n\n    // console.log('NUMBER OF LINES IS: ', numLines)\n  }\n}\n\n/**\n * Adds lines to a node recursively and returns them\n *\n * @param node - The node to add lines to\n * @param lines - The current lines\n * @param copyParent - Whether to copy the parent node to save the original node styles\n */\nfunction addLines(node: Element, lines: Element[] = [], copyParent?: boolean): Element[] {\n  const line = () => lines[lines.length - 1] ?? ((lines.push(createLine()) && lines[lines.length - 1]) || undefined)\n\n  node.children.forEach((child: ElementContent) => {\n    if (isText(child) && hasLineBreak(child)) {\n      const split: string[] = child.value.split(/\\n/)\n\n      split.forEach((content: string, i: number) => {\n        if (copyParent) {\n          line()?.children.push({ ...node, children: [textElement(content)] })\n        } else {\n          line()?.children.push(textElement(content))\n        }\n\n        i !== split.length - 1 && lines.push(createLine())\n      })\n    } else if (isElement(child) && child.children.some(hasLineBreak)) {\n      addLines(child, lines, true)\n    } else {\n      line()?.children.push(child)\n    }\n  })\n\n  return lines\n}\n\n/**\n * Creates a new line element\n *\n * @param children - The children the line should have initially\n */\nfunction createLine(...children: ElementContent[]): Element {\n  return {\n    type: 'element',\n    tagName: 'span',\n    properties: { class: ['line'] },\n    children,\n  }\n}\n\n/**\n * Checks if a node has a line break\n *\n * @param node - The node to check\n */\nfunction hasLineBreak(node: ElementContent): boolean {\n  return (isText(node) && /\\r?\\n/.test(node.value)) || (isElement(node) && node.children.some(hasLineBreak))\n}\n"],
  "mappings": "AACA,SAAS,aAAa;AAKtB,SAAS,OAAO,SAA2C;AACzD,SAAO,SAAS,SAAS;AAC3B;AAEA,SAAS,UAAU,MAAwC;AACzD,SAAO,MAAM,SAAS;AACxB;AAEA,SAAS,YAAY,OAAqB;AACxC,SAAO,EAAE,MAAM,QAAQ,MAAM;AAC/B;AAEA,SAAS,YAAkB;AACzB,SAAO,EAAE,MAAM,QAAQ,OAAO,KAAK;AACrC;AAKO,SAAS,uBAAuB;AACrC,SAAO,CAAC,SAAe;AACrB,UAAM,MAAM,WAAW,CAAC,MAAe,IAAI,WAAkC;AAC3E,UAAI,QAAQ,SAAS,aAAa,OAAO,YAAY,SAAS,KAAK,YAAY,QAAQ;AACrF,YAAI,WAAW;AAGf,aAAK,WAAW,SAAS,IAAI;AAG7B,aAAK,SAAS,QAAQ,CAAC,UAA0B;AAC/C,cAAI,MAAM,SAAS,aAAa,MAAM,YAAY,QAAQ;AACxD,kBAAM,YAAwC,MAAM,SAAS,MAAM,SAAS,SAAS,CAAC;AAEtF,gBAAI,cAAc,CAAC,OAAO,SAAS,KAAM,OAAO,SAAS,KAAK,CAAC,aAAa,SAAS,IAAK;AACxF,oBAAM,SAAS,KAAK,UAAU,CAAC;AAC/B;AAAA,YACF;AAAA,UACF;AAAA,QACF,CAAC;AAGD,aAAK,WAAW,QAAQ,CAAC,iBAAiB,QAAQ,KAAK,kBAAkB,SAAS,SAAS,EAAE,MAAM,GAAG;AAAA,MACxG;AAAA,IACF,CAAC;AAAA,EAGH;AACF;AASA,SAAS,SAAS,MAAe,QAAmB,CAAC,GAAG,YAAiC;AACvF,QAAM,OAAO,MAAM,MAAM,MAAM,SAAS,CAAC,MAAO,MAAM,KAAK,WAAW,CAAC,KAAK,MAAM,MAAM,SAAS,CAAC,KAAM;AAExG,OAAK,SAAS,QAAQ,CAAC,UAA0B;AAC/C,QAAI,OAAO,KAAK,KAAK,aAAa,KAAK,GAAG;AACxC,YAAM,QAAkB,MAAM,MAAM,MAAM,IAAI;AAE9C,YAAM,QAAQ,CAAC,SAAiB,MAAc;AAC5C,YAAI,YAAY;AACd,eAAK,GAAG,SAAS,KAAK,EAAE,GAAG,MAAM,UAAU,CAAC,YAAY,OAAO,CAAC,EAAE,CAAC;AAAA,QACrE,OAAO;AACL,eAAK,GAAG,SAAS,KAAK,YAAY,OAAO,CAAC;AAAA,QAC5C;AAEA,cAAM,MAAM,SAAS,KAAK,MAAM,KAAK,WAAW,CAAC;AAAA,MACnD,CAAC;AAAA,IACH,WAAW,UAAU,KAAK,KAAK,MAAM,SAAS,KAAK,YAAY,GAAG;AAChE,eAAS,OAAO,OAAO,IAAI;AAAA,IAC7B,OAAO;AACL,WAAK,GAAG,SAAS,KAAK,KAAK;AAAA,IAC7B;AAAA,EACF,CAAC;AAED,SAAO;AACT;AAOA,SAAS,cAAc,UAAqC;AAC1D,SAAO;AAAA,IACL,MAAM;AAAA,IACN,SAAS;AAAA,IACT,YAAY,EAAE,OAAO,CAAC,MAAM,EAAE;AAAA,IAC9B;AAAA,EACF;AACF;AAOA,SAAS,aAAa,MAA+B;AACnD,SAAQ,OAAO,IAAI,KAAK,QAAQ,KAAK,KAAK,KAAK,KAAO,UAAU,IAAI,KAAK,KAAK,SAAS,KAAK,YAAY;AAC1G;",
  "names": []
}
