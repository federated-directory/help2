import { isValidUrl as d, fetchSpecFromUrl as f, prettyPrintJson as v } from "@scalar/oas-utils/helpers";
import { ref as u, reactive as g, watch as m, toValue as a } from "vue";
import { parse as h } from "../helpers/parse.js";
import { createEmptySpecification as l } from "../helpers/createEmptySpecification.js";
const y = async ({ url: e, content: r }, o) => {
  if (e) {
    const i = performance.now(), s = d(e) ? await f(e, o) : await f(e), n = performance.now();
    return console.log(`fetch: ${Math.round(n - i)} ms (${e})`), console.log("size:", Math.round(s.length / 1024), "kB"), s;
  }
  const t = typeof r == "function" ? r() : r;
  if (typeof t == "string")
    return t;
  if (typeof t == "object")
    return v(t);
};
function C({
  specConfig: e,
  proxy: r
}) {
  const o = u(""), t = g(l()), i = u(null);
  function s(n) {
    return n ? h(n, {
      proxy: r ? a(r) : void 0
    }).then((c) => {
      i.value = null, Object.assign(t, {
        servers: [],
        ...c
      });
    }).catch((c) => {
      i.value = c.toString();
    }) : Object.assign(t, l());
  }
  return m(
    () => a(e),
    async (n) => {
      var c;
      if (n) {
        const p = (c = await y(n, a(r))) == null ? void 0 : c.trim();
        typeof p == "string" && (o.value = p);
      }
    },
    { immediate: !0, deep: !0 }
  ), m(o, () => {
    s(o.value);
  }), {
    rawSpec: o,
    parsedSpec: t,
    specErrors: i
  };
}
export {
  C as useReactiveSpec
};
