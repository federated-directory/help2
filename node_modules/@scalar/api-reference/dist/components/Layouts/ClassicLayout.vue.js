import { defineComponent as f, useSlots as g, computed as k, openBlock as i, createBlock as p, createSlots as S, withCtx as t, createVNode as d, unref as l, createCommentVNode as D, renderList as C, renderSlot as y, normalizeProps as M, guardReactiveProps as w } from "vue";
import h from "../ApiReferenceLayout.vue.js";
import v from "../ClassicHeader.vue.js";
import B from "../DarkModeToggle/DarkModeIconToggle.vue.js";
import H from "../../features/Search/SearchButton.vue.js";
const N = /* @__PURE__ */ f({
  __name: "ClassicLayout",
  props: {
    configuration: {},
    parsedSpec: {},
    rawSpec: {},
    isDark: { type: Boolean }
  },
  emits: ["toggleDarkMode", "updateContent"],
  setup(c) {
    const n = c, u = g(), s = k(() => ({ ...n.configuration, showSidebar: !1 }));
    return (e, o) => (i(), p(h, {
      configuration: s.value,
      parsedSpec: e.parsedSpec,
      rawSpec: e.rawSpec,
      onUpdateContent: o[1] || (o[1] = (r) => e.$emit("updateContent", r))
    }, S({
      "content-start": t(({ spec: r }) => [
        d(v, null, {
          "dark-mode-toggle": t(() => [
            n.configuration.hideDarkModeToggle ? D("", !0) : (i(), p(l(B), {
              key: 0,
              isDarkMode: e.isDark,
              onToggleDarkMode: o[0] || (o[0] = (a) => e.$emit("toggleDarkMode"))
            }, null, 8, ["isDarkMode"]))
          ]),
          default: t(() => [
            d(l(H), {
              class: "t-doc__sidebar",
              searchHotKey: s.value.searchHotKey,
              spec: r
            }, null, 8, ["searchHotKey", "spec"])
          ]),
          _: 2
        }, 1024)
      ]),
      _: 2
    }, [
      C(u, (r, a) => ({
        name: a,
        fn: t((m) => [
          y(e.$slots, a, M(w(m || {})))
        ])
      }))
    ]), 1032, ["configuration", "parsedSpec", "rawSpec"]));
  }
});
export {
  N as default
};
