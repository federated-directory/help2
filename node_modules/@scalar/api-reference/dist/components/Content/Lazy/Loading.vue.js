import { defineComponent as E, ref as v, watch as K, onMounted as M, withDirectives as $, openBlock as n, createElementBlock as f, normalizeClass as j, Fragment as g, renderList as k, createBlock as m, unref as o, withCtx as p, createCommentVNode as w, createVNode as T, createTextVNode as A, toDisplayString as F, vShow as H } from "vue";
import { lazyBus as P } from "./lazyBus.js";
import q from "../Tag/Tag.vue.js";
import G from "../Operation/Operation.vue.js";
import J from "../../Section/SectionContainer.vue.js";
import Q from "../../Section/Section.vue.js";
import R from "../../Section/SectionContent.vue.js";
import U from "../../Section/SectionHeader.vue.js";
import X from "../../Anchor/Anchor.vue.js";
import Y from "../Schema/Schema.vue.js";
import { getModels as h } from "../../../helpers/getModels.js";
import { scrollToId as x } from "../../../helpers/scrollToId.js";
import { useNavState as Z } from "../../../hooks/useNavState.js";
const fe = /* @__PURE__ */ E({
  __name: "Loading",
  props: {
    layout: { default: "default" },
    parsedSpec: {}
  },
  setup(L) {
    const i = L, C = v(!1), S = v([]), y = v([]), { getModelId: V, getSectionId: z, getTagId: B, hash: a, isIntersectionEnabled: I } = Z(), _ = v(i.layout !== "accordion" && a.value);
    K(
      () => {
        var r;
        return (r = i.parsedSpec.tags) == null ? void 0 : r.length;
      },
      (r) => {
        var e, u;
        if (!a.value || typeof r != "number" || !i.parsedSpec.tags)
          return;
        const l = z();
        if (l.startsWith("tag")) {
          let t = 0;
          const d = ((e = i.parsedSpec.tags) == null ? void 0 : e.findIndex(
            (b) => B(b) === l
          )) ?? 0, s = a.value.match(/tag\/([^/]+)\/([^/]+)\/(.+)/);
          if ((s == null ? void 0 : s.length) === 4) {
            const b = s[2], O = "/" + s[3];
            t = (u = i.parsedSpec.tags[d]) == null ? void 0 : u.operations.findIndex(
              ({ httpVerb: W, path: D }) => b === W && O === D
            );
          }
          const c = i.parsedSpec.tags[d];
          if (!c) return;
          c.name !== "default" && (C.value = l !== a.value && l.startsWith("tag")), S.value.push({
            ...c,
            lazyOperations: c.operations.slice(
              t,
              t + 2
            )
          });
        } else if (a.value.startsWith("model")) {
          const t = Object.keys(h(i.parsedSpec) ?? {}), [, d] = a.value.toLowerCase().split("/"), s = a.value === "models" ? 0 : t.findIndex((c) => c.toLowerCase() === d);
          if (s === -1) return;
          y.value = t.slice(s, s + 3);
        } else
          typeof window < "u" && x(a.value), setTimeout(() => I.value = !0, 1e3);
      },
      { immediate: !0 }
    );
    const N = P.on(({ id: r }) => {
      const l = a.value;
      !l || r !== l || (N(), setTimeout(() => {
        typeof window < "u" && x(l), _.value = !1, setTimeout(() => I.value = !0, 1e3);
      }, 300));
    });
    return M(() => {
      a.value || setTimeout(() => I.value = !0, 1e3);
    }), (r, l) => $((n(), f("div", {
      class: j(["references-loading", {
        "references-loading-hidden-tag": C.value,
        "references-loading-top-spacer": S.value.length
      }])
    }, [
      (n(!0), f(g, null, k(S.value, (e, u) => (n(), f(g, {
        key: e.name + u
      }, [
        e.operations && e.operations.length > 0 ? (n(), m(o(q), {
          key: 0,
          spec: r.parsedSpec,
          tag: e
        }, {
          default: p(() => [
            (n(!0), f(g, null, k(e.lazyOperations, (t) => (n(), m(o(G), {
              key: `${t.httpVerb}-${t.operationId}`,
              operation: t,
              tag: e
            }, null, 8, ["operation", "tag"]))), 128))
          ]),
          _: 2
        }, 1032, ["spec", "tag"])) : w("", !0)
      ], 64))), 128)),
      y.value.length ? (n(), m(o(J), { key: 0 }, {
        default: p(() => [
          (n(!0), f(g, null, k(y.value, (e) => (n(), m(o(Q), {
            key: e,
            label: e
          }, {
            default: p(() => {
              var u;
              return [
                (u = o(h)(r.parsedSpec)) != null && u[e] ? (n(), m(o(R), { key: 0 }, {
                  default: p(() => {
                    var t;
                    return [
                      T(o(U), { level: 2 }, {
                        default: p(() => [
                          T(o(X), {
                            id: o(V)(e)
                          }, {
                            default: p(() => {
                              var d;
                              return [
                                A(F(((d = o(h)(r.parsedSpec)) == null ? void 0 : d[e]).title ?? e), 1)
                              ];
                            }),
                            _: 2
                          }, 1032, ["id"])
                        ]),
                        _: 2
                      }, 1024),
                      T(o(Y), {
                        name: e,
                        noncollapsible: "",
                        value: (t = o(h)(r.parsedSpec)) == null ? void 0 : t[e]
                      }, null, 8, ["name", "value"])
                    ];
                  }),
                  _: 2
                }, 1024)) : w("", !0)
              ];
            }),
            _: 2
          }, 1032, ["label"]))), 128))
        ]),
        _: 1
      })) : w("", !0)
    ], 2)), [
      [H, _.value]
    ]);
  }
});
export {
  fe as default
};
