import { defineComponent, toRef, computed, createElementBlock, openBlock, createCommentVNode, createBlock, normalizeClass, renderSlot, Fragment, withCtx, createVNode, createTextVNode, toDisplayString, renderList, createSlots, unref } from "vue";
import { isDefined } from "@scalar/helpers/array/is-defined";
import { getResolvedRef } from "@scalar/workspace-store/helpers/get-resolved-ref";
import { isArraySchema, isStringSchema, isNumberSchema } from "@scalar/workspace-store/schemas/v3.1/strict/type-guards";
import ScreenReader from "../../ScreenReader.vue.js";
import { getSchemaType } from "./helpers/get-schema-type.js";
import { getModelName } from "./helpers/schema-name.js";
import _sfc_main$1 from "./RenderString.vue.js";
import SchemaPropertyDetail from "./SchemaPropertyDetail.vue.js";
import SchemaPropertyExamples from "./SchemaPropertyExamples.vue.js";
import Badge from "../../Badge/Badge.vue.js";
const _hoisted_1 = { class: "property-heading" };
const _hoisted_2 = {
  key: 1,
  class: "property-discriminator"
};
const _hoisted_3 = {
  key: 3,
  class: "property-additional"
};
const _hoisted_4 = {
  key: 4,
  class: "property-deprecated"
};
const _hoisted_5 = {
  key: 5,
  class: "property-const"
};
const _hoisted_6 = {
  key: 7,
  class: "property-write-only"
};
const _hoisted_7 = {
  key: 8,
  class: "property-read-only"
};
const _hoisted_8 = {
  key: 9,
  class: "property-required"
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "SchemaPropertyHeading",
  props: {
    value: {},
    enum: { type: Boolean },
    isDiscriminator: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    additional: { type: Boolean },
    withExamples: { type: Boolean, default: true },
    hideModelNames: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const valueRef = toRef(props, "value");
    const constValue = computed(() => {
      if (!valueRef.value) {
        return void 0;
      }
      const schema = valueRef.value;
      if (schema.const !== void 0) {
        return schema.const;
      }
      if (schema.enum?.length === 1) {
        return schema.enum[0];
      }
      if (isArraySchema(schema) && schema.items) {
        const items = getResolvedRef(schema.items);
        if (isDefined(items.const)) {
          return items.const;
        }
        if (items.enum?.length === 1) {
          return items.enum[0];
        }
      }
      return void 0;
    });
    const validationProperties = computed(() => {
      if (!valueRef.value) {
        return [];
      }
      const schema = valueRef.value;
      const properties = [];
      if (isArraySchema(schema)) {
        if (schema.minItems || schema.maxItems) {
          properties.push({
            key: "array-range",
            value: `${schema.minItems || ""}â€¦${schema.maxItems || ""}`
          });
        }
        if (schema.uniqueItems) {
          properties.push({
            key: "unique-items",
            value: "unique!"
          });
        }
      }
      if (isStringSchema(schema)) {
        if (schema.minLength) {
          properties.push({
            key: "min-length",
            prefix: "min length: ",
            value: schema.minLength
          });
        }
        if (schema.maxLength) {
          properties.push({
            key: "max-length",
            prefix: "max length: ",
            value: schema.maxLength
          });
        }
        if (schema.pattern) {
          properties.push({
            key: "pattern",
            value: schema.pattern,
            code: true,
            truncate: true
          });
        }
      }
      if (isStringSchema(schema) || isNumberSchema(schema)) {
        if (schema.format) {
          properties.push({
            key: "format",
            value: schema.format,
            truncate: true
          });
        }
      }
      if (isNumberSchema(schema)) {
        if (isDefined(schema.exclusiveMinimum)) {
          properties.push({
            key: "exclusive-minimum",
            prefix: "greater than: ",
            value: schema.exclusiveMinimum
          });
        }
        if (isDefined(schema.minimum)) {
          properties.push({
            key: "minimum",
            prefix: "min: ",
            value: schema.minimum
          });
        }
        if (isDefined(schema.exclusiveMaximum)) {
          properties.push({
            key: "exclusive-maximum",
            prefix: "less than: ",
            value: schema.exclusiveMaximum
          });
        }
        if (isDefined(schema.maximum)) {
          properties.push({
            key: "maximum",
            prefix: "max: ",
            value: schema.maximum
          });
        }
        if (isDefined(schema.multipleOf)) {
          properties.push({
            key: "multiple-of",
            prefix: "multiple of: ",
            value: schema.multipleOf
          });
        }
      }
      return properties;
    });
    const modelName = computed(() => {
      if (!props.value) {
        return null;
      }
      return getModelName(props.value, props.hideModelNames);
    });
    const shouldShowType = computed(() => {
      if (!props.value || !("type" in props.value)) {
        return false;
      }
      if (props.value.type === "array") {
        return true;
      }
      return !constValue.value;
    });
    const displayType = computed(() => {
      if (!props.value) {
        return "";
      }
      return modelName.value || getSchemaType(props.value);
    });
    const flattenedDefaultValue = computed(() => {
      const value = props.value;
      if (value?.default === null) {
        return "null";
      }
      if (Array.isArray(value?.default) && value?.default.length === 1) {
        return String(value?.default[0]);
      }
      if (typeof value?.default === "string") {
        return JSON.stringify(value.default);
      }
      if (Array.isArray(value?.default)) {
        return JSON.stringify(value?.default);
      }
      if (typeof value?.default === "object") {
        return JSON.stringify(value?.default);
      }
      return value?.default;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        _ctx.$slots.name ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["property-name", { deprecated: props.value?.deprecated }])
        }, [
          renderSlot(_ctx.$slots, "name", {}, void 0, true)
        ], 2)) : createCommentVNode("", true),
        props.isDiscriminator ? (openBlock(), createElementBlock("div", _hoisted_2, " Discriminator ")) : createCommentVNode("", true),
        props.value ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          shouldShowType.value ? (openBlock(), createBlock(SchemaPropertyDetail, {
            key: 0,
            truncate: ""
          }, {
            default: withCtx(() => [
              createVNode(ScreenReader, null, {
                default: withCtx(() => [..._cache[0] || (_cache[0] = [
                  createTextVNode("Type: ", -1)
                ])]),
                _: 1
              }),
              createTextVNode(toDisplayString(displayType.value), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(validationProperties.value, (property) => {
            return openBlock(), createBlock(SchemaPropertyDetail, {
              key: property.key,
              code: property.code,
              truncate: property.truncate
            }, createSlots({
              default: withCtx(() => [
                property.key === "format" ? (openBlock(), createBlock(ScreenReader, { key: 0 }, {
                  default: withCtx(() => [..._cache[1] || (_cache[1] = [
                    createTextVNode("Format:", -1)
                  ])]),
                  _: 1
                })) : property.key === "pattern" ? (openBlock(), createBlock(ScreenReader, { key: 1 }, {
                  default: withCtx(() => [..._cache[2] || (_cache[2] = [
                    createTextVNode(" Pattern: ", -1)
                  ])]),
                  _: 1
                })) : createCommentVNode("", true),
                createTextVNode(" " + toDisplayString(property.value), 1)
              ]),
              _: 2
            }, [
              property.prefix ? {
                name: "prefix",
                fn: withCtx(() => [
                  createTextVNode(toDisplayString(property.prefix), 1)
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["code", "truncate"]);
          }), 128)),
          props.enum ? (openBlock(), createBlock(SchemaPropertyDetail, { key: 1 }, {
            default: withCtx(() => [..._cache[3] || (_cache[3] = [
              createTextVNode("enum", -1)
            ])]),
            _: 1
          })) : createCommentVNode("", true),
          flattenedDefaultValue.value !== void 0 ? (openBlock(), createBlock(SchemaPropertyDetail, {
            key: 2,
            truncate: ""
          }, {
            prefix: withCtx(() => [..._cache[4] || (_cache[4] = [
              createTextVNode("default:", -1)
            ])]),
            default: withCtx(() => [
              createTextVNode(toDisplayString(flattenedDefaultValue.value), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true),
        props.additional ? (openBlock(), createElementBlock("div", _hoisted_3, [
          props.value?.["x-additionalPropertiesName"] ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(props.value["x-additionalPropertiesName"]), 1)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode("additional properties")
          ], 64))
        ])) : createCommentVNode("", true),
        props.value?.deprecated ? (openBlock(), createElementBlock("div", _hoisted_4, [
          createVNode(unref(Badge), null, {
            default: withCtx(() => [..._cache[5] || (_cache[5] = [
              createTextVNode("deprecated", -1)
            ])]),
            _: 1
          })
        ])) : createCommentVNode("", true),
        constValue.value !== void 0 ? (openBlock(), createElementBlock("div", _hoisted_5, [
          createVNode(SchemaPropertyDetail, { truncate: "" }, {
            prefix: withCtx(() => [..._cache[6] || (_cache[6] = [
              createTextVNode("const: ", -1)
            ])]),
            default: withCtx(() => [
              createVNode(_sfc_main$1, { value: constValue.value }, null, 8, ["value"])
            ]),
            _: 1
          })
        ])) : (openBlock(), createElementBlock(Fragment, { key: 6 }, [
          props.value?.nullable === true ? (openBlock(), createBlock(SchemaPropertyDetail, { key: 0 }, {
            default: withCtx(() => [..._cache[7] || (_cache[7] = [
              createTextVNode(" nullable ", -1)
            ])]),
            _: 1
          })) : createCommentVNode("", true)
        ], 64)),
        props.value?.writeOnly ? (openBlock(), createElementBlock("div", _hoisted_6, " write-only ")) : props.value?.readOnly ? (openBlock(), createElementBlock("div", _hoisted_7, " read-only ")) : createCommentVNode("", true),
        props.required ? (openBlock(), createElementBlock("div", _hoisted_8, " required ")) : createCommentVNode("", true),
        props.withExamples ? (openBlock(), createBlock(SchemaPropertyExamples, {
          key: 10,
          example: props.value?.example || props.value && unref(isArraySchema)(props.value) && unref(getResolvedRef)(props.value?.items)?.example,
          examples: props.value?.examples
        }, null, 8, ["example", "examples"])) : createCommentVNode("", true)
      ]);
    };
  }
});
export {
  _sfc_main as default
};
