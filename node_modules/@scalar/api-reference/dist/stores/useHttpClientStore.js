import { objectMerge as T } from "@scalar/oas-utils/helpers";
import { availableTargets as m } from "httpsnippet-lite";
import { computed as o, ref as k, reactive as A, readonly as f } from "vue";
const y = {
  targetKey: "shell",
  clientKey: "curl"
};
function p(e) {
  var n;
  return ((n = l.value.find((t) => t.key === e.targetKey)) == null ? void 0 : n.title) ?? e.targetKey;
}
function C(e) {
  var n, t;
  return ((t = (n = l.value.find((i) => i.key === e.targetKey)) == null ? void 0 : n.clients.find((i) => i.key === e.clientKey)) == null ? void 0 : t.title) ?? e.clientKey;
}
const b = o(() => p(r)), H = o(() => C(r));
function h(e, n) {
  return n.value === !0 ? [] : e.flatMap((t) => {
    var i;
    return typeof n.value != "object" ? [] : Array.isArray(n.value) ? (t.clients = t.clients.filter(
      // @ts-expect-error Typescript, chill. It’s all good. It has to be an array.
      (s) => !n.value.includes(s.key)
    ), [t]) : n.value[t.key] === !0 ? [] : (Array.isArray(n.value[t.key]) && (t.clients = t.clients.filter((s) => !// @ts-expect-error We checked whether it’s an Array already.
    n.value[t.key].includes(s.key))), (i = t == null ? void 0 : t.clients) != null && i.length ? [t] : []);
  });
}
const l = o(() => {
  var n;
  const e = m();
  return (n = e.find((t) => t.key === "node")) == null || n.clients.unshift({
    description: "An HTTP/1.1 client, written from scratch for Node.js.",
    key: "undici",
    link: "https://github.com/nodejs/undici",
    title: "undici"
  }), h(e, c);
}), d = {
  node: ["unirest"]
}, c = k({
  ...d === !0 ? {} : d
}), a = k();
function E(e) {
  e !== void 0 && (a.value = e, K(u()));
}
const u = () => {
  var e, n, t, i;
  return v(a.value) ? a.value : v(y) ? y : {
    targetKey: (e = l.value[0]) == null ? void 0 : e.key,
    clientKey: (i = (t = (n = l.value[0]) == null ? void 0 : n.clients) == null ? void 0 : t[0]) == null ? void 0 : i.key
  };
};
function v(e) {
  return e === void 0 ? !1 : !!l.value.find(
    (n) => n.key === e.targetKey && n.clients.find((t) => t.key === e.clientKey)
  );
}
function L() {
  T(r, u());
}
const r = A(u()), K = (e) => {
  Object.assign(r, {
    ...r,
    ...e
  });
}, _ = () => ({
  httpClient: f(r),
  resetState: L,
  setHttpClient: K,
  setDefaultHttpClient: E,
  excludedClients: f(c),
  setExcludedClients: (e) => {
    c.value = e, T(r, u());
  },
  availableTargets: l,
  getClientTitle: C,
  getTargetTitle: p,
  httpTargetTitle: b,
  httpClientTitle: H
});
export {
  h as filterHiddenClients,
  _ as useHttpClientStore
};
