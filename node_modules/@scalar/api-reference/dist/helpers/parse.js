import { redirectToProxy as b } from "@scalar/oas-utils/helpers";
import { load as j, dereference as M } from "@scalar/openapi-parser";
import { fetchUrls as q } from "@scalar/openapi-parser/plugins/fetch-urls";
import { createEmptySpecification as m } from "./createEmptySpecification.js";
import { normalizeRequestMethod as E } from "../legacy/helpers/normalizeRequestMethod.js";
import { validRequestMethods as k } from "../legacy/fixtures/httpRequestMethods.js";
const D = (p, {
  proxy: t
} = {}) => new Promise(async (a, h) => {
  var s;
  try {
    if (!p)
      return a(
        u(m())
      );
    const i = performance.now(), { filesystem: n } = await j(p, {
      plugins: [
        q({
          fetch: (o) => fetch(t ? b(t, o) : o)
        })
      ]
    }), { schema: e, errors: r } = await M(n), f = performance.now();
    return console.log(`dereference: ${Math.round(f - i)} ms`), r != null && r.length && console.warn(
      `Please open an issue on https://github.com/scalar/scalar
`,
      `Scalar OpenAPI Parser Warning:
`,
      r
    ), e === void 0 ? (h(((s = r == null ? void 0 : r[0]) == null ? void 0 : s.message) ?? "Failed to parse the OpenAPI file."), a(
      u(m())
    )) : a(u(e));
  } catch (i) {
    h(i);
  }
  return a(
    u(m())
  );
}), u = (p) => {
  let t = {};
  p && typeof p == "object" ? t = structuredClone(p) : t = m(), t.tags || (t.tags = []), t.paths || (t.paths = {});
  const a = {};
  return Object.keys(t.webhooks ?? {}).forEach((s) => {
    var i;
    Object.keys(((i = t.webhooks) == null ? void 0 : i[s]) ?? {}).forEach((n) => {
      var r, f, o;
      const e = (r = t.webhooks) == null ? void 0 : r[s][n];
      (e == null ? void 0 : e["x-internal"]) !== !0 && (a[s] === void 0 && (a[s] = {}), a[s][n] = {
        // Transformed data
        httpVerb: E(n),
        path: s,
        operationId: (e == null ? void 0 : e.operationId) || s,
        name: (e == null ? void 0 : e.summary) || s || "",
        description: (e == null ? void 0 : e.description) || "",
        pathParameters: (o = (f = t.paths) == null ? void 0 : f[s]) == null ? void 0 : o.parameters,
        // Original webhook
        information: {
          ...e
        }
      });
    });
  }), Object.keys(t.paths).forEach((s) => {
    Object.keys(t.paths[s]).filter(
      (n) => k.includes(n.toUpperCase())
    ).forEach((n) => {
      var f, o, g, w, y, x;
      const e = t.paths[s][n];
      if (e === void 0 || e["x-internal"] === !0)
        return;
      const r = {
        httpVerb: E(n),
        path: s,
        operationId: e.operationId || s,
        name: e.summary || s || "",
        description: e.description || "",
        information: {
          ...e
        },
        pathParameters: (o = (f = t.paths) == null ? void 0 : f[s]) == null ? void 0 : o.parameters
      };
      if (!e.tags || e.tags.length === 0) {
        (g = t.tags) != null && g.find(
          (c) => c.name === "default"
        ) || (w = t.tags) == null || w.push({
          name: "default",
          description: "",
          operations: []
        });
        const d = (y = t.tags) == null ? void 0 : y.findIndex(
          (c) => c.name === "default"
        );
        d >= 0 && ((x = t.tags[d]) == null || x.operations.push(r));
      } else
        e.tags.forEach((d) => {
          var I, O, P;
          const c = (I = t.tags) == null ? void 0 : I.findIndex(
            // @ts-expect-error TODO: The types are just screwed, needs refactoring
            (R) => R.name === d
          );
          c === -1 && ((O = t.tags) == null || O.push({
            name: d,
            description: ""
          }));
          const l = c !== -1 ? c : t.tags.length - 1;
          typeof ((P = t.tags[l]) == null ? void 0 : P.operations) > "u" && (t.tags[l].operations = []), t.tags[l].operations.push(r);
        });
    });
  }), {
    ...t,
    webhooks: a
  };
};
export {
  D as parse
};
