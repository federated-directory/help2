/** Tracks when the initial load is complete.
 * We will have placeholder content to allow the active item to be scrolled to the top while
 * the rest of the content is loaded.
 */
export declare const firstLazyLoadComplete: import("vue").Ref<boolean, boolean>;
type UnblockFn = () => void;
/**
 * Adds a unique identifier to the intersection blockers set
 * Intersection will not be enabled until the unblock callback is run
 */
export declare const blockIntersection: () => UnblockFn;
/** If there are any pending blocking operations we disable intersection */
export declare const intersectionEnabled: import("vue").ComputedRef<boolean>;
/**
 * Tracks the lazy loading state of an element.
 * The element should be conditionally rendered using the isReady property.
 *
 * @param id - The id of the element to track
 * @returns An object with the isReady property
 */
export declare function useLazyBus(id: string): {
    isReady: import("vue").ComputedRef<boolean>;
};
/**
 * Scroll to possible lazy element
 *
 * Will ensure that all parents are expanded and set to priority load before scrolling
 *
 * Similar to scrollToId BUT in the case of a section not being open,
 * it uses the lazyBus to ensure the section is open before scrolling to it
 *
 * Requires handlers to expand and lookup navigation items so that we can
 * traverse the parent structure and load all required items
 */
export declare const scrollToLazy: (id: string, setExpanded: (id: string, value: boolean) => void, getEntryById: (id: string) => {
    id: string;
    parent?: {
        id: string;
    };
    children?: {
        id: string;
    }[];
} | undefined) => void;
export {};
//# sourceMappingURL=lazy-bus.d.ts.map