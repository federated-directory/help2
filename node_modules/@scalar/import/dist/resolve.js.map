{
  "version": 3,
  "sources": ["../src/resolve.ts"],
  "sourcesContent": ["import { makeUrlAbsolute } from '@scalar/helpers/url/make-url-absolute'\nimport { parse } from 'yaml'\n\n/**\n * Find an OpenAPI document URL in the HTML of @scalar/api-reference and other places.\n * This is useful to open the OpenAPI document from basically any source.\n */\nexport async function resolve(\n  value?: string | null,\n  options?: {\n    /**\n     * Fetch function to use instead of the global fetch. Use this to intercept requests.\n     */\n    fetch?: (url: string) => Promise<Response>\n  },\n): Promise<string | Record<string, any> | undefined> {\n  // URLs\n  if (value?.startsWith('http://') || value?.startsWith('https://')) {\n    // Transform GitHub URLs to raw file URLs\n    const githubRawUrl = transformGitHubUrl(value)\n\n    if (githubRawUrl) {\n      return githubRawUrl\n    }\n\n    // https://*.json\n    if (value?.toLowerCase().endsWith('.json')) {\n      return value\n    }\n\n    // https://*.yaml\n    if (value?.toLowerCase().endsWith('.yaml') || value?.toLowerCase().endsWith('.yml')) {\n      return value\n    }\n\n    // https://sandbox.scalar.com\n    const sandboxUrl = value.match(/https:\\/\\/sandbox\\.scalar\\.com\\/(p|e)\\/([a-zA-Z0-9]+)/)\n\n    if (sandboxUrl?.[2]) {\n      return `https://sandbox.scalar.com/files/${sandboxUrl[2]}/openapi.yaml`\n    }\n\n    // Fetch URL\n    try {\n      let result = await (options?.fetch\n        ? options.fetch(value)\n        : fetch(value, {\n            cache: 'no-cache',\n          }))\n\n      // If the custom fetch failed, try again with regular fetch\n      if (!result.ok && options?.fetch) {\n        result = await fetch(value, {\n          cache: 'no-cache',\n        })\n      }\n\n      if (result.ok) {\n        const content = await result.text()\n        const forwardedHost = result.headers.get('X-Forwarded-Host')\n\n        // Check if content is directly JSON/YAML\n        try {\n          // Try parsing as JSON\n          const jsonContent = JSON.parse(content)\n          if (jsonContent.openapi || jsonContent.swagger) {\n            return value\n          }\n        } catch {\n          // Try parsing as YAML\n          try {\n            const yamlContent = parse(content)\n            if (yamlContent?.openapi || yamlContent?.swagger) {\n              return value\n            }\n          } catch {\n            // Not YAML\n          }\n        }\n\n        const urlOrPathOrDocument = parseHtml(content)\n\n        // Document (string)\n        if (typeof urlOrPathOrDocument === 'string') {\n          try {\n            // JSON?\n            return JSON.parse(urlOrPathOrDocument)\n          } catch {\n            // No JSON\n            try {\n              // YAML?\n              const yaml = parse(urlOrPathOrDocument)\n\n              if (typeof yaml === 'object') {\n                return yaml\n              }\n            } catch {\n              // Not YAML\n            }\n          }\n        }\n\n        // Document (object)\n        if (typeof urlOrPathOrDocument === 'object') {\n          return urlOrPathOrDocument\n        }\n\n        // Relative or absolute URL\n        if (urlOrPathOrDocument) {\n          return makeUrlAbsolute(urlOrPathOrDocument, {\n            baseUrl: forwardedHost || value,\n          })\n        }\n\n        // Check for configuration attribute URL\n        const configUrl = getConfigurationAttributeUrl(content)\n        if (configUrl) {\n          return makeUrlAbsolute(configUrl, {\n            baseUrl: forwardedHost || value,\n          })\n        }\n\n        // Check for embedded OpenAPI document\n        const embeddedSpec = parseEmbeddedOpenApi(content)\n        if (embeddedSpec) {\n          return embeddedSpec\n        }\n      } else {\n        console.warn(`[@scalar/import] Failed to fetch ${value}`)\n      }\n    } catch (error) {\n      console.error(`[@scalar/import] Failed to fetch ${value}`, error)\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Go through the HTML and try to find the OpenAPI document URL\n */\nfunction parseHtml(html?: string) {\n  // Check whether it could be HTML\n  if (!html?.includes('<')) {\n    return undefined\n  }\n\n  // id=\"api-reference\" data-url=\"*\"\n  const dataUrlMatch = html\n    .match(/id=[\"']api-reference[\"'][\\s\\S]*?data-url=[\"']([^\"']+)[\"']/)\n    ?.slice(1)\n    .find(Boolean)\n\n  if (dataUrlMatch) {\n    return dataUrlMatch\n  }\n\n  // spec-url=\"*\"\n  const specUrlMatch = html.match(/spec-url=[\"']([^\"']+)[\"']/)\n  if (specUrlMatch?.[1]) {\n    return specUrlMatch[1]\n  }\n\n  // Redoc.init('*')\n  const redocInit = html.match(/Redoc.init\\([\"']([^\"']+)[\"']/)\n\n  if (redocInit?.[1]) {\n    return redocInit[1]\n  }\n\n  // &amp;quot;url&amp;quot;:&amp;quot;MY_CUSTOM_URL&amp;quot;\n  const doubleEncodedConfigurationUrl = html.match(/&amp;quot;url&amp;quot;:&amp;quot;([^;]+)&amp;quot;/)\n\n  if (doubleEncodedConfigurationUrl?.[1]) {\n    return doubleEncodedConfigurationUrl[1]\n  }\n\n  // &amp;quot;url&amp;quot;:&amp;quot;MY_CUSTOM_URL&amp;quot;\n  const encodedConfigurationUrl = html.match(/&quot;url&quot;:&quot;([^;]+)&quot;/)\n  if (encodedConfigurationUrl?.[1]) {\n    return encodedConfigurationUrl[1]\n  }\n\n  // Try to find embedded OpenAPI document in script tag first\n  const scriptContent = parseScriptContent(html)\n  if (scriptContent) {\n    return scriptContent\n  }\n\n  // Check for configuration in script tag\n  const scriptConfigMatch = html.match(/url:\\s*[\"']([^\"']+)[\"']/i)\n\n  if (scriptConfigMatch?.[1]) {\n    return scriptConfigMatch?.[1]\n  }\n\n  // Check for OpenAPI URLs in the HTML\n  const linkMatch = html.match(/<a[^>]*href=[\"']([^\"']+\\.(?:yaml|yml|json))[\"'][^>]*>/i)\n\n  if (linkMatch?.[1]) {\n    return linkMatch[1]\n  }\n\n  // Check for URLs in escaped JS objects\n  const escapedJsonMatch = html.match(/\\\\\"spec\\\\\":\\{.*?\\\\\"url\\\\\":\\\\\"([^\"\\\\]+)\\\\\"/)\n\n  if (escapedJsonMatch?.[1]) {\n    return escapedJsonMatch[1]\n  }\n\n  return undefined\n}\n\n/**\n * Get the content between the script tags\n *\n * @example <script id=\"api-reference\">console.log(\"Hello, world!\");</script>\n */\nexport function getContentOfScriptTag(html: string): string | undefined {\n  const patterns = [\n    // Double quotes\n    /<script[^>]*id=\"api-reference[\\s\\S]*?\">([\\s\\S]*?)<\\/script>/i,\n    // Single quotes\n    /<script[^>]*id='api-reference[\\s\\S]*?'>([\\s\\S]*?)<\\/script>/i,\n  ]\n\n  for (const pattern of patterns) {\n    const match = html.match(pattern)\n\n    if (match?.[1]) {\n      return match[1].trim()\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Parse OpenAPI document directly from script tag content\n */\nfunction parseScriptContent(html: string): Record<string, any> | undefined {\n  const content = getContentOfScriptTag(html)\n\n  try {\n    if (content) {\n      try {\n        // JSON\n        return JSON.parse(content)\n      } catch {\n        try {\n          // JSON with escaped whitespace\n          const sanitizedContent = content.replace(/\\\\s/g, '\\\\\\\\s')\n\n          return JSON.parse(sanitizedContent)\n        } catch {\n          // YAML\n          return parse(content)\n        }\n      }\n    }\n  } catch (error) {\n    console.error('[@scalar/import] Failed to parse script content:', error)\n  }\n\n  return undefined\n}\n\n/**\n * Get the configuration attribute from the script tag\n *\n * @example <script id=\"api-reference\" data-configuration=\"{&quot;spec&quot;:{&quot;content&quot;:&quot;foo&quot;}}\"></script>\n */\nexport function getConfigurationAttribute(html: string): string | undefined {\n  const patterns = [\n    // Double quotes\n    /<script[^>]*id=\"api-reference\"[^>]*data-configuration=[\"]([^\"]+)[\"][^>]*>(.*?)<\\/script>/s,\n    // Single quotes\n    /<script[^>]*id='api-reference'[^>]*data-configuration=[']([^']+)['][^>]*>(.*?)<\\/script>/s,\n    // Mix quote single first\n    /<script[^>]*id='api-reference'[^>]*data-configuration=[\"]([^\"]+)[\"][^>]*>(.*?)<\\/script>/s,\n    // Mix quote double first\n    /<script[^>]*id=\"api-reference\"[^>]*data-configuration=[']([^']+)['][^>]*>(.*?)<\\/script>/s,\n  ]\n\n  for (const pattern of patterns) {\n    const match = html.match(pattern)\n\n    if (match?.[1]) {\n      return match[1]\n    }\n  }\n\n  return undefined\n}\n\n/** Grab the URL from the configuration data attribute */\nconst getConfigurationAttributeUrl = (html: string): string | undefined => {\n  const configString = getConfigurationAttribute(html)\n  if (!configString) {\n    return undefined\n  }\n\n  const config = JSON.parse(decodeHtmlEntities(configString))\n  return config.url || config.spec?.url\n}\n\n/**\n * Parse embedded OpenAPI document from HTML\n */\nfunction parseEmbeddedOpenApi(html: string): object | undefined {\n  const configString = getConfigurationAttribute(html)\n  if (!configString) {\n    return undefined\n  }\n\n  try {\n    const config = JSON.parse(decodeHtmlEntities(configString))\n\n    // Handle the old spec format while we transition to the new one\n    const content = config.content || config.spec?.content\n\n    // Handle both direct JSON content and YAML content\n    if (content) {\n      // If content is a string, assume it's YAML\n      if (typeof content === 'string') {\n        return parse(content)\n      }\n      // If content is an object, return it directly\n      return content\n    }\n  } catch (error) {\n    console.error('[@scalar/import] Failed to parse embedded OpenAPI document:', error)\n  }\n\n  return undefined\n}\n\n/**\n * Decode HTML entities in a string\n */\nfunction decodeHtmlEntities(text: string): string {\n  const entities = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\",\n  } as const\n\n  const updatedText = text\n    .replace(new RegExp(Object.keys(entities).join('|'), 'g'), (match) => entities[match as keyof typeof entities])\n    .replace(/\\n/g, '\\\\n')\n    .trim()\n\n  if (updatedText.startsWith('{&quot;')) {\n    // console.log('ok', updatedText)\n    return decodeHtmlEntities(updatedText)\n  }\n\n  return updatedText\n}\n\n/**\n * Transform GitHub URLs to raw file URLs, preserving the branch information\n */\nfunction transformGitHubUrl(url: string): string | undefined {\n  const githubRegex = /^https:\\/\\/github\\.com\\/([^/]+)\\/([^/]+)\\/blob\\/([^/]+)\\/(.+)$/\n  const match = url.match(githubRegex)\n\n  if (match) {\n    const [, owner, repo, branch, path] = match\n    return `https://raw.githubusercontent.com/${owner}/${repo}/refs/heads/${branch}/${path}`\n  }\n\n  return undefined\n}\n"],
  "mappings": "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",
  "names": []
}
