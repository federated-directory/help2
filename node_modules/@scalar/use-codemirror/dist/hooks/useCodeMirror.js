import { autocompletion as j, completionKeymap as B, closeBrackets as I, closeBracketsKeymap as O } from "@codemirror/autocomplete";
import { indentWithTab as K, insertNewline as L } from "@codemirror/commands";
import { css as R } from "@codemirror/lang-css";
import { html as V } from "@codemirror/lang-html";
import { json as A } from "@codemirror/lang-json";
import { xml as z } from "@codemirror/lang-xml";
import { yaml as J } from "@codemirror/lang-yaml";
import { syntaxHighlighting as P, defaultHighlightStyle as U, indentOnInput as W, bracketMatching as y } from "@codemirror/language";
import { linter as q } from "@codemirror/lint";
import { StateEffect as D } from "@codemirror/state";
import { EditorView as h, highlightSpecialChars as G, keymap as u, placeholder as Q, lineNumbers as X } from "@codemirror/view";
import { ref as Y, watch as m, onBeforeUnmount as Z, toValue as t, computed as _ } from "vue";
import { customTheme as $ } from "../themes/index.js";
import { variables as F } from "./variables.js";
const d = (e) => "provider" in e && !!t(e.provider), ee = {
  key: "Mod-a",
  run: (e) => (e.dispatch({
    selection: { anchor: 0, head: e.state.doc.length },
    scrollIntoView: !1
  }), !0)
}, ge = (e) => {
  const i = Y(null);
  m(
    e.codeMirrorRef,
    () => {
      var o;
      (o = i.value) == null || o.destroy(), s();
    },
    { immediate: !0 }
  ), Z(() => {
    var o;
    return (o = i.value) == null ? void 0 : o.destroy();
  });
  function s() {
    if (e.codeMirrorRef.value) {
      const o = d(e) ? t(e.provider) : null, a = E({
        ...l.value,
        provider: o
      });
      i.value = new h({
        parent: e.codeMirrorRef.value,
        extensions: a
      }), d(e) || n(t(e.content));
    }
  }
  const l = _(() => ({
    onChange: e.onChange,
    onBlur: e.onBlur,
    onFocus: e.onFocus,
    disableTabIndent: t(e.disableTabIndent),
    language: t(e.language),
    classes: t(e.classes),
    readOnly: t(e.readOnly),
    lineNumbers: t(e.lineNumbers),
    withVariables: t(e.withVariables),
    disableEnter: t(e.disableEnter),
    disableCloseBrackets: t(e.disableCloseBrackets),
    withoutTheme: t(e.withoutTheme),
    lint: t(e.lint),
    additionalExtensions: t(e.extensions),
    placeholder: t(e.placeholder)
  }));
  m(
    () => d(e) ? t(e.provider) : null,
    () => {
      var o;
      d(e) && ((o = i.value) == null || o.destroy(), s());
    }
  ), m(
    l,
    () => {
      if (i.value) {
        const o = d(e) ? t(e.provider) : null, a = E({
          ...l.value,
          provider: o
        });
        i.value.dispatch({
          effects: D.reconfigure.of(a)
        });
      } else
        return;
    },
    { immediate: !0 }
  );
  const n = (o = "") => {
    i.value && i.value.state.doc.toString() !== o && i.value.dispatch({
      changes: {
        from: 0,
        to: i.value.state.doc.length,
        insert: o
      },
      selection: {
        anchor: Math.min(
          i.value.state.selection.main.anchor,
          o.length
        )
      }
    });
  };
  return m(
    () => t(e.content),
    () => {
      d(e) || n(t(e.content));
    },
    { immediate: !0 }
  ), {
    /** Replaces the current content with the given value. */
    setCodeMirrorContent: n,
    /** Codemirror instance */
    codeMirror: i
  };
}, x = {
  html: V,
  json: A,
  yaml: J,
  css: R,
  xml: z
};
function E({
  onChange: e,
  onBlur: i,
  onFocus: s,
  provider: l,
  language: n,
  classes: o = [],
  readOnly: a = !1,
  lineNumbers: k = !1,
  withVariables: C = !1,
  disableEnter: M = !1,
  disableCloseBrackets: S = !1,
  disableTabIndent: T = !1,
  withoutTheme: N = !1,
  lint: w = !1,
  additionalExtensions: H = [],
  placeholder: g
}) {
  const r = [
    G(),
    P(U, { fallback: !0 }),
    h.theme({
      ".cm-line": {
        lineHeight: "20px"
      },
      ".cm-gutterElement": {
        lineHeight: "20px"
      },
      ".cm-tooltip": {
        border: "1px solid #f5c6cb",
        fontSize: "12px"
      },
      ".cm-tooltip-lint": {
        backgroundColor: "#ffffff"
      },
      ".cm-diagnostic-error": {
        borderLeft: "0",
        color: "#dc1b19"
      }
    }),
    // Listen to updates
    h.updateListener.of((f) => {
      f.docChanged && (e == null || e(f.state.doc.toString()));
    }),
    h.domEventHandlers({
      blur: (f, c) => {
        i == null || i(c.state.doc.toString());
      },
      focus: (f, c) => {
        s == null || s(c.state.doc.toString());
      }
    }),
    // Add Classes
    h.editorAttributes.of({ class: o.join(" ") }),
    ...H
  ];
  if (l && r.push(l), N || r.push($), a ? r.push(h.editable.of(!1)) : (r.push(
    W(),
    y(),
    j(),
    u.of([...B, ee]),
    y()
  ), S || r.push(I(), u.of([...O])), T ? r.push(
    u.of([
      {
        key: "Tab",
        run: () => !1,
        // Prevent default Tab behavior
        shift: () => !1
        // Prevent default Shift+Tab behavior
      }
    ])
  ) : r.push(u.of([K]))), g && r.push(Q(g)), n && x[n] && r.push(x[n]()), w && n === "json") {
    const f = q((c) => {
      const p = [], b = c.state.doc.toString();
      if (b.trim())
        try {
          JSON.parse(b);
        } catch (v) {
          v instanceof Error && p.push({
            from: 0,
            to: c.state.doc.length,
            severity: "error",
            message: v.message
          });
        }
      return p;
    });
    r.push(f);
  }
  return k && r.push(X()), C && r.push(F()), M ? r.push(
    u.of([
      {
        key: "Enter",
        run: () => !0
      },
      {
        key: "Ctrl-Enter",
        mac: "Cmd-Enter",
        run: () => !0
      },
      {
        key: "Shift-Enter",
        run: () => !0
      }
    ])
  ) : r.push(
    u.of([
      {
        key: "Enter",
        run: L
      }
    ])
  ), r;
}
export {
  ge as useCodeMirror
};
