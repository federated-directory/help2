import { getSelectedServer as O } from "@scalar/api-client/v2/features/operation";
import { getServers as x } from "@scalar/api-client/v2/helpers";
import { isObject as l } from "@scalar/helpers/object/is-object";
import { REFERENCE_LS_KEYS as d, safeLocalStorage as v } from "@scalar/helpers/object/local-storage";
import { getResolvedRef as h } from "@scalar/workspace-store/helpers/get-resolved-ref";
import { coerceValue as y } from "@scalar/workspace-store/schemas/typebox-coerce";
import { XScalarSelectedSecuritySchema as E, SecuritySchemesSchema as b } from "@scalar/workspace-store/schemas/v3.1/strict/openapi-document";
function P(e) {
  return Object.values(e.paths ?? {}).flatMap((c) => Object.values(c ?? {}));
}
function j(e) {
  const s = (e["x-scalar-selected-security"]?.selectedSchemes ?? []).flatMap((r) => Object.keys(r)), t = e.components?.securitySchemes;
  return t ? s.reduce((r, n) => {
    const o = t[n];
    return o && r.push(h(o)), r;
  }, []) : [];
}
function C(e) {
  return Object.fromEntries(
    Object.entries(e.workspace.documents).map(([c, s]) => {
      const t = x(s.servers, {
        documentUrl: s?.["x-scalar-original-source-url"]
      });
      return [
        c,
        {
          activeServer: O(s, t),
          securitySchemes: j(s)
        }
      ];
    })
  );
}
const m = v(), f = () => {
  const e = d.AUTH_SCHEMES, c = d.SELECTED_AUTH_SCHEMES, s = (t, r) => `${r}-${((o) => o === "schemas" ? e : c)(t)}`;
  return {
    /**
     * Retrieves and coerces the authentication schemes stored in local storage.
     */
    getSchemas: (t) => {
      const r = JSON.parse(m.getItem(s("schemas", t)) ?? "{}");
      return y(b, r);
    },
    /**
     * Stores the authentication schemes in local storage.
     * @param value The SecuritySchemes object to stringify and store.
     */
    setSchemas: (t, r) => {
      m.setItem(s("schemas", t), JSON.stringify(r));
    },
    /**
     * Retrieves and coerces the selected authentication schemes stored in local storage.
     */
    getSelectedSchemes: (t) => {
      const r = JSON.parse(m.getItem(s("selectedSchemes", t)) ?? "{}");
      return y(E, r);
    },
    /**
     * Stores the user's selected authentication schemes in local storage.
     * @param value The XScalarSelectedSecurity object to stringify and store.
     */
    setSelectedSchemes: (t, r) => {
      m.setItem(s("selectedSchemes", t), JSON.stringify(r));
    }
  };
}, p = (e, c) => {
  if (!(!l(e) || !l(c)))
    for (const [s, t] of Object.entries(c)) {
      if (typeof t != "object") {
        e[s] = t;
        continue;
      }
      p(h(e[s]), t);
    }
}, I = (e, c) => Object.keys(e).every((s) => c.has(s)), U = (e, c) => e >= c ? c - 1 : e, H = ({
  documentName: e,
  workspaceStore: c
}) => {
  const s = f().getSchemas(e), t = c.workspace.documents[e];
  if (!t)
    return;
  const n = f().getSelectedSchemes(e), o = new Set(Object.keys(t.components?.securitySchemes ?? {})), S = n["x-scalar-selected-security"]?.selectedSchemes?.filter((a) => I(a, o));
  if (!t["x-scalar-selected-security"] && S && S.length > 0) {
    const a = n["x-scalar-selected-security"]?.selectedIndex, i = U(a ?? 0, S.length);
    t["x-scalar-selected-security"] = {
      selectedIndex: i,
      selectedSchemes: S
    };
  }
  const g = t.components?.securitySchemes ?? {};
  for (const [a, i] of Object.entries(s)) {
    const u = h(g[a]);
    l(u) && p(u, i);
  }
};
function M(e) {
  try {
    return JSON.parse(e);
  } catch {
    return;
  }
}
function N(e) {
  try {
    if (e.startsWith("/") || e.startsWith("http://localhost"))
      return e;
    const c = new URLSearchParams({ scalar_url: e });
    return new URL(`https://proxy.scalar.com/?${c}`).toString();
  } catch {
    return console.error(`Invalid URL provided: ${e}`), e;
  }
}
export {
  f as authStorage,
  C as createDocumentSettings,
  P as getOperations,
  N as makeScalarProxyUrl,
  H as restoreAuthSecretsFromStorage,
  M as safeParseJson
};
