import { n as f } from "neverpanic";
import t from "zod";
import { createError as a } from "./entities/error/helpers.js";
import { registryApiMetadata as n } from "./entities/registry/document.js";
import { makeScalarProxyUrl as D } from "./helpers.js";
function E({
  getAccessToken: u,
  getAgentKey: i
}) {
  const c = u?.(), e = i?.();
  return {
    ...c && {
      Authorization: `Bearer ${c}`
    },
    ...e && {
      "x-scalar-agent-key": e
    }
  };
}
function $({
  baseUrl: u,
  getAccessToken: i,
  getAgentKey: c
}) {
  const e = f.safeFn(
    async ({
      path: s,
      method: g = "get",
      query: p,
      body: d,
      responseSchema: h
    }) => {
      const l = `${u}${s}${p ? `?${new URLSearchParams(p)}` : ""}`, o = await f.fromUnsafe(
        async () => fetch(D(l), {
          method: g,
          ...d && { body: JSON.stringify(d) },
          headers: {
            ...E({ getAccessToken: i, getAgentKey: c })
          }
        }),
        (r) => a("FAILED_TO_FETCH", r)
      );
      if (!o.success)
        return o;
      const m = await f.fromUnsafe(
        async () => o.data.json(),
        (r) => a("FAILED_TO_FETCH_DATA", r)
      );
      if (!m.success)
        return {
          success: !1,
          error: a("UNKNOWN_ERROR", "Unknown error occurred. Please contact support.")
        };
      if (!o.data.ok) {
        const r = t.object({ message: t.string(), code: t.string() }).safeParse(m.data);
        return r.success ? {
          success: !1,
          error: a(r.data.code, r.data.message)
        } : {
          success: !1,
          error: a("UNKNOWN_ERROR", "Unknown error occurred. Please contact support.")
        };
      }
      const y = h.safeParse(m.data);
      return y.success ? { success: !0, data: y.data } : {
        success: !1,
        error: a("INVALID_RESPONSE", "Invalid response. Please contact support")
      };
    }
  );
  return {
    search: async (s) => e({
      path: "/vector/registry/search",
      query: { query: s },
      responseSchema: t.object({
        results: n.array()
      })
    }),
    getDocument: async (s) => e({
      path: `/vector/registry/document/${s.namespace}/${s.slug}`,
      responseSchema: n
    }),
    getKeyDocuments: async () => e({
      path: "/vector/registry/documents",
      responseSchema: t.object({ documents: n.array() })
    }),
    getCuratedDocuments: async () => e({
      path: "/vector/registry/curated",
      responseSchema: t.object({
        results: n.array()
      })
    })
  };
}
export {
  $ as createApi,
  E as createAuthorizationHeaders
};
