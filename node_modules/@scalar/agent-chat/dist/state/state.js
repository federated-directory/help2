import { Chat as k } from "@ai-sdk/vue";
import { useModal as L } from "@scalar/components";
import { apiReferenceConfigurationSchema as N } from "@scalar/types/api-reference";
import { createWorkspaceStore as O } from "@scalar/workspace-store/client";
import { createWorkspaceEventBus as Y } from "@scalar/workspace-store/events";
import { DefaultChatTransport as _, lastAssistantMessageIsCompleteWithApprovalResponses as j } from "ai";
import { ref as s, computed as x, watch as C, inject as z } from "vue";
import { createApi as H, createAuthorizationHeaders as I } from "../api.js";
import { createDocumentSettings as P, makeScalarProxyUrl as U } from "../helpers.js";
import { useTermsAndConditions as $ } from "../hooks/use-term-and-conditions.js";
import { loadDocument as q } from "../registry/add-documents-to-store.js";
import { createDocumentName as F } from "../registry/create-document-name.js";
const G = /* @__PURE__ */ Symbol("STATE_SYMBOL");
function J({
  registryDocuments: r,
  workspaceStore: c,
  baseUrl: p,
  getAccessToken: n,
  getAgentKey: f
}) {
  return new k({
    sendAutomaticallyWhen: j,
    transport: new _({
      api: U(`${p}/vector/openapi/chat`),
      headers: () => I({ getAccessToken: n, getAgentKey: f }),
      body: () => ({
        registryDocuments: r.value,
        documentSettings: P(c)
      })
    })
  });
}
function ct({
  initialRegistryDocuments: r,
  registryUrl: c,
  dashboardUrl: p,
  baseUrl: n,
  mode: f,
  getAccessToken: l,
  getAgentKey: d,
  getActiveDocumentJson: A,
  prefilledMessageRef: h
}) {
  const m = s(h?.value ?? ""), a = s([]), E = s([]), v = s("https://proxy.scalar.com"), M = s(), D = $(), T = Y(), i = O(), S = x(
    () => N.parse({
      proxyUrl: v.value,
      persistAuth: !0
    })
  ), e = J({
    registryDocuments: a,
    workspaceStore: i,
    baseUrl: n,
    getAccessToken: l,
    getAgentKey: d
  }), y = H({
    baseUrl: n,
    getAccessToken: l,
    getAgentKey: d
  }), B = x(
    () => e.status === "submitted" || e.status === "streaming" && !e.lastMessage?.parts.some((t) => t.type === "text")
  );
  C(
    () => e.status,
    () => {
      e.status === "streaming" && (m.value = "");
    }
  ), h && C(h, async (t) => {
    t && (m.value = t, D.accepted.value && await e.sendMessage({ text: m.value }));
  });
  const W = L();
  async function w({
    namespace: t,
    slug: o,
    removable: u = !0
  }) {
    a.value.find((g) => g.namespace === t && g.slug === o) || await q({
      namespace: t,
      slug: o,
      workspaceStore: i,
      registryUrl: c,
      registryDocuments: a,
      config: S.value,
      api: y,
      removable: u
    });
  }
  function b({ namespace: t, slug: o }) {
    a.value = a.value.filter(
      (u) => !(u.namespace === t && u.slug === o)
    ), i.deleteDocument(F(t, o));
  }
  return r.forEach(({ namespace: t, slug: o }) => w({ namespace: t, slug: o, removable: !1 })), {
    prompt: m,
    chat: e,
    workspaceStore: i,
    eventBus: T,
    loading: B,
    settingsModal: W,
    config: S,
    registryUrl: c,
    dashboardUrl: p,
    baseUrl: n,
    registryDocuments: a,
    proxyUrl: v,
    mode: f,
    terms: D,
    addDocument: w,
    removeDocument: b,
    getAccessToken: l,
    getAgentKey: d,
    api: y,
    uploadedTmpDocumentUrl: M,
    curatedDocuments: E,
    getActiveDocumentJson: A
  };
}
function mt() {
  const r = z(G);
  if (!r)
    throw new Error("No state provided.");
  return r;
}
export {
  G as STATE_SYMBOL,
  ct as createState,
  mt as useState
};
