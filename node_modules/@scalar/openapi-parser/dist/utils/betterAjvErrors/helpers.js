import{getErrors as r,isRequiredError as e,isAnyOfError as t,isEnumError as n,getSiblings as o,notUndefined as a,concatAll as i,getChildren as c}from"./utils.js";import s from"./validation-errors/additional-prop.js";import d from"./validation-errors/default.js";import l from"./validation-errors/enum.js";import u from"./validation-errors/pattern.js";import h from"./validation-errors/required.js";import m from"./validation-errors/unevaluated-prop.js";const p=/\/[\w_-]+(\/\d+)?/g;function f(r=[]){const e={children:{}};return r.forEach((r=>{const t=void 0!==r.instancePath?r.instancePath:r.dataPath,n=""===t?[""]:t.match(p);n&&n.reduce(((e,t,o)=>(e.children[t]=e.children[t]||{children:{},errors:[]},o===n.length-1&&e.children[t].errors.push(r),e.children[t])),e)})),e}function w(i,c,s){r(i).forEach((r=>{e(r)&&(i.errors=[r],i.children={})})),r(i).some(t)&&Object.keys(i.children).length>0&&delete i.errors,i.errors&&i.errors.length&&r(i).every(n)&&o(c)(i).filter(a).some(r)&&delete c.children[s],Object.entries(i.children).forEach((([r,e])=>w(e,i,r)))}function v(e,t){const o=r(e);if(o.length&&o.every(n)){const r=[...new Set(i([])(o.map((r=>r.params.allowedValues))))],e=o[0];return[new l({...e,params:{allowedValues:r}},t)]}return i(o.reduce(((r,e)=>{switch(e.keyword){case"additionalProperties":return r.concat(new s(e,t));case"pattern":return r.concat(new u(e,t));case"required":return r.concat(new h(e,t));case"unevaluatedProperties":return r.concat(new m(e,t));default:return r.concat(new d(e,t))}}),[]))(c(e).map((r=>v(r,t))))}function j(r,e){const t=f(r||[]);return w(t),v(t,e)}export{v as createErrorInstances,j as default,w as filterRedundantErrors,f as makeTree};
