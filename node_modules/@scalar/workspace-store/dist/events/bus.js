import { debounce } from "@scalar/helpers/general/debounce";
import { unpackProxyObject } from "../helpers/unpack-proxy.js";
const createWorkspaceEventBus = (options = {}) => {
  const { debug = false } = options;
  const events = /* @__PURE__ */ new Map();
  const pendingLogs = [];
  let logTimeout = null;
  const { execute: debouncedEmitter } = debounce({ delay: 328 });
  const getListeners = (event) => {
    const listeners = events.get(event) ?? /* @__PURE__ */ new Set();
    events.set(event, listeners);
    return listeners;
  };
  const flushLogs = () => {
    if (pendingLogs.length === 0) {
      return;
    }
    if (debug) {
      if (pendingLogs.length === 1) {
        const firstLog = pendingLogs[0];
        if (firstLog) {
          console.log(`[EventBus] ${firstLog.message}`, ...firstLog.args);
        }
      } else {
        console.groupCollapsed(`[EventBus] ${pendingLogs.length} operations`);
        for (const { message, args } of pendingLogs) {
          console.log(message, ...args);
        }
        console.groupEnd();
      }
    }
    pendingLogs.length = 0;
    logTimeout = null;
  };
  const log = (message, ...args) => {
    if (debug) {
      pendingLogs.push({ message, args });
      if (logTimeout) {
        clearTimeout(logTimeout);
      }
      logTimeout = setTimeout(flushLogs, 500);
    }
  };
  const on = (event, listener) => {
    const listeners = getListeners(event);
    listeners.add(listener);
    log(`Added listener for "${String(event)}" (${listeners.size} total)`);
    return () => off(event, listener);
  };
  const off = (event, listener) => {
    const listeners = events.get(event);
    if (!listeners) {
      return;
    }
    listeners.delete(listener);
    log(`Removed listener for "${String(event)}" (${listeners.size} remaining)`);
    if (listeners.size === 0) {
      events.delete(event);
    }
  };
  const performEmit = (event, payload, options2) => {
    const unpackedPayload = options2?.skipUnpackProxy ? payload : unpackProxyObject(payload, { depth: 5 });
    const listeners = events.get(event);
    if (!listeners || listeners.size === 0) {
      log(`\u{1F6D1} No listeners for "${String(event)}"`);
      return;
    }
    log(`Emitting "${String(event)}" to ${listeners.size} listener(s)`, payload);
    const listenersArray = Array.from(listeners);
    for (const listener of listenersArray) {
      try {
        listener(unpackedPayload);
      } catch (error) {
        console.error(`[EventBus] Error in listener for "${String(event)}":`, error);
      }
    }
  };
  const emit = (...args) => {
    const [event, payload, options2] = args;
    if (!options2?.debounceKey) {
      performEmit(event, payload, options2);
      return;
    }
    const debounceMapKey = `${event}-${options2.debounceKey}`;
    debouncedEmitter(debounceMapKey, () => performEmit(event, payload, options2));
  };
  return {
    on,
    off,
    emit
  };
};
export {
  createWorkspaceEventBus
};
//# sourceMappingURL=bus.js.map
