{
  "version": 3,
  "sources": ["../../src/events/bus.ts"],
  "sourcesContent": ["import { debounce } from '@scalar/helpers/general/debounce'\n\nimport { unpackProxyObject } from '@/helpers/unpack-proxy'\n\nimport type { ApiReferenceEvents } from './definitions'\n\ntype Unsubscribe = () => void\n\n/**\n * Helper type for event listeners that makes the payload optional\n * if the event allows undefined, otherwise requires it.\n */\ntype EventListener<E extends keyof ApiReferenceEvents> = undefined extends ApiReferenceEvents[E]\n  ? (payload?: ApiReferenceEvents[E]) => void\n  : (payload: ApiReferenceEvents[E]) => void\n\n/**\n * Helper type for emit parameters that uses rest parameters\n * for a cleaner API surface.\n *\n * @example\n * bus.emit('scalar-update-sidebar', { value: true }, { debounceKey: 'test' })\n */\ntype EmitParameters<E extends keyof ApiReferenceEvents> = undefined extends ApiReferenceEvents[E]\n  ? [event: E, payload?: ApiReferenceEvents[E], options?: { skipUnpackProxy?: boolean; debounceKey?: string }]\n  : [event: E, payload: ApiReferenceEvents[E], options?: { skipUnpackProxy?: boolean; debounceKey?: string }]\n\n/**\n * Type-safe event bus for workspace events\n *\n * - Full type safety for event names and payloads\n * - Debug mode for development\n */\nexport type WorkspaceEventBus = {\n  /**\n   * Subscribe to an event\n   *\n   * @param event - The event name to listen for\n   * @param listener - Callback function that receives the event detail\n   * @returns Unsubscribe function to remove the listener\n   *\n   * @example\n   * const unsubscribe = bus.on('scalar-update-sidebar', (detail) => {\n   *   console.log('Sidebar state:', detail.value)\n   * })\n   *\n   * // Later, clean up\n   * unsubscribe()\n   */\n  on<E extends keyof ApiReferenceEvents>(event: E, listener: EventListener<E>): Unsubscribe\n\n  /**\n   * Remove a specific event listener\n   *\n   * @param event - The event name\n   * @param listener - The listener function to remove\n   *\n   * @example\n   * const handler = (detail) => console.log(detail)\n   * bus.on('scalar-update-sidebar', handler)\n   * bus.off('scalar-update-sidebar', handler)\n   */\n  off<E extends keyof ApiReferenceEvents>(event: E, listener: EventListener<E>): void\n\n  /**\n   * Emit an event with its payload\n   *\n   * @param event - The event name to emit\n   * @param payload - The event detail payload (optional if event allows undefined)\n   * @param options.skipUnpackProxy - Whether to skip unpacking the proxy object,\n   * useful if we are sure there is no proxy OR when passing js events like keyboard events.\n   * @param options.debounceKey - If present we will debounce the event by the key + event name.\n   *\n   * @example\n   * bus.emit('scalar-update-sidebar', { value: true })\n   */\n  emit<E extends keyof ApiReferenceEvents>(...args: EmitParameters<E>): void\n}\n\n/**\n * Options for creating an event bus\n */\ntype EventBusOptions = {\n  /**\n   * Enable debug mode to log all events and listener operations\n   * Useful for development and troubleshooting\n   */\n  debug?: boolean\n}\n\n/**\n * Creates a type-safe event bus for workspace events\n *\n * This implementation uses a Map for O(1) lookups and maintains\n * a separate Set for each event type to efficiently manage listeners.\n *\n * Create this once per application instance.\n *\n * @param options - Configuration options\n * @returns A fully type-safe event bus instance\n *\n * @example\n * const bus = createWorkspaceEventBus()\n *\n * // Subscribe to events\n * const unsubscribe = bus.on('scalar-update-sidebar', (detail) => {\n *   console.log('Sidebar:', detail.value)\n * })\n *\n * // Emit events\n * bus.emit('scalar-update-sidebar', { value: true })\n *\n * // Clean up\n * unsubscribe()\n */\nexport const createWorkspaceEventBus = (options: EventBusOptions = {}): WorkspaceEventBus => {\n  const { debug = false } = options\n\n  /**\n   * Map of event names to their listener sets\n   * Using Map for O(1) lookups and Set for O(1) add/remove operations\n   */\n  type ListenerSet = Set<EventListener<keyof ApiReferenceEvents>>\n  const events = new Map<keyof ApiReferenceEvents, ListenerSet>()\n\n  /**\n   * Track pending log entries for batching\n   */\n  type PendingLogEntry = { message: string; args: unknown[] }\n  const pendingLogs: PendingLogEntry[] = []\n  let logTimeout: ReturnType<typeof setTimeout> | null = null\n\n  /**\n   * Single debounce instance for all debounced emits\n   * Uses keys to separate different event + debounceKey combinations\n   */\n  const { execute: debouncedEmitter } = debounce({ delay: 328 })\n\n  /**\n   * Get or create a listener set for an event\n   */\n  const getListeners = <E extends keyof ApiReferenceEvents>(event: E): ListenerSet => {\n    const listeners = events.get(event) ?? new Set()\n    events.set(event, listeners)\n    return listeners\n  }\n\n  /**\n   * Flush batched logs using console.groupCollapsed\n   */\n  const flushLogs = (): void => {\n    if (pendingLogs.length === 0) {\n      return\n    }\n\n    if (debug) {\n      if (pendingLogs.length === 1) {\n        // Only one log, output it normally without grouping\n        const firstLog = pendingLogs[0]\n        if (firstLog) {\n          console.log(`[EventBus] ${firstLog.message}`, ...firstLog.args)\n        }\n      } else {\n        // Multiple logs, use a collapsed group\n        console.groupCollapsed(`[EventBus] ${pendingLogs.length} operations`)\n        for (const { message, args } of pendingLogs) {\n          console.log(message, ...args)\n        }\n        console.groupEnd()\n      }\n    }\n\n    pendingLogs.length = 0\n    logTimeout = null\n  }\n\n  /**\n   * Log debug information if debug mode is enabled\n   * Batches multiple logs together using console.groupCollapsed\n   */\n  const log = (message: string, ...args: unknown[]): void => {\n    if (debug) {\n      pendingLogs.push({ message, args })\n\n      // Clear existing timeout and set a new one to batch logs\n      if (logTimeout) {\n        clearTimeout(logTimeout)\n      }\n      logTimeout = setTimeout(flushLogs, 500)\n    }\n  }\n\n  const on = <E extends keyof ApiReferenceEvents>(event: E, listener: EventListener<E>): Unsubscribe => {\n    const listeners = getListeners(event)\n    listeners.add(listener as EventListener<keyof ApiReferenceEvents>)\n    log(`Added listener for \"${String(event)}\" (${listeners.size} total)`)\n\n    return () => off(event, listener)\n  }\n\n  const off = <E extends keyof ApiReferenceEvents>(event: E, listener: EventListener<E>): void => {\n    const listeners = events.get(event)\n    if (!listeners) {\n      return\n    }\n\n    listeners.delete(listener as EventListener<keyof ApiReferenceEvents>)\n    log(`Removed listener for \"${String(event)}\" (${listeners.size} remaining)`)\n\n    // Clean up empty listener sets to avoid memory leaks\n    if (listeners.size === 0) {\n      events.delete(event)\n    }\n  }\n\n  /**\n   * Internal function that performs the actual emission logic\n   * This is extracted so it can be wrapped with debouncing\n   */\n  const performEmit = <E extends keyof ApiReferenceEvents>(\n    event: E,\n    payload: ApiReferenceEvents[E] | undefined,\n    options?: { skipUnpackProxy?: boolean },\n  ): void => {\n    // We unpack the payload here to ensure that, within mutators, we are not assigning proxies directly,\n    // but are always assigning plain objects 5 level depth.\n    const unpackedPayload = options?.skipUnpackProxy ? payload : unpackProxyObject(payload, { depth: 5 })\n\n    const listeners = events.get(event)\n\n    if (!listeners || listeners.size === 0) {\n      log(`\uD83D\uDED1 No listeners for \"${String(event)}\"`)\n      return\n    }\n\n    log(`Emitting \"${String(event)}\" to ${listeners.size} listener(s)`, payload)\n\n    // Convert to array to avoid issues if listeners modify the set during iteration\n    const listenersArray = Array.from(listeners)\n\n    // Execute all listeners\n    for (const listener of listenersArray) {\n      try {\n        listener(unpackedPayload)\n      } catch (error) {\n        // Do not let one listener error break other listeners\n        console.error(`[EventBus] Error in listener for \"${String(event)}\":`, error)\n      }\n    }\n  }\n\n  const emit = <E extends keyof ApiReferenceEvents>(...args: EmitParameters<E>): void => {\n    const [event, payload, options] = args\n\n    // If no debounce key is provided, emit immediately\n    if (!options?.debounceKey) {\n      performEmit(event, payload, options)\n      return\n    }\n\n    // Create a unique key for this event + debounce key combination\n    const debounceMapKey = `${event}-${options.debounceKey}`\n\n    // Pass the closure directly - debounce will store the latest version\n    debouncedEmitter(debounceMapKey, () => performEmit(event, payload, options))\n  }\n\n  return {\n    on,\n    off,\n    emit,\n  }\n}\n"],
  "mappings": "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",
  "names": ["options"]
}
