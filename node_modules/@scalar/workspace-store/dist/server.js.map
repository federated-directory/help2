{
  "version": 3,
  "sources": ["../src/server.ts"],
  "sourcesContent": ["import fs from 'node:fs/promises'\nimport { cwd } from 'node:process'\n\nimport type { LoaderPlugin } from '@scalar/json-magic/bundle'\nimport { fetchUrls, readFiles } from '@scalar/json-magic/bundle/plugins/node'\nimport { escapeJsonPointer } from '@scalar/json-magic/helpers/escape-json-pointer'\nimport { upgrade } from '@scalar/openapi-upgrader'\n\nimport { keyOf } from '@/helpers/general'\nimport { createNavigation } from '@/navigation'\nimport type { NavigationOptions } from '@/navigation/get-navigation-options'\nimport { extensions } from '@/schemas/extensions'\nimport type { TraversedDocument } from '@/schemas/navigation'\nimport { coerceValue } from '@/schemas/typebox-coerce'\nimport {\n  type ComponentsObject,\n  OpenAPIDocumentSchema,\n  type OpenApiDocument,\n  type OperationObject,\n  type PathsObject,\n} from '@/schemas/v3.1/strict/openapi-document'\n\nimport { getValueByPath, parseJsonPointer } from './helpers/json-path-utils'\nimport type { WorkspaceDocumentMeta, WorkspaceMeta } from './schemas/workspace'\n\nconst DEFAULT_ASSETS_FOLDER = 'assets'\nexport const WORKSPACE_FILE_NAME = 'scalar-workspace.json'\n\ntype WorkspaceDocumentMetaInput = {\n  name: string\n  meta?: WorkspaceDocumentMeta\n}\n\ntype UrlDoc = { url: string } & WorkspaceDocumentMetaInput\ntype FileDoc = { path: string } & WorkspaceDocumentMetaInput\ntype ObjectDoc = { document: Record<string, unknown> } & WorkspaceDocumentMetaInput\n\ntype WorkspaceDocumentInput = UrlDoc | ObjectDoc | FileDoc\n\ntype CreateServerWorkspaceStoreBase = {\n  documents: WorkspaceDocumentInput[]\n  meta?: WorkspaceMeta\n  navigationOptions?: NavigationOptions\n}\ntype CreateServerWorkspaceStore =\n  | ({\n      directory?: string\n      mode: 'static'\n    } & CreateServerWorkspaceStoreBase)\n  | ({\n      baseUrl: string\n      mode: 'ssr'\n    } & CreateServerWorkspaceStoreBase)\n\nconst httpMethods = new Set(['get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace'])\n\n/**\n * Filters an OpenAPI PathsObject to only include standard HTTP methods.\n * Removes any vendor extensions or other non-HTTP properties.\n *\n * @param paths - The OpenAPI PathsObject to filter\n * @returns A new PathsObject containing only standard HTTP methods\n *\n * @example\n * Input: {\n *   \"/users\": {\n *     \"get\": {...},\n *     \"x-custom\": {...},\n *     \"post\": {...}\n *   }\n * }\n * Output: {\n *   \"/users\": {\n *     \"get\": {...},\n *     \"post\": {...}\n *   }\n * }\n */\nexport function filterHttpMethodsOnly(paths: PathsObject): Record<string, Record<string, OperationObject>> {\n  const result: Record<string, Record<string, OperationObject>> = {}\n\n  // Todo: skip extension properties\n  for (const [path, methods] of Object.entries(paths)) {\n    if (!methods) {\n      continue\n    }\n\n    const filteredMethods: Record<string, any> = {}\n\n    for (const [method, operation] of Object.entries(methods)) {\n      if (httpMethods.has(method.toLowerCase())) {\n        filteredMethods[method] = operation\n      }\n    }\n\n    if (Object.keys(filteredMethods).length > 0) {\n      result[path] = filteredMethods\n    }\n  }\n\n  return result\n}\n\n/**\n * Escapes path keys in an OpenAPI PathsObject to be JSON Pointer compatible.\n * This is necessary because OpenAPI paths can contain characters that need to be escaped\n * when used as JSON Pointer references (like '/' and '~').\n *\n * @example\n * Input: { \"/users/{id}\": { ... } }\n * Output: { \"/users~1{id}\": { ... } }\n */\nexport function escapePaths(\n  paths: Record<string, Record<string, OperationObject>>,\n): Record<string, Record<string, OperationObject>> {\n  const result: Record<string, Record<string, OperationObject>> = {}\n\n  Object.keys(paths).forEach((path) => {\n    if (paths[path]) {\n      result[escapeJsonPointer(path)] = paths[path]\n    }\n  })\n\n  return result\n}\n\n/**\n * Externalizes components by turning them into refs.\n */\nexport function externalizeComponentReferences(\n  document: OpenApiDocument,\n  meta: { mode: 'ssr'; name: string; baseUrl: string } | { mode: 'static'; name: string; directory: string },\n) {\n  const result: Record<string, any> = {}\n\n  if (!document.components) {\n    return result\n  }\n\n  Object.entries(document.components).forEach(([type, component]) => {\n    if (!component || typeof component !== 'object') {\n      return\n    }\n\n    result[type] = {}\n    Object.keys(component).forEach((name) => {\n      const ref =\n        meta.mode === 'ssr'\n          ? `${meta.baseUrl}/${meta.name}/components/${type}/${name}#`\n          : `./chunks/${meta.name}/components/${type}/${name}.json#`\n\n      result[type][name] = { '$ref': ref, $global: true }\n    })\n  })\n\n  return result\n}\n\n/**\n * Externalizes paths operations by turning them into refs.\n */\nexport function externalizePathReferences(\n  document: OpenApiDocument,\n  meta: { mode: 'ssr'; name: string; baseUrl: string } | { mode: 'static'; name: string; directory: string },\n) {\n  const result: Record<string, any> = {}\n\n  if (!document.paths) {\n    return result\n  }\n\n  Object.entries(document.paths).forEach(([path, pathItem]) => {\n    if (!pathItem || typeof pathItem !== 'object') {\n      return\n    }\n\n    const pathItemRecord = pathItem as Record<string, unknown>\n\n    result[path] = {}\n\n    const escapedPath = escapeJsonPointer(path)\n\n    keyOf(pathItemRecord).forEach((type) => {\n      if (httpMethods.has(type)) {\n        const ref =\n          meta.mode === 'ssr'\n            ? `${meta.baseUrl}/${meta.name}/operations/${escapedPath}/${type}#`\n            : `./chunks/${meta.name}/operations/${escapedPath}/${type}.json#`\n\n        result[path][type] = { '$ref': ref, $global: true }\n      } else {\n        result[path][type] = pathItemRecord[type]\n      }\n    })\n  })\n\n  return result\n}\n\n/**\n * Resolves a workspace document from various input sources (URL, local file, or direct document object).\n *\n * @param workspaceDocument - The document input to resolve, which can be:\n *   - A URL to fetch the document from\n *   - A local file path to read the document from\n *   - A direct document object\n * @returns A promise that resolves to an object containing:\n *   - ok: boolean indicating if the resolution was successful\n *   - data: The resolved document data\n *\n * @example\n * // Resolve from URL\n * const urlDoc = await loadDocument({ name: 'api', url: 'https://api.example.com/openapi.json' })\n *\n * // Resolve direct document\n * const directDoc = await loadDocument({\n *   name: 'inline',\n *   document: { openapi: '3.0.0', paths: {} }\n * })\n */\nfunction loadDocument(workspaceDocument: WorkspaceDocumentInput): ReturnType<LoaderPlugin['exec']> {\n  if ('url' in workspaceDocument) {\n    return fetchUrls().exec(workspaceDocument.url)\n  }\n\n  if ('path' in workspaceDocument) {\n    return readFiles().exec(workspaceDocument.path)\n  }\n\n  return Promise.resolve({\n    ok: true,\n    data: workspaceDocument.document,\n    raw: JSON.stringify(workspaceDocument.document),\n  })\n}\n\n/**\n * Create server state workspace store\n */\nexport async function createServerWorkspaceStore(workspaceProps: CreateServerWorkspaceStore) {\n  /**\n   * Base workspace document containing essential metadata and document references.\n   *\n   * This workspace document provides the minimal information needed for initial rendering.\n   * All components and path operations are replaced with references to enable lazy loading.\n   *\n   * In SSR mode, references point to API endpoints.\n   * In static mode, references point to filesystem chunks.\n   */\n  const workspace = {\n    ...workspaceProps.meta,\n    documents: {} as Record<string, OpenApiDocument & { [extensions.document.navigation]: TraversedDocument }>,\n  }\n\n  /**\n   * A map of document chunks that can be loaded asynchronously by the client.\n   * Each document is split into components and operations to enable lazy loading.\n   * The keys are document names and values contain the components and operations\n   * for that document.\n   */\n  const assets = {} as Record<\n    string,\n    { components?: ComponentsObject; operations?: Record<string, Record<string, OperationObject>> }\n  >\n\n  /**\n   * Adds a new document to the workspace.\n   *\n   * This function processes an OpenAPI document by:\n   * 1. Converting it to OpenAPI 3.1 format if needed\n   * 2. Separating it into reusable components and path operations\n   * 3. Externalizing references based on the workspace mode (SSR or static)\n   * 4. Adding the processed document to the workspace with its metadata\n   *\n   * The resulting document contains minimal information with externalized references\n   * that will be resolved on-demand through the workspace's get() method.\n   *\n   * @param document - The OpenAPI document to process and add\n   * @param meta - Document metadata containing the required name and optional settings\n   */\n  const addDocumentSync = (document: Record<string, unknown>, meta: { name: string } & WorkspaceDocumentMeta) => {\n    const { name, ...documentMeta } = meta\n\n    const documentV3 = coerceValue(OpenAPIDocumentSchema, upgrade(document, '3.1'))\n\n    // add the assets\n    assets[meta.name] = {\n      components: documentV3.components,\n      operations: documentV3.paths && escapePaths(filterHttpMethodsOnly(documentV3.paths)),\n    }\n\n    const options =\n      workspaceProps.mode === 'ssr'\n        ? { mode: workspaceProps.mode, name, baseUrl: workspaceProps.baseUrl }\n        : { mode: workspaceProps.mode, name, directory: workspaceProps.directory ?? DEFAULT_ASSETS_FOLDER }\n\n    const components = externalizeComponentReferences(documentV3, options)\n    const paths = externalizePathReferences(documentV3, options)\n\n    // Build the sidebar entries\n    const navigation = createNavigation(name, documentV3, workspaceProps.navigationOptions)\n\n    // The document is now a minimal version with externalized references to components and operations.\n    // These references will be resolved asynchronously when needed through the workspace's get() method.\n    workspace.documents[meta.name] = {\n      ...documentMeta,\n      ...documentV3,\n      components,\n      paths,\n      [extensions.document.navigation]: navigation,\n    }\n  }\n\n  /**\n   * Adds a new document to the workspace asynchronously.\n   *\n   * This function:\n   * 1. Loads the document using the provided input\n   * 2. Checks if the document loaded successfully\n   * 3. If successful, adds the document to the workspace using addDocumentSync\n   *\n   * @param input - The document input containing the document source and metadata\n   */\n  const addDocument = async (input: WorkspaceDocumentInput) => {\n    const document = await loadDocument(input)\n\n    if (!document.ok) {\n      console.warn(`Failed to load document \"${input.name}`)\n      return\n    }\n\n    addDocumentSync(document.data as Record<string, unknown>, { name: input.name, ...input.meta })\n  }\n\n  // Load and process all initial documents in parallel\n  await Promise.all(workspaceProps.documents.map((document) => addDocument(document)))\n\n  return {\n    /**\n     * Generates workspace chunks by writing components and operations to the filesystem.\n     *\n     * This method is only available in static mode. It creates a directory structure containing:\n     * - A workspace file with metadata and document references\n     * - Component chunks split by type (schemas, parameters, etc)\n     * - Operation chunks split by path and HTTP method\n     *\n     * The generated workspace references will be relative file paths pointing to these chunks.\n     *\n     * @throws {Error} If called when mode is not 'static'\n     */\n    generateWorkspaceChunks: async () => {\n      if (workspaceProps.mode !== 'static') {\n        throw 'Mode has to be set to `static` to generate filesystem workspace chunks'\n      }\n\n      // Write the workspace document\n      const basePath = `${cwd()}/${workspaceProps.directory ?? DEFAULT_ASSETS_FOLDER}`\n      await fs.mkdir(basePath, { recursive: true })\n\n      // Write the workspace contents on the file system\n      await fs.writeFile(`${basePath}/${WORKSPACE_FILE_NAME}`, JSON.stringify(workspace))\n\n      // Write the chunks\n      for (const [name, { components, operations }] of Object.entries(assets)) {\n        // Write the components chunks\n        if (components) {\n          for (const [type, component] of Object.entries(components as Record<string, Record<string, unknown>>)) {\n            const componentPath = `${basePath}/chunks/${name}/components/${type}`\n            await fs.mkdir(componentPath, { recursive: true })\n\n            for (const [key, value] of Object.entries(component)) {\n              await fs.writeFile(`${componentPath}/${key}.json`, JSON.stringify(value))\n            }\n          }\n        }\n\n        // Write the operations chunks\n        if (operations) {\n          for (const [path, methods] of Object.entries(operations)) {\n            const operationPath = `${basePath}/chunks/${name}/operations/${path}`\n            await fs.mkdir(operationPath, { recursive: true })\n\n            for (const [method, operation] of Object.entries(methods)) {\n              await fs.writeFile(`${operationPath}/${method}.json`, JSON.stringify(operation))\n            }\n          }\n        }\n      }\n    },\n    /**\n     * Returns the workspace document containing metadata and all sparse documents.\n     *\n     * The workspace document includes:\n     * - Global workspace metadata (theme, active document, etc)\n     * - Document metadata and sparse document\n     * - In SSR mode: References point to in-memory chunks\n     * - In static mode: References point to filesystem chunks\n     *\n     * @returns The complete workspace document\n     */\n    getWorkspace: () => {\n      return workspace\n    },\n    /**\n     * Retrieves a chunk of data from the workspace using a JSON Pointer\n     *\n     * A JSON Pointer is a string that references a specific location in a JSON document.\n     * Only components and operations chunks can be retrieved.\n     *\n     * @example\n     * ```ts\n     * // Get a component\n     * get('#/document-name/components/schemas/User')\n     *\n     * // Get an operation\n     * get('#/document-name/operations/pets/get')\n     * ```\n     *\n     * @param pointer - The JSON Pointer string to locate the chunk\n     * @returns The chunk data if found, undefined otherwise\n     */\n    get: (pointer: string) => {\n      return getValueByPath(assets, parseJsonPointer(pointer))\n    },\n    /**\n     * Adds a new document to the workspace asynchronously.\n     *\n     * This function:\n     * 1. Loads the document using the provided input\n     * 2. Checks if the document loaded successfully\n     * 3. If successful, adds the document to the workspace using addDocumentSync\n     *\n     * @param input - The document input containing the document source and metadata\n     */\n    addDocument,\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
