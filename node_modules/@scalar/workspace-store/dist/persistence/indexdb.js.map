{
  "version": 3,
  "sources": ["../../src/persistence/indexdb.ts"],
  "sourcesContent": ["import type { Static, TObject, TRecord } from '@scalar/typebox'\n\ntype TableEntry<S extends TObject, K extends readonly (keyof Static<S>)[]> = {\n  schema: S\n  keyPath: K\n  indexes?: Record<string, readonly (keyof Static<S>)[]>\n}\n\n/**\n * Initializes and manages an IndexedDB database connection for table-based persistence.\n *\n * @param name - The database name. Defaults to 'scalar-workspace-store'.\n * @param tables - Table definitions: the tables to create and their key schemas.\n * @param version - The database version. Bump this to trigger upgrades (default: 1).\n * @param migrations - Optional migration steps to run for version upgrades.\n * @returns An object with the following methods:\n *   - `get(tableName)` \u2014 Get a wrapper to interact with the object store for the given table name.\n *   - `closeDatabase()` \u2014 Closes the database connection.\n *\n * Example usage:\n * ```ts\n * import { Type } from '@scalar/typebox'\n * import { createIndexDbConnection } from './indexdb'\n *\n * // Define a schema for a user\n * const UserSchema = Type.Object({\n *   id: Type.String(),\n *   name: Type.String(),\n *   age: Type.Number(),\n * })\n *\n * // Define tables in the database\n * const dbConfig = {\n *   users: {\n *     schema: UserSchema,\n *     index: ['id'] as const,\n *   },\n * }\n *\n * // Open the database connection and get table API\n * const { get, closeDatabase } = await createIndexDbConnection({\n *   name: 'my-app-db',\n *   tables: dbConfig,\n *   version: 1,\n * })\n *\n * // Get a strongly-typed users table API\n * const usersTable = get('users')\n *\n * // Add a user\n * await usersTable.addItem({ id: 'user-1' }, { name: 'Alice', age: 25 })\n *\n * // Retrieve a user by id\n * const user = await usersTable.getItem({ id: 'user-1' })\n *\n * // Don't forget to close the database when done!\n * closeDatabase()\n * ```\n */\nexport const createIndexDbConnection = async <T extends Record<string, TableEntry<any, readonly (keyof any)[]>>>({\n  name = 'scalar-workspace-store',\n  tables,\n  version = 1,\n  migrations = [],\n}: {\n  name: string\n  tables: T\n  version: number\n  migrations?: { version: number; exec: (db: IDBDatabase, event: IDBVersionChangeEvent) => {} }[]\n}) => {\n  const db = indexedDB.open(name, version)\n\n  db.onupgradeneeded = (e) => {\n    // Initial setup of object stores\n    if (e.oldVersion < 1) {\n      const database = db.result\n\n      // Initialize all the tables\n      Object.entries(tables).forEach(([name, options]) => {\n        if (!database.objectStoreNames.contains(name)) {\n          const objectStore = database.createObjectStore(name, {\n            keyPath: options.keyPath.length === 1 ? (options.keyPath[0] as string) : (options.keyPath as string[]),\n          })\n\n          // Create any indexes for the object store\n          Object.entries(options.indexes ?? {}).forEach(([indexName, indexPath]) => {\n            objectStore.createIndex(indexName, indexPath as string[])\n          })\n        }\n      })\n    }\n\n    // Run any future migrations here\n    migrations.forEach((migration) => {\n      if (e.oldVersion < migration.version) {\n        migration.exec(db.result, e)\n      }\n    })\n  }\n\n  await new Promise((resolve, reject) => {\n    db.onsuccess = () => resolve(true)\n    db.onerror = () => reject(db.error)\n  })\n\n  return {\n    get: <Name extends keyof T>(name: Name) => {\n      return createTableWrapper<T[Name]['schema'], T[Name]['keyPath'][number]>(name as string, db.result)\n    },\n    closeDatabase: () => {\n      db.result.close()\n    },\n  }\n}\n\n/**\n * Utility wrapper for interacting with an IndexedDB object store, typed by the schema.\n *\n * Usage example:\n * ```\n * // Define a TypeBox schema for users\n * const UserSchema = Type.Object({\n *   id: Type.String(),\n *   name: Type.String(),\n *   age: Type.Number(),\n * })\n * \n * // Open or create the users table\n * const usersTable = createTableWrapper<typeof UserSchema, 'id'>('users', openDatabase)\n * \n * // Add a user\n  await usersTable.addItem({ id: 'user-1' }, { name: 'Alice', age: 24 })\n * \n * // Get a user by id\n * const alic = await usersTable.getItem({ id: 'user-1' })\n * \n * // Get users with a partial key (use [] if no composite key)\n * const users = await usersTable.getRange(['user-1'])\n * \n * // Get all users\n * const allUsers = await usersTable.getAll()\n * ```\n *\n * @template T TypeBox schema type for objects in the store\n * @template K Key property names that compose the primary key\n *\n * @param name - Object store name\n * @param getDb - Function returning a Promise for the IDBDatabase\n * @returns Methods to interact with the object store\n */\nfunction createTableWrapper<T extends TRecord | TObject, const K extends keyof Static<T>>(\n  name: string,\n  db: IDBDatabase,\n) {\n  /**\n   * Gets the object store from the latest DB connection, for the given transaction mode.\n   */\n  const getStore = (mode: IDBTransactionMode): IDBObjectStore => {\n    const tx = db.transaction(name, mode)\n    return tx.objectStore(name)\n  }\n\n  /**\n   * Adds or updates an item in the store.\n   * @param key - The primary key values, as { key1, key2 }\n   * @param value - The value for the other properties, omitting keys\n   * @returns The full inserted/updated object\n   */\n  async function addItem(key: Record<K, IDBValidKey>, value: Omit<Static<T>, K>): Promise<Static<T>> {\n    const store = getStore('readwrite')\n    const keyObj: any = { ...key }\n    const finalValue = { ...keyObj, ...value }\n    await requestAsPromise(store.put(finalValue))\n\n    return finalValue\n  }\n\n  /**\n   * Retrieves a single item by composite key.\n   * @param key - Key values. For a single key: { id: '...' }\n   * @returns The found object or undefined\n   */\n  function getItem(key: Record<K, IDBValidKey>): Promise<Static<T> | undefined> {\n    const store = getStore('readonly')\n    const keyValues = Object.values(key)\n    // For single keys, pass value directly; for compound keys, pass array\n    const keyToUse = keyValues.length === 1 ? keyValues[0] : keyValues\n    return requestAsPromise(store.get(keyToUse as IDBValidKey))\n  }\n\n  /**\n   * Returns all records matching a partial (prefix) key. Use for composite keys.\n   * For non-compound keys, pass single-element array: getRange(['some-id'])\n   * For prefix search, pass subset of key parts.\n   * @param partialKey - Array of partial key values\n   * @returns Matching objects\n   *\n   * Example (composite [a,b]):\n   *   getRange(['foo']) // All with a === 'foo'\n   *   getRange(['foo', 'bar']) // All with a === 'foo' and b === 'bar'\n   */\n  function getRange(partialKey: IDBValidKey[], indexName?: string): Promise<Static<T>[]> {\n    const store = getStore('readonly')\n    const objectStoreOrIndex = indexName ? store.index(indexName as string) : store\n\n    const results: Static<T>[] = []\n\n    // Construct upper bound to match all keys starting with partialKey\n    const upperBound = [...partialKey]\n    upperBound.push([]) // ensures upper bound includes all keys with this prefix\n    const range = IDBKeyRange.bound(partialKey, upperBound, false, true)\n\n    return new Promise((resolve, reject) => {\n      const request = objectStoreOrIndex.openCursor(range)\n      request.onerror = () => reject(request.error)\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result\n        if (cursor) {\n          results.push(cursor.value)\n          cursor.continue()\n        } else {\n          resolve(results)\n        }\n      }\n    })\n  }\n\n  /**\n   * Deletes an item from the store by its composite key.\n   * @param key - Key values. For a single key: { id: '...' }\n   * @returns void\n   */\n  async function deleteItem(key: Record<K, IDBValidKey>): Promise<void> {\n    const store = getStore('readwrite')\n    const keyValues = Object.values(key)\n    // For single keys, pass value directly; for compound keys, pass array\n    const keyToUse = keyValues.length === 1 ? keyValues[0] : keyValues\n    await requestAsPromise(store.delete(keyToUse as IDBValidKey))\n  }\n\n  /**\n   * Deletes all records matching a partial (prefix) key. Use for composite keys.\n   * For non-compound keys, pass single-element array: deleteRange(['some-id'])\n   * For prefix deletion, pass subset of key parts.\n   * @param partialKey - Array of partial key values\n   * @returns Number of deleted items\n   *\n   * Example (composite [a,b]):\n   *   deleteRange(['foo']) // Delete all with a === 'foo'\n   *   deleteRange(['foo', 'bar']) // Delete all with a === 'foo' and b === 'bar'\n   */\n  function deleteRange(partialKey: IDBValidKey[]): Promise<number> {\n    const store = getStore('readwrite')\n    let deletedCount = 0\n\n    // Construct upper bound to match all keys starting with partialKey\n    const upperBound = [...partialKey]\n    upperBound.push([]) // ensures upper bound includes all keys with this prefix\n    const range = IDBKeyRange.bound(partialKey, upperBound, false, true)\n\n    return new Promise((resolve, reject) => {\n      const request = store.openCursor(range)\n      request.onerror = () => reject(request.error)\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result\n        if (cursor) {\n          cursor.delete()\n          deletedCount++\n          cursor.continue()\n        } else {\n          resolve(deletedCount)\n        }\n      }\n    })\n  }\n\n  /**\n   * Deletes all items from the table.\n   * @returns void\n   */\n  async function deleteAll(): Promise<void> {\n    const store = getStore('readwrite')\n    await requestAsPromise(store.clear())\n  }\n\n  /**\n   * Retrieves all items from the table.\n   * @returns Array of all objects in the store\n   */\n  function getAll(): Promise<Static<T>[]> {\n    const store = getStore('readonly')\n    return requestAsPromise(store.getAll())\n  }\n\n  return {\n    addItem,\n    getItem,\n    getRange,\n    deleteItem,\n    deleteRange,\n    getAll,\n    deleteAll,\n  }\n}\n\n// ---- Utility ----\nfunction requestAsPromise<T>(req: IDBRequest<T>): Promise<T> {\n  return new Promise((resolve, reject) => {\n    req.onsuccess = () => resolve(req.result)\n    req.onerror = () => reject(req.error)\n  })\n}\n"],
  "mappings": "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",
  "names": ["name"]
}
