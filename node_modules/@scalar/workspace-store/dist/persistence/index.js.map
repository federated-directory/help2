{
  "version": 3,
  "sources": ["../../src/persistence/index.ts"],
  "sourcesContent": ["import { Type } from '@scalar/typebox'\n\nimport { createIndexDbConnection } from '@/persistence/indexdb'\nimport type { InMemoryWorkspace } from '@/schemas/inmemory-workspace'\nimport type { WorkspaceMeta } from '@/schemas/workspace'\n\ntype WorkspaceKey = {\n  namespace?: string\n  slug: string\n}\n\ntype WorkspaceStoreShape = {\n  teamUid?: string\n  name: string\n  workspace: InMemoryWorkspace\n}\n\n/** Generates a workspace ID from namespace and slug. */\nconst getWorkspaceId = (namespace: string, slug: string) => `${namespace}/${slug}`\n\n/**\n * Creates the persistence layer for the workspace store using IndexedDB.\n * This sets up all the required tables for storing workspace chunk information,\n * such as workspace meta, documents, original documents, intermediate documents, overrides, etc.\n * Each logical group (meta, documents, etc) gets its own table keyed appropriately for efficient sub-document access.\n * Returns an object containing `meta`, `documents`, `originalDocuments`, `intermediateDocuments`, `overrides`,\n * `documentMeta`, `documentConfigs`, and `workspace` sections, each exposing a `setItem` method\n * for upsetting records, and in the case of `workspace`, also `getItem` and `deleteItem`.\n */\nexport const createWorkspaceStorePersistence = async () => {\n  // Create the database connection and setup all required tables for workspace storage.\n  const connection = await createIndexDbConnection({\n    name: 'scalar-workspace-store',\n    version: 1,\n    tables: {\n      workspace: {\n        schema: Type.Object({\n          /** Visual name for a given workspace */\n          name: Type.String(),\n          /** When logged in all new workspaces (remote and local) are scoped to a team  */\n          teamUid: Type.String({ default: 'local' }),\n          /** Namespace associated with a remote workspace */\n          namespace: Type.String({ default: 'local' }),\n          /** Slug associated with a remote workspace */\n          slug: Type.String({ default: 'local' }),\n        }),\n        keyPath: ['namespace', 'slug'],\n        indexes: {\n          teamUid: ['teamUid'],\n        },\n      },\n      meta: {\n        schema: Type.Object({ workspaceId: Type.String(), data: Type.Any() }),\n        keyPath: ['workspaceId'],\n      },\n      documents: {\n        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),\n        keyPath: ['workspaceId', 'documentName'],\n      },\n      originalDocuments: {\n        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),\n        keyPath: ['workspaceId', 'documentName'],\n      },\n      intermediateDocuments: {\n        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),\n        keyPath: ['workspaceId', 'documentName'],\n      },\n      overrides: {\n        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),\n        keyPath: ['workspaceId', 'documentName'],\n      },\n    },\n  })\n\n  // Tables wrappers for each logical section.\n  const workspaceTable = connection.get('workspace')\n  const metaTable = connection.get('meta')\n  const documentsTable = connection.get('documents')\n  const originalDocumentTable = connection.get('originalDocuments')\n  const intermediateDocumentTable = connection.get('intermediateDocuments')\n  const overridesTable = connection.get('overrides')\n\n  // The returned persistence API with logical sections for each table and mapping.\n  return {\n    close: () => {\n      connection.closeDatabase()\n    },\n    meta: {\n      /**\n       * Set meta data for a workspace.\n       */\n      setItem: async (workspaceId: string, data: WorkspaceMeta) => {\n        await metaTable.addItem({ workspaceId }, { data })\n      },\n    },\n    documents: {\n      /**\n       * Set (persist) a workspace document using workspaceId and documentName as composite key.\n       */\n      setItem: async (workspaceId: string, documentName: string, data: InMemoryWorkspace['documents'][string]) => {\n        await documentsTable.addItem({ workspaceId, documentName }, { data })\n      },\n    },\n    originalDocuments: {\n      /**\n       * Set an original (raw) document for a workspace/document pair.\n       */\n      setItem: async (\n        workspaceId: string,\n        documentName: string,\n        data: InMemoryWorkspace['originalDocuments'][string],\n      ) => {\n        await originalDocumentTable.addItem({ workspaceId, documentName }, { data })\n      },\n    },\n    intermediateDocuments: {\n      /**\n       * Set an intermediate (transformed) document for a workspace/document pair.\n       */\n      setItem: async (\n        workspaceId: string,\n        documentName: string,\n        data: InMemoryWorkspace['intermediateDocuments'][string],\n      ) => {\n        await intermediateDocumentTable.addItem({ workspaceId, documentName }, { data })\n      },\n    },\n    overrides: {\n      /**\n       * Set document overrides for a workspace/document pair.\n       */\n      setItem: async (workspaceId: string, documentName: string, data: InMemoryWorkspace['overrides'][string]) => {\n        await overridesTable.addItem({ workspaceId, documentName }, { data })\n      },\n    },\n    workspace: {\n      /**\n       * Retrieves a workspace by its ID.\n       * Returns undefined if the workspace does not exist.\n       * Gathers all workspace 'chunk' tables and assembles a full workspace shape.\n       */\n      getItem: async ({\n        namespace,\n        slug,\n      }: Required<WorkspaceKey>): Promise<(WorkspaceStoreShape & Required<WorkspaceKey>) | undefined> => {\n        const workspace = await workspaceTable.getItem({ namespace, slug })\n\n        if (!workspace) {\n          return undefined\n        }\n\n        // Create a composite key for the workspace chunks.\n        const id = getWorkspaceId(namespace, slug)\n\n        // Retrieve all chunk records for this workspace.\n        const workspaceDocuments = await documentsTable.getRange([id])\n        const workspaceOriginalDocuments = await originalDocumentTable.getRange([id])\n        const workspaceIntermediateDocuments = await intermediateDocumentTable.getRange([id])\n        const workspaceOverrides = await overridesTable.getRange([id])\n        const workspaceMeta = await metaTable.getItem({ workspaceId: id })\n\n        // Compose the workspace structure from table records.\n        return {\n          name: workspace.name,\n          teamUid: workspace.teamUid,\n          namespace: workspace.namespace,\n          slug: workspace.slug,\n          workspace: {\n            documents: Object.fromEntries(workspaceDocuments.map((item) => [item.documentName, item.data])),\n            originalDocuments: Object.fromEntries(\n              workspaceOriginalDocuments.map((item) => [item.documentName, item.data]),\n            ),\n            intermediateDocuments: Object.fromEntries(\n              workspaceIntermediateDocuments.map((item) => [item.documentName, item.data]),\n            ),\n            overrides: Object.fromEntries(workspaceOverrides.map((item) => [item.documentName, item.data])),\n            meta: workspaceMeta?.data,\n          },\n        }\n      },\n\n      /**\n       * Retrieves all workspaces from the database.\n       * Returns only the workspace ID and name for each workspace.\n       * To get the full workspace data including documents and metadata, use getItem() with a specific ID.\n       * Returns an empty array if no workspaces exist.\n       */\n      getAll: async () => {\n        return await workspaceTable.getAll()\n      },\n\n      /**\n       * Retrieves all workspaces for a given team UID.\n       */\n      getAllByTeamUid: async (teamUid: string) => {\n        return await workspaceTable.getRange([teamUid], 'teamUid')\n      },\n\n      /**\n       * Saves a workspace to the database.\n       * All chunks (meta, documents, configs, etc.) are upsert in their respective tables.\n       * If a workspace with the same ID already exists, it will be replaced.\n       */\n      setItem: async ({ namespace = 'local', slug }: WorkspaceKey, value: WorkspaceStoreShape) => {\n        const workspace = await workspaceTable.addItem(\n          { namespace, slug },\n          {\n            name: value.name,\n            teamUid: value.teamUid ?? 'local',\n          },\n        )\n\n        const id = getWorkspaceId(namespace, slug)\n\n        // Save all meta info for workspace.\n        await metaTable.addItem({ workspaceId: id }, { data: value.workspace.meta })\n\n        // Persist all workspace documents (chunks).\n        await Promise.all(\n          Object.entries(value.workspace.documents ?? {}).map(([name, data]) => {\n            return documentsTable.addItem({ workspaceId: id, documentName: name }, { data })\n          }),\n        )\n\n        // Persist all original documents.\n        await Promise.all(\n          Object.entries(value.workspace.originalDocuments ?? {}).map(([name, data]) => {\n            return originalDocumentTable.addItem({ workspaceId: id, documentName: name }, { data })\n          }),\n        )\n\n        // Persist all intermediate documents.\n        await Promise.all(\n          Object.entries(value.workspace.intermediateDocuments ?? {}).map(([name, data]) => {\n            return intermediateDocumentTable.addItem({ workspaceId: id, documentName: name }, { data })\n          }),\n        )\n\n        // Persist all document overrides.\n        await Promise.all(\n          Object.entries(value.workspace.overrides ?? {}).map(([name, data]) => {\n            return overridesTable.addItem({ workspaceId: id, documentName: name }, { data })\n          }),\n        )\n\n        return workspace\n      },\n\n      /**\n       * Deletes an entire workspace and all associated chunk records from all tables by ID.\n       */\n      deleteItem: async ({ namespace, slug }: Required<WorkspaceKey>): Promise<void> => {\n        const id = getWorkspaceId(namespace, slug)\n\n        await workspaceTable.deleteItem({ namespace, slug })\n\n        // Remove all workspace-related records from all chunk tables.\n        await Promise.all([\n          // By id\n          metaTable.deleteItem({ workspaceId: id }),\n\n          // By range (composite-key tables)\n          documentsTable.deleteRange([id]),\n          originalDocumentTable.deleteRange([id]),\n          intermediateDocumentTable.deleteRange([id]),\n          overridesTable.deleteRange([id]),\n        ])\n      },\n\n      deleteDocument: async (workspaceId: string, documentName: string): Promise<void> => {\n        await Promise.all([\n          documentsTable.deleteItem({ workspaceId, documentName }),\n          intermediateDocumentTable.deleteItem({ workspaceId, documentName }),\n          originalDocumentTable.deleteItem({ workspaceId, documentName }),\n          overridesTable.deleteItem({ workspaceId, documentName }),\n        ])\n      },\n\n      /**\n       * Checks if a workspace with the given ID exists in the store.\n       */\n      has: async ({ namespace, slug }: Required<WorkspaceKey>): Promise<boolean> => {\n        return (await workspaceTable.getItem({ namespace, slug })) !== undefined\n      },\n    },\n    clear: async () => {\n      await workspaceTable.deleteAll()\n    },\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
