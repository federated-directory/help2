const createIndexDbConnection = async ({
  name = "scalar-workspace-store",
  tables,
  version = 1,
  migrations = []
}) => {
  const db = indexedDB.open(name, version);
  db.onupgradeneeded = (e) => {
    if (e.oldVersion < 1) {
      const database = db.result;
      Object.entries(tables).forEach(([name2, options]) => {
        if (!database.objectStoreNames.contains(name2)) {
          const objectStore = database.createObjectStore(name2, {
            keyPath: options.keyPath.length === 1 ? options.keyPath[0] : options.keyPath
          });
          Object.entries(options.indexes ?? {}).forEach(([indexName, indexPath]) => {
            objectStore.createIndex(indexName, indexPath);
          });
        }
      });
    }
    migrations.forEach((migration) => {
      if (e.oldVersion < migration.version) {
        migration.exec(db.result, e);
      }
    });
  };
  await new Promise((resolve, reject) => {
    db.onsuccess = () => resolve(true);
    db.onerror = () => reject(db.error);
  });
  return {
    get: (name2) => {
      return createTableWrapper(name2, db.result);
    },
    closeDatabase: () => {
      db.result.close();
    }
  };
};
function createTableWrapper(name, db) {
  const getStore = (mode) => {
    const tx = db.transaction(name, mode);
    return tx.objectStore(name);
  };
  async function addItem(key, value) {
    const store = getStore("readwrite");
    const keyObj = { ...key };
    const finalValue = { ...keyObj, ...value };
    await requestAsPromise(store.put(finalValue));
    return finalValue;
  }
  function getItem(key) {
    const store = getStore("readonly");
    const keyValues = Object.values(key);
    const keyToUse = keyValues.length === 1 ? keyValues[0] : keyValues;
    return requestAsPromise(store.get(keyToUse));
  }
  function getRange(partialKey, indexName) {
    const store = getStore("readonly");
    const objectStoreOrIndex = indexName ? store.index(indexName) : store;
    const results = [];
    const upperBound = [...partialKey];
    upperBound.push([]);
    const range = IDBKeyRange.bound(partialKey, upperBound, false, true);
    return new Promise((resolve, reject) => {
      const request = objectStoreOrIndex.openCursor(range);
      request.onerror = () => reject(request.error);
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          results.push(cursor.value);
          cursor.continue();
        } else {
          resolve(results);
        }
      };
    });
  }
  async function deleteItem(key) {
    const store = getStore("readwrite");
    const keyValues = Object.values(key);
    const keyToUse = keyValues.length === 1 ? keyValues[0] : keyValues;
    await requestAsPromise(store.delete(keyToUse));
  }
  function deleteRange(partialKey) {
    const store = getStore("readwrite");
    let deletedCount = 0;
    const upperBound = [...partialKey];
    upperBound.push([]);
    const range = IDBKeyRange.bound(partialKey, upperBound, false, true);
    return new Promise((resolve, reject) => {
      const request = store.openCursor(range);
      request.onerror = () => reject(request.error);
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          cursor.delete();
          deletedCount++;
          cursor.continue();
        } else {
          resolve(deletedCount);
        }
      };
    });
  }
  async function deleteAll() {
    const store = getStore("readwrite");
    await requestAsPromise(store.clear());
  }
  function getAll() {
    const store = getStore("readonly");
    return requestAsPromise(store.getAll());
  }
  return {
    addItem,
    getItem,
    getRange,
    deleteItem,
    deleteRange,
    getAll,
    deleteAll
  };
}
function requestAsPromise(req) {
  return new Promise((resolve, reject) => {
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
export {
  createIndexDbConnection
};
//# sourceMappingURL=indexdb.js.map
