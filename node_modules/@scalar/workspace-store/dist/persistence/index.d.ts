import type { InMemoryWorkspace } from '../schemas/inmemory-workspace.js';
import type { WorkspaceMeta } from '../schemas/workspace.js';
type WorkspaceKey = {
    namespace?: string;
    slug: string;
};
type WorkspaceStoreShape = {
    teamUid?: string;
    name: string;
    workspace: InMemoryWorkspace;
};
/**
 * Creates the persistence layer for the workspace store using IndexedDB.
 * This sets up all the required tables for storing workspace chunk information,
 * such as workspace meta, documents, original documents, intermediate documents, overrides, etc.
 * Each logical group (meta, documents, etc) gets its own table keyed appropriately for efficient sub-document access.
 * Returns an object containing `meta`, `documents`, `originalDocuments`, `intermediateDocuments`, `overrides`,
 * `documentMeta`, `documentConfigs`, and `workspace` sections, each exposing a `setItem` method
 * for upsetting records, and in the case of `workspace`, also `getItem` and `deleteItem`.
 */
export declare const createWorkspaceStorePersistence: () => Promise<{
    close: () => void;
    meta: {
        /**
         * Set meta data for a workspace.
         */
        setItem: (workspaceId: string, data: WorkspaceMeta) => Promise<void>;
    };
    documents: {
        /**
         * Set (persist) a workspace document using workspaceId and documentName as composite key.
         */
        setItem: (workspaceId: string, documentName: string, data: InMemoryWorkspace["documents"][string]) => Promise<void>;
    };
    originalDocuments: {
        /**
         * Set an original (raw) document for a workspace/document pair.
         */
        setItem: (workspaceId: string, documentName: string, data: InMemoryWorkspace["originalDocuments"][string]) => Promise<void>;
    };
    intermediateDocuments: {
        /**
         * Set an intermediate (transformed) document for a workspace/document pair.
         */
        setItem: (workspaceId: string, documentName: string, data: InMemoryWorkspace["intermediateDocuments"][string]) => Promise<void>;
    };
    overrides: {
        /**
         * Set document overrides for a workspace/document pair.
         */
        setItem: (workspaceId: string, documentName: string, data: InMemoryWorkspace["overrides"][string]) => Promise<void>;
    };
    workspace: {
        /**
         * Retrieves a workspace by its ID.
         * Returns undefined if the workspace does not exist.
         * Gathers all workspace 'chunk' tables and assembles a full workspace shape.
         */
        getItem: ({ namespace, slug, }: Required<WorkspaceKey>) => Promise<(WorkspaceStoreShape & Required<WorkspaceKey>) | undefined>;
        /**
         * Retrieves all workspaces from the database.
         * Returns only the workspace ID and name for each workspace.
         * To get the full workspace data including documents and metadata, use getItem() with a specific ID.
         * Returns an empty array if no workspaces exist.
         */
        getAll: () => Promise<{
            slug: string;
            name: string;
            namespace: string;
            teamUid: string;
        }[]>;
        /**
         * Retrieves all workspaces for a given team UID.
         */
        getAllByTeamUid: (teamUid: string) => Promise<{
            slug: string;
            name: string;
            namespace: string;
            teamUid: string;
        }[]>;
        /**
         * Saves a workspace to the database.
         * All chunks (meta, documents, configs, etc.) are upsert in their respective tables.
         * If a workspace with the same ID already exists, it will be replaced.
         */
        setItem: ({ namespace, slug }: WorkspaceKey, value: WorkspaceStoreShape) => Promise<{
            slug: string;
            name: string;
            namespace: string;
            teamUid: string;
        }>;
        /**
         * Deletes an entire workspace and all associated chunk records from all tables by ID.
         */
        deleteItem: ({ namespace, slug }: Required<WorkspaceKey>) => Promise<void>;
        deleteDocument: (workspaceId: string, documentName: string) => Promise<void>;
        /**
         * Checks if a workspace with the given ID exists in the store.
         */
        has: ({ namespace, slug }: Required<WorkspaceKey>) => Promise<boolean>;
    };
    clear: () => Promise<void>;
}>;
export {};
//# sourceMappingURL=index.d.ts.map