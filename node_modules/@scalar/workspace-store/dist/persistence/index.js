import { Type } from "@scalar/typebox";
import { createIndexDbConnection } from "../persistence/indexdb.js";
const getWorkspaceId = (namespace, slug) => `${namespace}/${slug}`;
const createWorkspaceStorePersistence = async () => {
  const connection = await createIndexDbConnection({
    name: "scalar-workspace-store",
    version: 1,
    tables: {
      workspace: {
        schema: Type.Object({
          /** Visual name for a given workspace */
          name: Type.String(),
          /** When logged in all new workspaces (remote and local) are scoped to a team  */
          teamUid: Type.String({ default: "local" }),
          /** Namespace associated with a remote workspace */
          namespace: Type.String({ default: "local" }),
          /** Slug associated with a remote workspace */
          slug: Type.String({ default: "local" })
        }),
        keyPath: ["namespace", "slug"],
        indexes: {
          teamUid: ["teamUid"]
        }
      },
      meta: {
        schema: Type.Object({ workspaceId: Type.String(), data: Type.Any() }),
        keyPath: ["workspaceId"]
      },
      documents: {
        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),
        keyPath: ["workspaceId", "documentName"]
      },
      originalDocuments: {
        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),
        keyPath: ["workspaceId", "documentName"]
      },
      intermediateDocuments: {
        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),
        keyPath: ["workspaceId", "documentName"]
      },
      overrides: {
        schema: Type.Object({ workspaceId: Type.String(), documentName: Type.String(), data: Type.Any() }),
        keyPath: ["workspaceId", "documentName"]
      }
    }
  });
  const workspaceTable = connection.get("workspace");
  const metaTable = connection.get("meta");
  const documentsTable = connection.get("documents");
  const originalDocumentTable = connection.get("originalDocuments");
  const intermediateDocumentTable = connection.get("intermediateDocuments");
  const overridesTable = connection.get("overrides");
  return {
    close: () => {
      connection.closeDatabase();
    },
    meta: {
      /**
       * Set meta data for a workspace.
       */
      setItem: async (workspaceId, data) => {
        await metaTable.addItem({ workspaceId }, { data });
      }
    },
    documents: {
      /**
       * Set (persist) a workspace document using workspaceId and documentName as composite key.
       */
      setItem: async (workspaceId, documentName, data) => {
        await documentsTable.addItem({ workspaceId, documentName }, { data });
      }
    },
    originalDocuments: {
      /**
       * Set an original (raw) document for a workspace/document pair.
       */
      setItem: async (workspaceId, documentName, data) => {
        await originalDocumentTable.addItem({ workspaceId, documentName }, { data });
      }
    },
    intermediateDocuments: {
      /**
       * Set an intermediate (transformed) document for a workspace/document pair.
       */
      setItem: async (workspaceId, documentName, data) => {
        await intermediateDocumentTable.addItem({ workspaceId, documentName }, { data });
      }
    },
    overrides: {
      /**
       * Set document overrides for a workspace/document pair.
       */
      setItem: async (workspaceId, documentName, data) => {
        await overridesTable.addItem({ workspaceId, documentName }, { data });
      }
    },
    workspace: {
      /**
       * Retrieves a workspace by its ID.
       * Returns undefined if the workspace does not exist.
       * Gathers all workspace 'chunk' tables and assembles a full workspace shape.
       */
      getItem: async ({
        namespace,
        slug
      }) => {
        const workspace = await workspaceTable.getItem({ namespace, slug });
        if (!workspace) {
          return void 0;
        }
        const id = getWorkspaceId(namespace, slug);
        const workspaceDocuments = await documentsTable.getRange([id]);
        const workspaceOriginalDocuments = await originalDocumentTable.getRange([id]);
        const workspaceIntermediateDocuments = await intermediateDocumentTable.getRange([id]);
        const workspaceOverrides = await overridesTable.getRange([id]);
        const workspaceMeta = await metaTable.getItem({ workspaceId: id });
        return {
          name: workspace.name,
          teamUid: workspace.teamUid,
          namespace: workspace.namespace,
          slug: workspace.slug,
          workspace: {
            documents: Object.fromEntries(workspaceDocuments.map((item) => [item.documentName, item.data])),
            originalDocuments: Object.fromEntries(
              workspaceOriginalDocuments.map((item) => [item.documentName, item.data])
            ),
            intermediateDocuments: Object.fromEntries(
              workspaceIntermediateDocuments.map((item) => [item.documentName, item.data])
            ),
            overrides: Object.fromEntries(workspaceOverrides.map((item) => [item.documentName, item.data])),
            meta: workspaceMeta?.data
          }
        };
      },
      /**
       * Retrieves all workspaces from the database.
       * Returns only the workspace ID and name for each workspace.
       * To get the full workspace data including documents and metadata, use getItem() with a specific ID.
       * Returns an empty array if no workspaces exist.
       */
      getAll: async () => {
        return await workspaceTable.getAll();
      },
      /**
       * Retrieves all workspaces for a given team UID.
       */
      getAllByTeamUid: async (teamUid) => {
        return await workspaceTable.getRange([teamUid], "teamUid");
      },
      /**
       * Saves a workspace to the database.
       * All chunks (meta, documents, configs, etc.) are upsert in their respective tables.
       * If a workspace with the same ID already exists, it will be replaced.
       */
      setItem: async ({ namespace = "local", slug }, value) => {
        const workspace = await workspaceTable.addItem(
          { namespace, slug },
          {
            name: value.name,
            teamUid: value.teamUid ?? "local"
          }
        );
        const id = getWorkspaceId(namespace, slug);
        await metaTable.addItem({ workspaceId: id }, { data: value.workspace.meta });
        await Promise.all(
          Object.entries(value.workspace.documents ?? {}).map(([name, data]) => {
            return documentsTable.addItem({ workspaceId: id, documentName: name }, { data });
          })
        );
        await Promise.all(
          Object.entries(value.workspace.originalDocuments ?? {}).map(([name, data]) => {
            return originalDocumentTable.addItem({ workspaceId: id, documentName: name }, { data });
          })
        );
        await Promise.all(
          Object.entries(value.workspace.intermediateDocuments ?? {}).map(([name, data]) => {
            return intermediateDocumentTable.addItem({ workspaceId: id, documentName: name }, { data });
          })
        );
        await Promise.all(
          Object.entries(value.workspace.overrides ?? {}).map(([name, data]) => {
            return overridesTable.addItem({ workspaceId: id, documentName: name }, { data });
          })
        );
        return workspace;
      },
      /**
       * Deletes an entire workspace and all associated chunk records from all tables by ID.
       */
      deleteItem: async ({ namespace, slug }) => {
        const id = getWorkspaceId(namespace, slug);
        await workspaceTable.deleteItem({ namespace, slug });
        await Promise.all([
          // By id
          metaTable.deleteItem({ workspaceId: id }),
          // By range (composite-key tables)
          documentsTable.deleteRange([id]),
          originalDocumentTable.deleteRange([id]),
          intermediateDocumentTable.deleteRange([id]),
          overridesTable.deleteRange([id])
        ]);
      },
      deleteDocument: async (workspaceId, documentName) => {
        await Promise.all([
          documentsTable.deleteItem({ workspaceId, documentName }),
          intermediateDocumentTable.deleteItem({ workspaceId, documentName }),
          originalDocumentTable.deleteItem({ workspaceId, documentName }),
          overridesTable.deleteItem({ workspaceId, documentName })
        ]);
      },
      /**
       * Checks if a workspace with the given ID exists in the store.
       */
      has: async ({ namespace, slug }) => {
        return await workspaceTable.getItem({ namespace, slug }) !== void 0;
      }
    },
    clear: async () => {
      await workspaceTable.deleteAll();
    }
  };
};
export {
  createWorkspaceStorePersistence
};
//# sourceMappingURL=index.js.map
