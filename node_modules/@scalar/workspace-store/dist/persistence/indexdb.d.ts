import type { Static, TObject } from '@scalar/typebox';
type TableEntry<S extends TObject, K extends readonly (keyof Static<S>)[]> = {
    schema: S;
    keyPath: K;
    indexes?: Record<string, readonly (keyof Static<S>)[]>;
};
/**
 * Initializes and manages an IndexedDB database connection for table-based persistence.
 *
 * @param name - The database name. Defaults to 'scalar-workspace-store'.
 * @param tables - Table definitions: the tables to create and their key schemas.
 * @param version - The database version. Bump this to trigger upgrades (default: 1).
 * @param migrations - Optional migration steps to run for version upgrades.
 * @returns An object with the following methods:
 *   - `get(tableName)` — Get a wrapper to interact with the object store for the given table name.
 *   - `closeDatabase()` — Closes the database connection.
 *
 * Example usage:
 * ```ts
 * import { Type } from '@scalar/typebox'
 * import { createIndexDbConnection } from './indexdb.js'
 *
 * // Define a schema for a user
 * const UserSchema = Type.Object({
 *   id: Type.String(),
 *   name: Type.String(),
 *   age: Type.Number(),
 * })
 *
 * // Define tables in the database
 * const dbConfig = {
 *   users: {
 *     schema: UserSchema,
 *     index: ['id'] as const,
 *   },
 * }
 *
 * // Open the database connection and get table API
 * const { get, closeDatabase } = await createIndexDbConnection({
 *   name: 'my-app-db',
 *   tables: dbConfig,
 *   version: 1,
 * })
 *
 * // Get a strongly-typed users table API
 * const usersTable = get('users')
 *
 * // Add a user
 * await usersTable.addItem({ id: 'user-1' }, { name: 'Alice', age: 25 })
 *
 * // Retrieve a user by id
 * const user = await usersTable.getItem({ id: 'user-1' })
 *
 * // Don't forget to close the database when done!
 * closeDatabase()
 * ```
 */
export declare const createIndexDbConnection: <T extends Record<string, TableEntry<any, readonly (keyof any)[]>>>({ name, tables, version, migrations, }: {
    name: string;
    tables: T;
    version: number;
    migrations?: {
        version: number;
        exec: (db: IDBDatabase, event: IDBVersionChangeEvent) => {};
    }[];
}) => Promise<{
    get: <Name extends keyof T>(name: Name) => {
        addItem: (key: Record<T[Name]["keyPath"][number], IDBValidKey>, value: Omit<(T[Name]["schema"] & {
            params: [];
        })["static"], T[Name]["keyPath"][number]>) => Promise<(T[Name]["schema"] & {
            params: [];
        })["static"]>;
        getItem: (key: Record<T[Name]["keyPath"][number], IDBValidKey>) => Promise<(T[Name]["schema"] & {
            params: [];
        })["static"] | undefined>;
        getRange: (partialKey: IDBValidKey[], indexName?: string) => Promise<(T[Name]["schema"] & {
            params: [];
        })["static"][]>;
        deleteItem: (key: Record<T[Name]["keyPath"][number], IDBValidKey>) => Promise<void>;
        deleteRange: (partialKey: IDBValidKey[]) => Promise<number>;
        getAll: () => Promise<(T[Name]["schema"] & {
            params: [];
        })["static"][]>;
        deleteAll: () => Promise<void>;
    };
    closeDatabase: () => void;
}>;
export {};
//# sourceMappingURL=indexdb.d.ts.map