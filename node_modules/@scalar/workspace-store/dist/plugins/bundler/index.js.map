{
  "version": 3,
  "sources": ["../../../src/plugins/bundler/index.ts"],
  "sourcesContent": ["/**\n * This file contains a collection of plugins used for the bundler.\n * Plugins defined here can extend or modify the behavior of the bundling process,\n * such as adding lifecycle hooks or custom processing logic.\n */\n\nimport type { LifecyclePlugin } from '@scalar/json-magic/bundle'\n\nimport { isLocalRef } from '@/helpers/general'\nimport { getResolvedRef } from '@/plugins/bundler/helpers'\n\n/**\n * A lifecycle plugin that adds a `$status` property to nodes during resolution.\n * - Sets `$status` to 'loading' when resolution starts.\n * - Sets `$status` to 'error' if resolution fails.\n * - Removes `$status` when resolution succeeds.\n */\nexport const loadingStatus = (): LifecyclePlugin => {\n  return {\n    type: 'lifecycle',\n    onResolveStart: (node) => {\n      node['$status'] = 'loading'\n    },\n    onResolveError: (node) => {\n      node['$status'] = 'error'\n    },\n    onResolveSuccess: (node) => {\n      delete node['$status']\n    },\n  }\n}\n\n/**\n * Lifecycle plugin to resolve and embed external content referenced by an 'externalValue' property in a node.\n *\n * When a node contains an 'externalValue' property (as a string), this plugin will:\n *   - Fetch the external resource (such as a URL or file) using the fetchUrls plugin.\n *   - If the fetch is successful, assign the fetched data to the node's 'value' property.\n *\n * This is useful for inlining external content (like examples or schemas) into the OpenAPI document during bundling.\n *\n * @param node - The node being processed, which may contain an 'externalValue' property.\n */\nexport const externalValueResolver = (): LifecyclePlugin => {\n  return {\n    type: 'lifecycle',\n    onAfterNodeProcess: async (node, context) => {\n      const externalValue = node['externalValue']\n      const cache = context.resolutionCache\n\n      // Only process if 'externalValue' is a string\n      if (typeof externalValue !== 'string') {\n        return\n      }\n\n      const loader = context.loaders.find((it) => it.validate(externalValue))\n\n      // We can not process the external value\n      if (!loader) {\n        return\n      }\n\n      if (!cache.has(externalValue)) {\n        cache.set(externalValue, loader.exec(externalValue))\n      }\n\n      const result = await cache.get(externalValue)\n\n      // If fetch is successful, assign the data to the node's 'value' property\n      if (result?.ok) {\n        node['value'] = result.data\n      }\n    },\n  }\n}\n\n/**\n * Lifecycle plugin to resolve $ref on any object, including non-standard locations like the info object.\n *\n * This plugin will:\n *   - Detect if a node contains a $ref property (as a string).\n *   - If the node is under the 'info' path, attempt to resolve the reference using fetchUrls.\n *   - Replace the node's properties with the resolved data if successful.\n *\n * Note: This currently only supports refs on the 'info' object and does not handle primitive types.\n */\nexport const refsEverywhere = (): LifecyclePlugin => {\n  return {\n    type: 'lifecycle',\n    onBeforeNodeProcess: async (node, context) => {\n      const { path, resolutionCache, parentNode } = context\n      const ref = node['$ref']\n\n      // Only process nodes that have a $ref property as a string\n      if (typeof ref !== 'string') {\n        return\n      }\n\n      // Can not resolve top level refs\n      if (!parentNode || !path.length) {\n        return\n      }\n\n      const loader = context.loaders.find((it) => it.validate(ref))\n\n      // Can not load the external ref\n      if (!loader) {\n        return\n      }\n\n      // Support resolving $ref on the info object\n      if (path[0] === 'info') {\n        // Use the cache to avoid duplicate fetches\n        if (!resolutionCache.has(ref)) {\n          resolutionCache.set(ref, loader.exec(ref))\n        }\n\n        const result = await resolutionCache.get(ref)\n\n        if (result?.ok) {\n          // Replace the ref with the resolved data\n          parentNode[path.at(-1)!] = result.data\n        }\n      }\n    },\n  }\n}\n\n/**\n * Lifecycle plugin to restore original $ref values after processing.\n *\n * This plugin is intended to be used as a \"lifecycle\" plugin in the bundling process.\n * It operates in the `onAfterNodeProcess` hook, and its main purpose is to restore\n * the original $ref values for external references that may have been replaced or\n * rewritten during the bundling process.\n *\n * How it works:\n * - For each node processed, if the node contains a $ref property (as a string),\n *   and the root document contains an \"x-ext-urls\" mapping object,\n *   the plugin will attempt to restore the original $ref value.\n * - The \"x-ext-urls\" object is expected to be a mapping from the rewritten $ref\n *   (e.g., a hashed or compressed reference) back to the original external URL or path.\n * - If a mapping exists for the current $ref, the plugin replaces the $ref value\n *   with the original value from the mapping. If no mapping exists (e.g., for local refs),\n *   the $ref value is left unchanged.\n *\n * This is useful for scenarios where you want to present or export the bundled document\n * with the original external $ref values, rather than the internal or rewritten ones.\n *\n * @returns {LifecyclePlugin} The plugin object for use in the bundler.\n */\nexport const restoreOriginalRefs = (): LifecyclePlugin => {\n  return {\n    type: 'lifecycle',\n    onBeforeNodeProcess: (node, context) => {\n      const ref = node['$ref']\n      const root = context.rootNode\n      const extUrls = root['x-ext-urls']\n\n      // Only process if $ref is a string and x-ext-urls is a valid object\n      if (typeof ref !== 'string' || typeof extUrls !== 'object' || extUrls === null || !isLocalRef(ref)) {\n        return\n      }\n\n      // Working with local refs\n\n      const segments = ref.split('/')\n      const key = segments.at(-1) ?? ''\n\n      // Replace the $ref with the original version from the mapping,\n      // or keep the current version if there is no mapping (e.g., for local refs)\n      node['$ref'] = (extUrls as Record<string, string>)[key] ?? ref\n    },\n  }\n}\n\n/**\n * Lifecycle plugin to normalize the `scheme` property in securitySchemes to lowercase.\n *\n * Our typebox schemas require the `scheme` property to be a lowercase string.\n * This plugin ensures that any `scheme` field under `components.securitySchemes` is normalized to lowercase, fixing\n * potential user input errors such as \"Bearer\" or \"BASIC\".\n *\n * Example:\n * ```yaml\n * Before normalization:\n *   components:\n *     securitySchemes:\n *       bearerAuth:\n *         type: http\n *         scheme: Bearer\n * ```\n * After normalization:\n * ```yaml\n *   components:\n *     securitySchemes:\n *       bearerAuth:\n *         type: http\n *         scheme: bearer\n * ```\n */\nexport const normalizeAuthSchemes = (): LifecyclePlugin => {\n  return {\n    type: 'lifecycle',\n    onAfterNodeProcess: (node, context) => {\n      const { path } = context\n\n      // Check if we're at components.securitySchemes.{schemeName}\n      if (path.length === 3 && path[0] === 'components' && path[1] === 'securitySchemes') {\n        const targetNode = getResolvedRef(node, context)\n\n        // If the scheme exists and is a string, normalize to lowercase if not already\n        if (\n          typeof targetNode === 'object' &&\n          targetNode !== null &&\n          'scheme' in targetNode &&\n          typeof targetNode['scheme'] === 'string' &&\n          targetNode['scheme'].toLowerCase() !== targetNode['scheme']\n        ) {\n          targetNode['scheme'] = targetNode['scheme'].toLowerCase()\n        }\n      }\n    },\n  }\n}\n"],
  "mappings": "AAQA,SAAS,kBAAkB;AAC3B,SAAS,sBAAsB;AAQxB,MAAM,gBAAgB,MAAuB;AAClD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,gBAAgB,CAAC,SAAS;AACxB,WAAK,SAAS,IAAI;AAAA,IACpB;AAAA,IACA,gBAAgB,CAAC,SAAS;AACxB,WAAK,SAAS,IAAI;AAAA,IACpB;AAAA,IACA,kBAAkB,CAAC,SAAS;AAC1B,aAAO,KAAK,SAAS;AAAA,IACvB;AAAA,EACF;AACF;AAaO,MAAM,wBAAwB,MAAuB;AAC1D,SAAO;AAAA,IACL,MAAM;AAAA,IACN,oBAAoB,OAAO,MAAM,YAAY;AAC3C,YAAM,gBAAgB,KAAK,eAAe;AAC1C,YAAM,QAAQ,QAAQ;AAGtB,UAAI,OAAO,kBAAkB,UAAU;AACrC;AAAA,MACF;AAEA,YAAM,SAAS,QAAQ,QAAQ,KAAK,CAAC,OAAO,GAAG,SAAS,aAAa,CAAC;AAGtE,UAAI,CAAC,QAAQ;AACX;AAAA,MACF;AAEA,UAAI,CAAC,MAAM,IAAI,aAAa,GAAG;AAC7B,cAAM,IAAI,eAAe,OAAO,KAAK,aAAa,CAAC;AAAA,MACrD;AAEA,YAAM,SAAS,MAAM,MAAM,IAAI,aAAa;AAG5C,UAAI,QAAQ,IAAI;AACd,aAAK,OAAO,IAAI,OAAO;AAAA,MACzB;AAAA,IACF;AAAA,EACF;AACF;AAYO,MAAM,iBAAiB,MAAuB;AACnD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,qBAAqB,OAAO,MAAM,YAAY;AAC5C,YAAM,EAAE,MAAM,iBAAiB,WAAW,IAAI;AAC9C,YAAM,MAAM,KAAK,MAAM;AAGvB,UAAI,OAAO,QAAQ,UAAU;AAC3B;AAAA,MACF;AAGA,UAAI,CAAC,cAAc,CAAC,KAAK,QAAQ;AAC/B;AAAA,MACF;AAEA,YAAM,SAAS,QAAQ,QAAQ,KAAK,CAAC,OAAO,GAAG,SAAS,GAAG,CAAC;AAG5D,UAAI,CAAC,QAAQ;AACX;AAAA,MACF;AAGA,UAAI,KAAK,CAAC,MAAM,QAAQ;AAEtB,YAAI,CAAC,gBAAgB,IAAI,GAAG,GAAG;AAC7B,0BAAgB,IAAI,KAAK,OAAO,KAAK,GAAG,CAAC;AAAA,QAC3C;AAEA,cAAM,SAAS,MAAM,gBAAgB,IAAI,GAAG;AAE5C,YAAI,QAAQ,IAAI;AAEd,qBAAW,KAAK,GAAG,EAAE,CAAE,IAAI,OAAO;AAAA,QACpC;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAyBO,MAAM,sBAAsB,MAAuB;AACxD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,qBAAqB,CAAC,MAAM,YAAY;AACtC,YAAM,MAAM,KAAK,MAAM;AACvB,YAAM,OAAO,QAAQ;AACrB,YAAM,UAAU,KAAK,YAAY;AAGjC,UAAI,OAAO,QAAQ,YAAY,OAAO,YAAY,YAAY,YAAY,QAAQ,CAAC,WAAW,GAAG,GAAG;AAClG;AAAA,MACF;AAIA,YAAM,WAAW,IAAI,MAAM,GAAG;AAC9B,YAAM,MAAM,SAAS,GAAG,EAAE,KAAK;AAI/B,WAAK,MAAM,IAAK,QAAmC,GAAG,KAAK;AAAA,IAC7D;AAAA,EACF;AACF;AA2BO,MAAM,uBAAuB,MAAuB;AACzD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,oBAAoB,CAAC,MAAM,YAAY;AACrC,YAAM,EAAE,KAAK,IAAI;AAGjB,UAAI,KAAK,WAAW,KAAK,KAAK,CAAC,MAAM,gBAAgB,KAAK,CAAC,MAAM,mBAAmB;AAClF,cAAM,aAAa,eAAe,MAAM,OAAO;AAG/C,YACE,OAAO,eAAe,YACtB,eAAe,QACf,YAAY,cACZ,OAAO,WAAW,QAAQ,MAAM,YAChC,WAAW,QAAQ,EAAE,YAAY,MAAM,WAAW,QAAQ,GAC1D;AACA,qBAAW,QAAQ,IAAI,WAAW,QAAQ,EAAE,YAAY;AAAA,QAC1D;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}
