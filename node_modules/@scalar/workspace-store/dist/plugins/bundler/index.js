import { isLocalRef } from "../../helpers/general.js";
import { getResolvedRef } from "../../plugins/bundler/helpers.js";
const loadingStatus = () => {
  return {
    type: "lifecycle",
    onResolveStart: (node) => {
      node["$status"] = "loading";
    },
    onResolveError: (node) => {
      node["$status"] = "error";
    },
    onResolveSuccess: (node) => {
      delete node["$status"];
    }
  };
};
const externalValueResolver = () => {
  return {
    type: "lifecycle",
    onAfterNodeProcess: async (node, context) => {
      const externalValue = node["externalValue"];
      const cache = context.resolutionCache;
      if (typeof externalValue !== "string") {
        return;
      }
      const loader = context.loaders.find((it) => it.validate(externalValue));
      if (!loader) {
        return;
      }
      if (!cache.has(externalValue)) {
        cache.set(externalValue, loader.exec(externalValue));
      }
      const result = await cache.get(externalValue);
      if (result?.ok) {
        node["value"] = result.data;
      }
    }
  };
};
const refsEverywhere = () => {
  return {
    type: "lifecycle",
    onBeforeNodeProcess: async (node, context) => {
      const { path, resolutionCache, parentNode } = context;
      const ref = node["$ref"];
      if (typeof ref !== "string") {
        return;
      }
      if (!parentNode || !path.length) {
        return;
      }
      const loader = context.loaders.find((it) => it.validate(ref));
      if (!loader) {
        return;
      }
      if (path[0] === "info") {
        if (!resolutionCache.has(ref)) {
          resolutionCache.set(ref, loader.exec(ref));
        }
        const result = await resolutionCache.get(ref);
        if (result?.ok) {
          parentNode[path.at(-1)] = result.data;
        }
      }
    }
  };
};
const restoreOriginalRefs = () => {
  return {
    type: "lifecycle",
    onBeforeNodeProcess: (node, context) => {
      const ref = node["$ref"];
      const root = context.rootNode;
      const extUrls = root["x-ext-urls"];
      if (typeof ref !== "string" || typeof extUrls !== "object" || extUrls === null || !isLocalRef(ref)) {
        return;
      }
      const segments = ref.split("/");
      const key = segments.at(-1) ?? "";
      node["$ref"] = extUrls[key] ?? ref;
    }
  };
};
const normalizeAuthSchemes = () => {
  return {
    type: "lifecycle",
    onAfterNodeProcess: (node, context) => {
      const { path } = context;
      if (path.length === 3 && path[0] === "components" && path[1] === "securitySchemes") {
        const targetNode = getResolvedRef(node, context);
        if (typeof targetNode === "object" && targetNode !== null && "scheme" in targetNode && typeof targetNode["scheme"] === "string" && targetNode["scheme"].toLowerCase() !== targetNode["scheme"]) {
          targetNode["scheme"] = targetNode["scheme"].toLowerCase();
        }
      }
    }
  };
};
export {
  externalValueResolver,
  loadingStatus,
  normalizeAuthSchemes,
  refsEverywhere,
  restoreOriginalRefs
};
//# sourceMappingURL=index.js.map
