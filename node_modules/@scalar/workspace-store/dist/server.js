import fs from "node:fs/promises";
import { cwd } from "node:process";
import { fetchUrls, readFiles } from "@scalar/json-magic/bundle/plugins/node";
import { escapeJsonPointer } from "@scalar/json-magic/helpers/escape-json-pointer";
import { upgrade } from "@scalar/openapi-upgrader";
import { keyOf } from "./helpers/general.js";
import { createNavigation } from "./navigation/index.js";
import { extensions } from "./schemas/extensions.js";
import { coerceValue } from "./schemas/typebox-coerce.js";
import {
  OpenAPIDocumentSchema
} from "./schemas/v3.1/strict/openapi-document.js";
import { getValueByPath, parseJsonPointer } from "./helpers/json-path-utils.js";
const DEFAULT_ASSETS_FOLDER = "assets";
const WORKSPACE_FILE_NAME = "scalar-workspace.json";
const httpMethods = /* @__PURE__ */ new Set(["get", "put", "post", "delete", "options", "head", "patch", "trace"]);
function filterHttpMethodsOnly(paths) {
  const result = {};
  for (const [path, methods] of Object.entries(paths)) {
    if (!methods) {
      continue;
    }
    const filteredMethods = {};
    for (const [method, operation] of Object.entries(methods)) {
      if (httpMethods.has(method.toLowerCase())) {
        filteredMethods[method] = operation;
      }
    }
    if (Object.keys(filteredMethods).length > 0) {
      result[path] = filteredMethods;
    }
  }
  return result;
}
function escapePaths(paths) {
  const result = {};
  Object.keys(paths).forEach((path) => {
    if (paths[path]) {
      result[escapeJsonPointer(path)] = paths[path];
    }
  });
  return result;
}
function externalizeComponentReferences(document, meta) {
  const result = {};
  if (!document.components) {
    return result;
  }
  Object.entries(document.components).forEach(([type, component]) => {
    if (!component || typeof component !== "object") {
      return;
    }
    result[type] = {};
    Object.keys(component).forEach((name) => {
      const ref = meta.mode === "ssr" ? `${meta.baseUrl}/${meta.name}/components/${type}/${name}#` : `./chunks/${meta.name}/components/${type}/${name}.json#`;
      result[type][name] = { "$ref": ref, $global: true };
    });
  });
  return result;
}
function externalizePathReferences(document, meta) {
  const result = {};
  if (!document.paths) {
    return result;
  }
  Object.entries(document.paths).forEach(([path, pathItem]) => {
    if (!pathItem || typeof pathItem !== "object") {
      return;
    }
    const pathItemRecord = pathItem;
    result[path] = {};
    const escapedPath = escapeJsonPointer(path);
    keyOf(pathItemRecord).forEach((type) => {
      if (httpMethods.has(type)) {
        const ref = meta.mode === "ssr" ? `${meta.baseUrl}/${meta.name}/operations/${escapedPath}/${type}#` : `./chunks/${meta.name}/operations/${escapedPath}/${type}.json#`;
        result[path][type] = { "$ref": ref, $global: true };
      } else {
        result[path][type] = pathItemRecord[type];
      }
    });
  });
  return result;
}
function loadDocument(workspaceDocument) {
  if ("url" in workspaceDocument) {
    return fetchUrls().exec(workspaceDocument.url);
  }
  if ("path" in workspaceDocument) {
    return readFiles().exec(workspaceDocument.path);
  }
  return Promise.resolve({
    ok: true,
    data: workspaceDocument.document,
    raw: JSON.stringify(workspaceDocument.document)
  });
}
async function createServerWorkspaceStore(workspaceProps) {
  const workspace = {
    ...workspaceProps.meta,
    documents: {}
  };
  const assets = {};
  const addDocumentSync = (document, meta) => {
    const { name, ...documentMeta } = meta;
    const documentV3 = coerceValue(OpenAPIDocumentSchema, upgrade(document, "3.1"));
    assets[meta.name] = {
      components: documentV3.components,
      operations: documentV3.paths && escapePaths(filterHttpMethodsOnly(documentV3.paths))
    };
    const options = workspaceProps.mode === "ssr" ? { mode: workspaceProps.mode, name, baseUrl: workspaceProps.baseUrl } : { mode: workspaceProps.mode, name, directory: workspaceProps.directory ?? DEFAULT_ASSETS_FOLDER };
    const components = externalizeComponentReferences(documentV3, options);
    const paths = externalizePathReferences(documentV3, options);
    const navigation = createNavigation(name, documentV3, workspaceProps.navigationOptions);
    workspace.documents[meta.name] = {
      ...documentMeta,
      ...documentV3,
      components,
      paths,
      [extensions.document.navigation]: navigation
    };
  };
  const addDocument = async (input) => {
    const document = await loadDocument(input);
    if (!document.ok) {
      console.warn(`Failed to load document "${input.name}`);
      return;
    }
    addDocumentSync(document.data, { name: input.name, ...input.meta });
  };
  await Promise.all(workspaceProps.documents.map((document) => addDocument(document)));
  return {
    /**
     * Generates workspace chunks by writing components and operations to the filesystem.
     *
     * This method is only available in static mode. It creates a directory structure containing:
     * - A workspace file with metadata and document references
     * - Component chunks split by type (schemas, parameters, etc)
     * - Operation chunks split by path and HTTP method
     *
     * The generated workspace references will be relative file paths pointing to these chunks.
     *
     * @throws {Error} If called when mode is not 'static'
     */
    generateWorkspaceChunks: async () => {
      if (workspaceProps.mode !== "static") {
        throw "Mode has to be set to `static` to generate filesystem workspace chunks";
      }
      const basePath = `${cwd()}/${workspaceProps.directory ?? DEFAULT_ASSETS_FOLDER}`;
      await fs.mkdir(basePath, { recursive: true });
      await fs.writeFile(`${basePath}/${WORKSPACE_FILE_NAME}`, JSON.stringify(workspace));
      for (const [name, { components, operations }] of Object.entries(assets)) {
        if (components) {
          for (const [type, component] of Object.entries(components)) {
            const componentPath = `${basePath}/chunks/${name}/components/${type}`;
            await fs.mkdir(componentPath, { recursive: true });
            for (const [key, value] of Object.entries(component)) {
              await fs.writeFile(`${componentPath}/${key}.json`, JSON.stringify(value));
            }
          }
        }
        if (operations) {
          for (const [path, methods] of Object.entries(operations)) {
            const operationPath = `${basePath}/chunks/${name}/operations/${path}`;
            await fs.mkdir(operationPath, { recursive: true });
            for (const [method, operation] of Object.entries(methods)) {
              await fs.writeFile(`${operationPath}/${method}.json`, JSON.stringify(operation));
            }
          }
        }
      }
    },
    /**
     * Returns the workspace document containing metadata and all sparse documents.
     *
     * The workspace document includes:
     * - Global workspace metadata (theme, active document, etc)
     * - Document metadata and sparse document
     * - In SSR mode: References point to in-memory chunks
     * - In static mode: References point to filesystem chunks
     *
     * @returns The complete workspace document
     */
    getWorkspace: () => {
      return workspace;
    },
    /**
     * Retrieves a chunk of data from the workspace using a JSON Pointer
     *
     * A JSON Pointer is a string that references a specific location in a JSON document.
     * Only components and operations chunks can be retrieved.
     *
     * @example
     * ```ts
     * // Get a component
     * get('#/document-name/components/schemas/User')
     *
     * // Get an operation
     * get('#/document-name/operations/pets/get')
     * ```
     *
     * @param pointer - The JSON Pointer string to locate the chunk
     * @returns The chunk data if found, undefined otherwise
     */
    get: (pointer) => {
      return getValueByPath(assets, parseJsonPointer(pointer));
    },
    /**
     * Adds a new document to the workspace asynchronously.
     *
     * This function:
     * 1. Loads the document using the provided input
     * 2. Checks if the document loaded successfully
     * 3. If successful, adds the document to the workspace using addDocumentSync
     *
     * @param input - The document input containing the document source and metadata
     */
    addDocument
  };
}
export {
  WORKSPACE_FILE_NAME,
  createServerWorkspaceStore,
  escapePaths,
  externalizeComponentReferences,
  externalizePathReferences,
  filterHttpMethodsOnly
};
//# sourceMappingURL=server.js.map
