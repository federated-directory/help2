import { sortByOrder } from "@scalar/object-utils/arrays";
import { unpackProxyObject } from "../../helpers/unpack-proxy.js";
import { getXKeysFromObject } from "../../navigation/helpers/get-x-keys.js";
import { getTag } from "./get-tag.js";
const createTagEntry = ({
  tag,
  generateId,
  children,
  isGroup = false,
  parentId
}) => {
  const id = generateId({
    type: "tag",
    tag,
    parentId
  });
  const title = tag["x-displayName"] ?? tag.name ?? "Untitled Tag";
  tag["x-scalar-order"] = children.map((child) => child.id);
  const entry = {
    id,
    title,
    name: tag.name || title,
    description: tag.description,
    children,
    isGroup,
    isWebhooks: false,
    type: "tag",
    xKeys: getXKeysFromObject(unpackProxyObject(tag))
  };
  return entry;
};
const getSortedTagEntries = ({
  _keys,
  tagsMap,
  options: { tagsSorter, operationsSorter, generateId },
  documentId,
  sortOrder
}) => {
  const entries = _keys.flatMap((key) => {
    const { tag, entries: entries2 } = getTag({ tagsMap, name: key, documentId, generateId });
    if (tag["x-internal"] || tag["x-scalar-ignore"]) {
      return [];
    }
    const sortOrder2 = tag["x-scalar-order"];
    if (sortOrder2 === void 0) {
      if (operationsSorter === "alpha") {
        entries2.sort((a, b) => a.type === "operation" && b.type === "operation" ? a.title.localeCompare(b.title) : 0);
      } else if (operationsSorter === "method") {
        entries2.sort(
          (a, b) => a.type === "operation" && b.type === "operation" ? a.method.localeCompare(b.method) : 0
        );
      } else if (typeof operationsSorter === "function") {
        entries2.sort((a, b) => {
          if (!(a.type === "operation" || a.type === "webhook") || !(b.type === "operation" || b.type === "webhook")) {
            return 0;
          }
          const pathA = a.type === "operation" ? a.path : a.name;
          const pathB = b.type === "operation" ? b.path : b.name;
          return operationsSorter(
            { method: a.method, path: pathA, ref: a.ref, httpVerb: a.method },
            { method: b.method, path: pathB, ref: b.ref, httpVerb: b.method }
          );
        });
      }
    }
    return createTagEntry({
      tag,
      generateId,
      children: sortOrder2 ? sortByOrder(entries2, sortOrder2, "id") : entries2,
      parentId: documentId,
      isGroup: false
    });
  });
  if (sortOrder) {
    return sortByOrder(entries, sortOrder, "id");
  }
  if (tagsSorter === "alpha") {
    entries.sort((a, b) => {
      const nameA = getTag({
        tagsMap,
        name: a.title,
        documentId,
        generateId
      }).tag["x-displayName"] || a.title || "Untitled Tag";
      const nameB = getTag({ tagsMap, name: b.title, documentId, generateId }).tag["x-displayName"] || b.title || "Untitled Tag";
      return nameA.localeCompare(nameB);
    });
  } else if (typeof tagsSorter === "function") {
    entries.sort(
      (a, b) => tagsSorter(
        getTag({ tagsMap, name: a.name, documentId, generateId }).tag,
        getTag({ tagsMap, name: b.name, documentId, generateId }).tag
      )
    );
  }
  return entries;
};
const traverseTags = ({
  document,
  tagsMap,
  documentId,
  options: { generateId, tagsSorter, operationsSorter }
}) => {
  if (document["x-tagGroups"]) {
    const tagGroups = document["x-tagGroups"];
    return tagGroups.flatMap((tagGroup) => {
      const entries = getSortedTagEntries({
        _keys: tagGroup.tags,
        tagsMap,
        options: { tagsSorter, operationsSorter, generateId },
        documentId,
        sortOrder: tagGroup["x-scalar-order"]
      });
      tagGroup["x-scalar-order"] = entries.map((entry) => entry.id);
      return entries.length ? createTagEntry({
        tag: tagGroup,
        generateId,
        children: entries,
        parentId: documentId,
        isGroup: true
      }) : [];
    });
  }
  const keys = Array.from(tagsMap.keys());
  const tags = getSortedTagEntries({
    _keys: keys,
    tagsMap,
    options: { generateId, tagsSorter, operationsSorter },
    documentId,
    sortOrder: document["x-scalar-order"]
  });
  return tags;
};
export {
  traverseTags
};
//# sourceMappingURL=traverse-tags.js.map
