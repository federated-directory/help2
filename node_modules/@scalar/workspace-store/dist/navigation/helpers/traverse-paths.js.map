{
  "version": 3,
  "sources": ["../../../src/navigation/helpers/traverse-paths.ts"],
  "sourcesContent": ["import type { HttpMethod } from '@scalar/helpers/http/http-methods'\nimport { isHttpMethod } from '@scalar/helpers/http/is-http-method'\nimport { objectKeys } from '@scalar/helpers/object/object-keys'\nimport { escapeJsonPointer } from '@scalar/json-magic/helpers/escape-json-pointer'\n\nimport { getResolvedRef } from '@/helpers/get-resolved-ref'\nimport { traverseOperationExamples } from '@/navigation/helpers/traverse-examples'\nimport type { TagsMap, TraverseSpecOptions } from '@/navigation/types'\nimport { XScalarStabilityValues } from '@/schemas/extensions/operation'\nimport type { ParentTag, TraversedExample, TraversedOperation } from '@/schemas/navigation'\nimport type { OpenApiDocument, OperationObject } from '@/schemas/v3.1/strict/openapi-document'\n\nimport { getTag } from './get-tag'\n\nexport const isDeprecatedOperation = (operation: OperationObject) => {\n  return operation.deprecated || operation['x-scalar-stability'] === XScalarStabilityValues.Deprecated\n}\n\n/**\n * Creates a traversed operation entry from an OpenAPI operation object.\n *\n * @param ref - JSON pointer reference to the operation in the OpenAPI document\n * @param operation - The OpenAPI operation object\n * @param method - HTTP method of the operation\n * @param path - API path of the operation, defaults to 'Unknown'\n * @param tag - Tag object associated with the operation\n * @param entitiesMap - Map to store operation IDs and titles for mobile header navigation\n * @param getOperationId - Function to generate unique IDs for operations\n * @returns A traversed operation entry with ID, title, path, method and reference\n */\nconst createOperationEntry = ({\n  ref,\n  operation,\n  method,\n  path,\n  generateId,\n  parentId,\n  parentTag,\n}: {\n  ref: string\n  operation: OperationObject\n  method: HttpMethod\n  path: string\n  parentTag?: ParentTag\n  generateId: TraverseSpecOptions['generateId']\n  parentId: string\n}): TraversedOperation => {\n  const id = generateId({\n    type: 'operation',\n    operation,\n    parentTag,\n    method: method,\n    path: path,\n    parentId: parentId,\n  })\n  const title = operation.summary?.trim() ? operation.summary : path\n\n  const isDeprecated = isDeprecatedOperation(operation)\n\n  const examples: TraversedExample[] = traverseOperationExamples(operation).map((example) => ({\n    type: 'example',\n    id: generateId({\n      type: 'example',\n      parentId: id,\n      name: example,\n    }),\n    title: example,\n    name: example,\n  }))\n\n  const entry = {\n    id,\n    title,\n    path,\n    method,\n    ref,\n    type: 'operation',\n    isDeprecated,\n    children: examples.length ? examples : undefined,\n  } satisfies TraversedOperation\n\n  return entry\n}\n\n/**\n * Traverses the paths in an OpenAPI document to build a map of operations organized by tags.\n *\n * This function processes each path and its operations to:\n * - Filter out internal operations (marked with x-internal) and operations to ignore (marked with x-scalar-ignore)\n * - Group operations by their tags\n * - Collect operations without tags to be added at the document level\n * - Generate unique references and IDs for each operation\n *\n * TODO: filter out internal and scalar-ignore tags\n *\n * @param content - The OpenAPI document to traverse\n * @param tagsDict - Dictionary mapping tag names to their OpenAPI tag objects\n * @param entitiesMap - Map to store operation IDs and titles for mobile header navigation\n * @param getOperationId - Function to generate unique IDs for operations\n * @returns Object containing the tagsMap and an array of untagged operations\n */\nexport const traversePaths = ({\n  document,\n  tagsMap,\n  generateId,\n  documentId,\n}: {\n  document: OpenApiDocument\n  /** Map of tags and their entries */\n  tagsMap: TagsMap\n  /** Function used to generate unique IDs for operations */\n  generateId: TraverseSpecOptions['generateId']\n  /** Document ID */\n  documentId: string\n}): { untaggedOperations: TraversedOperation[] } => {\n  const untaggedOperations: TraversedOperation[] = []\n\n  // Traverse paths\n  Object.entries(document.paths ?? {}).forEach(([path, pathItemObject]) => {\n    const pathKeys = objectKeys(pathItemObject ?? {}).filter((key) => isHttpMethod(key))\n\n    pathKeys.forEach((method) => {\n      const _operation = pathItemObject?.[method]\n      const operation = getResolvedRef(_operation)\n      if (!operation) {\n        return\n      }\n\n      // Skip if the operation is internal or scalar-ignore\n      if (operation['x-internal'] || operation['x-scalar-ignore'] || !isHttpMethod(method)) {\n        return\n      }\n\n      const ref = `#/paths/${escapeJsonPointer(path)}/${method}`\n\n      // Traverse tags\n      if (operation.tags?.length) {\n        operation.tags.forEach((tagName: string) => {\n          const { tag, id: tagId } = getTag({\n            tagsMap,\n            name: tagName,\n            documentId,\n            generateId,\n          })\n          tagsMap.get(tagName)?.entries.push(\n            createOperationEntry({\n              ref,\n              operation,\n              method,\n              path,\n              parentTag: { tag, id: tagId },\n              generateId,\n              parentId: tagId,\n            }),\n          )\n        })\n      } else {\n        // Collect operations without tags (no parentTag)\n        untaggedOperations.push(\n          createOperationEntry({\n            ref,\n            operation,\n            method,\n            path,\n            generateId,\n            parentId: documentId,\n          }),\n        )\n      }\n    })\n  })\n\n  return { untaggedOperations }\n}\n"],
  "mappings": "AACA,SAAS,oBAAoB;AAC7B,SAAS,kBAAkB;AAC3B,SAAS,yBAAyB;AAElC,SAAS,sBAAsB;AAC/B,SAAS,iCAAiC;AAE1C,SAAS,8BAA8B;AAIvC,SAAS,cAAc;AAEhB,MAAM,wBAAwB,CAAC,cAA+B;AACnE,SAAO,UAAU,cAAc,UAAU,oBAAoB,MAAM,uBAAuB;AAC5F;AAcA,MAAM,uBAAuB,CAAC;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAQ0B;AACxB,QAAM,KAAK,WAAW;AAAA,IACpB,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACD,QAAM,QAAQ,UAAU,SAAS,KAAK,IAAI,UAAU,UAAU;AAE9D,QAAM,eAAe,sBAAsB,SAAS;AAEpD,QAAM,WAA+B,0BAA0B,SAAS,EAAE,IAAI,CAAC,aAAa;AAAA,IAC1F,MAAM;AAAA,IACN,IAAI,WAAW;AAAA,MACb,MAAM;AAAA,MACN,UAAU;AAAA,MACV,MAAM;AAAA,IACR,CAAC;AAAA,IACD,OAAO;AAAA,IACP,MAAM;AAAA,EACR,EAAE;AAEF,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM;AAAA,IACN;AAAA,IACA,UAAU,SAAS,SAAS,WAAW;AAAA,EACzC;AAEA,SAAO;AACT;AAmBO,MAAM,gBAAgB,CAAC;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAQoD;AAClD,QAAM,qBAA2C,CAAC;AAGlD,SAAO,QAAQ,SAAS,SAAS,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,MAAM,cAAc,MAAM;AACvE,UAAM,WAAW,WAAW,kBAAkB,CAAC,CAAC,EAAE,OAAO,CAAC,QAAQ,aAAa,GAAG,CAAC;AAEnF,aAAS,QAAQ,CAAC,WAAW;AAC3B,YAAM,aAAa,iBAAiB,MAAM;AAC1C,YAAM,YAAY,eAAe,UAAU;AAC3C,UAAI,CAAC,WAAW;AACd;AAAA,MACF;AAGA,UAAI,UAAU,YAAY,KAAK,UAAU,iBAAiB,KAAK,CAAC,aAAa,MAAM,GAAG;AACpF;AAAA,MACF;AAEA,YAAM,MAAM,WAAW,kBAAkB,IAAI,CAAC,IAAI,MAAM;AAGxD,UAAI,UAAU,MAAM,QAAQ;AAC1B,kBAAU,KAAK,QAAQ,CAAC,YAAoB;AAC1C,gBAAM,EAAE,KAAK,IAAI,MAAM,IAAI,OAAO;AAAA,YAChC;AAAA,YACA,MAAM;AAAA,YACN;AAAA,YACA;AAAA,UACF,CAAC;AACD,kBAAQ,IAAI,OAAO,GAAG,QAAQ;AAAA,YAC5B,qBAAqB;AAAA,cACnB;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA,WAAW,EAAE,KAAK,IAAI,MAAM;AAAA,cAC5B;AAAA,cACA,UAAU;AAAA,YACZ,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AAAA,MACH,OAAO;AAEL,2BAAmB;AAAA,UACjB,qBAAqB;AAAA,YACnB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,UAAU;AAAA,UACZ,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AAED,SAAO,EAAE,mBAAmB;AAC9B;",
  "names": []
}
