import { isHttpMethod } from "@scalar/helpers/http/is-http-method";
import { objectKeys } from "@scalar/helpers/object/object-keys";
import { escapeJsonPointer } from "@scalar/json-magic/helpers/escape-json-pointer";
import { getResolvedRef } from "../../helpers/get-resolved-ref.js";
import { traverseOperationExamples } from "../../navigation/helpers/traverse-examples.js";
import { XScalarStabilityValues } from "../../schemas/extensions/operation/index.js";
import { getTag } from "./get-tag.js";
const isDeprecatedOperation = (operation) => {
  return operation.deprecated || operation["x-scalar-stability"] === XScalarStabilityValues.Deprecated;
};
const createOperationEntry = ({
  ref,
  operation,
  method,
  path,
  generateId,
  parentId,
  parentTag
}) => {
  const id = generateId({
    type: "operation",
    operation,
    parentTag,
    method,
    path,
    parentId
  });
  const title = operation.summary?.trim() ? operation.summary : path;
  const isDeprecated = isDeprecatedOperation(operation);
  const examples = traverseOperationExamples(operation).map((example) => ({
    type: "example",
    id: generateId({
      type: "example",
      parentId: id,
      name: example
    }),
    title: example,
    name: example
  }));
  const entry = {
    id,
    title,
    path,
    method,
    ref,
    type: "operation",
    isDeprecated,
    children: examples.length ? examples : void 0
  };
  return entry;
};
const traversePaths = ({
  document,
  tagsMap,
  generateId,
  documentId
}) => {
  const untaggedOperations = [];
  Object.entries(document.paths ?? {}).forEach(([path, pathItemObject]) => {
    const pathKeys = objectKeys(pathItemObject ?? {}).filter((key) => isHttpMethod(key));
    pathKeys.forEach((method) => {
      const _operation = pathItemObject?.[method];
      const operation = getResolvedRef(_operation);
      if (!operation) {
        return;
      }
      if (operation["x-internal"] || operation["x-scalar-ignore"] || !isHttpMethod(method)) {
        return;
      }
      const ref = `#/paths/${escapeJsonPointer(path)}/${method}`;
      if (operation.tags?.length) {
        operation.tags.forEach((tagName) => {
          const { tag, id: tagId } = getTag({
            tagsMap,
            name: tagName,
            documentId,
            generateId
          });
          tagsMap.get(tagName)?.entries.push(
            createOperationEntry({
              ref,
              operation,
              method,
              path,
              parentTag: { tag, id: tagId },
              generateId,
              parentId: tagId
            })
          );
        });
      } else {
        untaggedOperations.push(
          createOperationEntry({
            ref,
            operation,
            method,
            path,
            generateId,
            parentId: documentId
          })
        );
      }
    });
  });
  return { untaggedOperations };
};
export {
  isDeprecatedOperation,
  traversePaths
};
//# sourceMappingURL=traverse-paths.js.map
