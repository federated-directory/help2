import { isObject } from "@scalar/helpers/object/is-object";
import { preventPollution } from "@scalar/helpers/object/prevent-pollution";
import { generateHash } from "@scalar/helpers/string/generate-hash";
import { measureAsync, measureSync } from "@scalar/helpers/testing/measure";
import { bundle } from "@scalar/json-magic/bundle";
import { fetchUrls } from "@scalar/json-magic/bundle/plugins/browser";
import { apply, diff, merge } from "@scalar/json-magic/diff";
import { createMagicProxy, getRaw } from "@scalar/json-magic/magic-proxy";
import { upgrade } from "@scalar/openapi-upgrader";
import { Value } from "@scalar/typebox/value";
import { reactive, toRaw } from "vue";
import YAML from "yaml";
import { applySelectiveUpdates } from "./helpers/apply-selective-updates.js";
import { deepClone } from "./helpers/deep-clone.js";
import { createDetectChangesProxy } from "./helpers/detect-changes-proxy.js";
import { safeAssign } from "./helpers/general.js";
import { getFetch } from "./helpers/get-fetch.js";
import { getValueByPath } from "./helpers/json-path-utils.js";
import { mergeObjects } from "./helpers/merge-object.js";
import { createOverridesProxy, unpackOverridesProxy } from "./helpers/overrides-proxy.js";
import { unpackProxyObject } from "./helpers/unpack-proxy.js";
import { createNavigation } from "./navigation/index.js";
import {
  externalValueResolver,
  loadingStatus,
  normalizeAuthSchemes,
  refsEverywhere,
  restoreOriginalRefs
} from "./plugins/bundler/index.js";
import { extensions } from "./schemas/extensions.js";
import { coerceValue } from "./schemas/typebox-coerce.js";
import {
  OpenAPIDocumentSchema as OpenAPIDocumentSchemaStrict
} from "./schemas/v3.1/strict/openapi-document.js";
function loadDocument(workspaceDocument) {
  if ("url" in workspaceDocument) {
    return fetchUrls({ fetch: workspaceDocument.fetch }).exec(workspaceDocument.url);
  }
  return Promise.resolve({
    ok: true,
    data: workspaceDocument.document,
    // string version of the raw document for hashing purposes
    raw: JSON.stringify(workspaceDocument.document)
  });
}
const getDocumentSource = (input) => {
  if ("url" in input) {
    return input.url;
  }
  return void 0;
};
const createWorkspaceStore = (workspaceProps) => {
  const extraDocumentConfigurations = {};
  const fireWorkspaceChange = (event) => {
    workspaceProps?.plugins?.forEach((plugin) => plugin.hooks?.onWorkspaceStateChanges?.(event));
  };
  const workspace = reactive(
    createDetectChangesProxy(
      {
        ...workspaceProps?.meta,
        documents: {},
        /**
         * Returns the currently active document from the workspace.
         * The active document is determined by the 'x-scalar-active-document' metadata field,
         * falling back to the first document in the workspace if no active document is specified.
         *
         * @returns The active document or undefined if no document is found
         */
        get activeDocument() {
          return workspace.documents[getActiveDocumentName()];
        }
      },
      {
        hooks: {
          onAfterChange(path) {
            const type = path[0];
            if (type === "documents") {
              if (path.length < 2) {
                console.log("[WARN]: Overriding entire documents object is not supported");
                return;
              }
              const documentName = path[1];
              const document = workspace.documents[documentName] ?? {
                openapi: "3.1.0",
                info: { title: "", version: "" },
                "x-scalar-original-document-hash": ""
              };
              const event2 = {
                type: "documents",
                documentName,
                value: unpackProxyObject(document),
                path: path.slice(2)
              };
              if (event2.path.length > 0 && event2.path[0] !== "x-scalar-is-dirty") {
                document["x-scalar-is-dirty"] = true;
              }
              fireWorkspaceChange(event2);
              return;
            }
            if (type === "activeDocument") {
              const documentName = getActiveDocumentName();
              const document = workspace.documents[documentName] ?? {
                openapi: "3.1.0",
                info: { title: "", version: "" },
                "x-scalar-original-document-hash": ""
              };
              const event2 = {
                type: "documents",
                documentName,
                value: unpackProxyObject(document),
                path: path.slice(2)
              };
              if (event2.path.length > 0 && event2.path[0] !== "x-scalar-is-dirty") {
                document["x-scalar-is-dirty"] = true;
              }
              fireWorkspaceChange(event2);
              return;
            }
            const { activeDocument: _a, documents: _d, ...meta } = workspace;
            const event = {
              type: "meta",
              value: unpackProxyObject(meta, { depth: 1 })
            };
            fireWorkspaceChange(event);
            return;
          }
        }
      }
    )
  );
  const { originalDocuments, intermediateDocuments, overrides } = createDetectChangesProxy(
    {
      /**
       * Holds the original, unmodified documents as they were initially loaded into the workspace.
       * These documents are stored in their raw formâ€”prior to any reactive wrapping, dereferencing, or bundling.
       * This map preserves the pristine structure of each document, using deep clones to ensure that
       * subsequent mutations in the workspace do not affect the originals.
       * The originals are retained so that we can restore, compare, or sync with the remote registry as needed.
       */
      originalDocuments: {},
      /**
       * Stores the intermediate state of documents after local edits but before syncing with the remote registry.
       *
       * This map acts as a local "saved" version of the document, reflecting the user's changes after they hit "save".
       * The `originalDocuments` map, by contrast, always mirrors the document as it exists in the remote registry.
       *
       * Use this map to stage local changes that are ready to be propagated back to the remote registry.
       * This separation allows us to distinguish between:
       *   - The last known remote version (`originalDocuments`)
       *   - The latest locally saved version (`intermediateDocuments`)
       *   - The current in-memory (possibly unsaved) workspace document (`workspace.documents`)
       */
      intermediateDocuments: {},
      /**
       * Stores per-document overrides for OpenAPI documents.
       * This object is used to override specific fields of a document
       * when you cannot (or should not) modify the source document directly.
       * For example, this enables UI-driven or temporary changes to be applied
       * on top of the original document, without mutating the source.
       * The key is the document name, and the value is a deep partial
       * OpenAPI document representing the overridden fields.
       */
      overrides: {}
    },
    {
      hooks: {
        onAfterChange(path) {
          const type = path[0];
          if (!type) {
            return;
          }
          if (path.length < 2) {
            return;
          }
          const documentName = path[1];
          if (type === "originalDocuments") {
            const event = {
              type,
              documentName,
              value: unpackProxyObject(originalDocuments[documentName] ?? {}),
              path: path.splice(2)
            };
            fireWorkspaceChange(event);
          }
          if (type === "intermediateDocuments") {
            const event = {
              type,
              documentName,
              value: unpackProxyObject(intermediateDocuments[documentName] ?? {}),
              path: path.splice(2)
            };
            fireWorkspaceChange(event);
          }
          if (type === "overrides") {
            const event = {
              type,
              documentName,
              value: unpackProxyObject(overrides[documentName] ?? {})
            };
            fireWorkspaceChange(event);
          }
        }
      }
    }
  );
  function getActiveDocumentName() {
    return workspace[extensions.workspace.activeDocument] ?? Object.keys(workspace.documents)[0] ?? "";
  }
  function exportDocument(documentName, format, minify) {
    const intermediateDocument = intermediateDocuments[documentName];
    if (!intermediateDocument) {
      return;
    }
    if (format === "json") {
      return minify ? JSON.stringify(intermediateDocument) : JSON.stringify(intermediateDocument, null, 2);
    }
    return YAML.stringify(intermediateDocument);
  }
  async function saveDocument(documentName) {
    const intermediateDocument = intermediateDocuments[documentName];
    const workspaceDocument = workspace.documents[documentName];
    if (!workspaceDocument) {
      return;
    }
    const activeDocumentRaw = unpackProxyObject(workspaceDocument);
    if (!intermediateDocument || !activeDocumentRaw) {
      console.warn("Failed to save document, intermediate document and/or active document is missing");
      return;
    }
    const updatedWithOriginalRefs = await bundle(deepClone(activeDocumentRaw), {
      plugins: [restoreOriginalRefs()],
      treeShake: false,
      urlMap: true
    });
    const excludedDiffs = applySelectiveUpdates(intermediateDocument, updatedWithOriginalRefs);
    workspaceDocument["x-scalar-is-dirty"] = false;
    return excludedDiffs;
  }
  async function addInMemoryDocument(input, navigationOptions) {
    const { name, meta } = input;
    const clonedRawInputDocument = measureSync("deepClone", () => deepClone(input.document));
    measureSync("initialize", () => {
      if (input.initialize !== false) {
        originalDocuments[name] = deepClone(clonedRawInputDocument);
        intermediateDocuments[name] = deepClone(clonedRawInputDocument);
        overrides[name] = input.overrides ?? {};
        extraDocumentConfigurations[name] = { fetch: input.fetch };
      }
    });
    const inputDocument = measureSync("upgrade", () => upgrade(deepClone(clonedRawInputDocument), "3.1"));
    const strictDocument = createMagicProxy(
      {
        ...inputDocument,
        ...meta,
        "x-original-oas-version": originalDocuments[name]?.openapi ?? originalDocuments[name]?.swagger,
        "x-scalar-original-document-hash": input.documentHash,
        "x-scalar-original-source-url": input.documentSource
      },
      { showInternal: true }
    );
    if (strictDocument[extensions.document.navigation] === void 0) {
      const loaders = [
        fetchUrls({
          fetch: extraDocumentConfigurations[name]?.fetch ?? workspaceProps?.fetch
        })
      ];
      if (workspaceProps?.fileLoader) {
        loaders.push(workspaceProps.fileLoader);
      }
      await measureAsync(
        "bundle",
        async () => await bundle(getRaw(strictDocument), {
          treeShake: false,
          plugins: [...loaders, externalValueResolver(), refsEverywhere(), normalizeAuthSchemes()],
          urlMap: true,
          origin: input.documentSource
          // use the document origin (if provided) as the base URL for resolution
        })
      );
      const coerced = measureSync(
        "coerceValue",
        () => coerceValue(OpenAPIDocumentSchemaStrict, deepClone(strictDocument))
      );
      measureSync("mergeObjects", () => mergeObjects(strictDocument, coerced));
    }
    const isValid = Value.Check(OpenAPIDocumentSchemaStrict, strictDocument);
    if (!isValid) {
      const validationErrors = Array.from(Value.Errors(OpenAPIDocumentSchemaStrict, strictDocument));
      console.warn("document validation errors: ");
      console.warn(
        validationErrors.map((error) => ({
          message: error.message,
          path: error.path,
          schema: error.schema,
          value: error.value
        }))
      );
    }
    if (strictDocument[extensions.document.navigation] === void 0) {
      const navigation = createNavigation(name, strictDocument, navigationOptions);
      strictDocument[extensions.document.navigation] = navigation;
    }
    workspace.documents[name] = createOverridesProxy(createMagicProxy(getRaw(strictDocument)), {
      overrides: unpackProxyObject(overrides[name])
    });
  }
  async function addDocument(input, navigationOptions) {
    const { name, meta } = input;
    const fetch = getFetch({
      fetch: input.fetch ?? workspaceProps?.fetch,
      proxyUrl: workspace["x-scalar-active-proxy"]
    });
    const resolve = await measureAsync("loadDocument", async () => await loadDocument({ ...input, fetch }));
    return await measureAsync("addDocument", async () => {
      if (!resolve.ok) {
        console.error(`Failed to fetch document '${name}': request was not successful`);
        workspace.documents[name] = {
          ...meta,
          openapi: "3.1.0",
          info: {
            title: `Document '${name}' could not be loaded`,
            version: "unknown"
          },
          "x-scalar-original-document-hash": "not-a-hash"
        };
        return false;
      }
      if (!isObject(resolve.data)) {
        console.error(`Failed to load document '${name}': response data is not a valid object`);
        workspace.documents[name] = {
          ...meta,
          openapi: "3.1.0",
          info: {
            title: `Document '${name}' could not be loaded`,
            version: "unknown"
          },
          "x-scalar-original-document-hash": "not-a-hash"
        };
        return false;
      }
      await addInMemoryDocument(
        {
          ...input,
          document: resolve.data,
          documentSource: getDocumentSource(input),
          documentHash: generateHash(resolve.raw)
        },
        navigationOptions
      );
      return true;
    });
  }
  const buildSidebar = (documentName) => {
    const document = workspace.documents[documentName];
    if (!document) {
      console.error(`Document '${documentName}' does not exist in the workspace.`);
      return false;
    }
    const navigation = createNavigation(documentName, document);
    document[extensions.document.navigation] = navigation;
    return true;
  };
  const visitedNodesCache = /* @__PURE__ */ new Set();
  return {
    get workspace() {
      return workspace;
    },
    update(key, value) {
      preventPollution(key);
      Object.assign(workspace, { [key]: value });
    },
    updateDocument(name, key, value) {
      const currentDocument = workspace.documents[name === "active" ? getActiveDocumentName() : name];
      if (!currentDocument) {
        throw "Please select a valid document";
      }
      preventPollution(key);
      Object.assign(currentDocument, { [key]: value });
    },
    async replaceDocument(documentName, input) {
      const currentDocument = workspace.documents[documentName];
      if (!currentDocument) {
        return console.error(`Document '${documentName}' does not exist in the workspace.`);
      }
      await addInMemoryDocument({
        name: documentName,
        document: input,
        // Preserve the current metadata
        documentSource: currentDocument["x-scalar-original-source-url"],
        documentHash: currentDocument["x-scalar-original-document-hash"],
        meta: {
          "x-scalar-active-auth": currentDocument["x-scalar-active-auth"],
          "x-scalar-active-server": currentDocument["x-scalar-active-server"]
        },
        initialize: false
      });
    },
    resolve: (path) => {
      const activeDocument = workspace.activeDocument;
      const target = getValueByPath(activeDocument, path);
      if (!isObject(target)) {
        console.error(
          `Invalid path provided for resolution. Path: [${path.join(", ")}]. Found value of type: ${typeof target}. Expected an object.`
        );
        return Promise.resolve();
      }
      return bundle(target, {
        root: activeDocument,
        treeShake: false,
        plugins: [fetchUrls(), loadingStatus(), externalValueResolver()],
        urlMap: true,
        visitedNodes: visitedNodesCache
      });
    },
    addDocument,
    /**
     * Deletes a document from the workspace and all associated data.
     *
     * This function removes the document and all related data structures.
     * If the deleted document was active, it automatically selects the first remaining document.
     */
    deleteDocument: (documentName) => {
      if (!workspace.documents[documentName]) {
        return;
      }
      delete workspace.documents[documentName];
      delete originalDocuments[documentName];
      delete intermediateDocuments[documentName];
      delete overrides[documentName];
      delete extraDocumentConfigurations[documentName];
      const remainingDocuments = Object.keys(workspace.documents);
      const wasActiveDocument = workspace["x-scalar-active-document"] === documentName;
      if (wasActiveDocument) {
        workspace["x-scalar-active-document"] = remainingDocuments[0] ?? void 0;
      }
      fireWorkspaceChange({
        type: "deleteDocument",
        documentName
      });
    },
    exportDocument,
    exportActiveDocument: (format, minify) => exportDocument(getActiveDocumentName(), format, minify),
    buildSidebar,
    saveDocument,
    async revertDocumentChanges(documentName) {
      const workspaceDocument = workspace.documents[documentName];
      const intermediate = intermediateDocuments[documentName];
      if (!workspaceDocument || !intermediate) {
        return;
      }
      await addInMemoryDocument({
        name: documentName,
        document: intermediate,
        documentSource: workspaceDocument["x-scalar-original-source-url"],
        documentHash: workspaceDocument["x-scalar-original-document-hash"],
        initialize: false
      });
    },
    commitDocument(documentName) {
      console.warn(`Commit operation for document '${documentName}' is not implemented yet.`);
    },
    exportWorkspace() {
      const { activeDocument: _, documents, ...meta } = unpackProxyObject(workspace);
      return {
        documents: {
          ...Object.fromEntries(
            Object.entries(documents).map(([name, doc]) => [
              name,
              // Get the raw document without any proxies
              unpackProxyObject(doc)
            ])
          )
        },
        meta: unpackProxyObject(meta) ?? {},
        originalDocuments: unpackProxyObject(originalDocuments),
        intermediateDocuments: unpackProxyObject(intermediateDocuments),
        overrides: unpackProxyObject(overrides)
      };
    },
    loadWorkspace(input) {
      safeAssign(
        workspace.documents,
        Object.fromEntries(
          Object.entries(input.documents).map(([name, doc]) => [
            name,
            createOverridesProxy(createMagicProxy(doc), {
              overrides: input.overrides[name]
            })
          ])
        )
      );
      safeAssign(originalDocuments, input.originalDocuments);
      safeAssign(intermediateDocuments, input.intermediateDocuments);
      safeAssign(overrides, input.overrides);
      safeAssign(workspace, input.meta);
    },
    importWorkspaceFromSpecification: (specification) => {
      const { documents, overrides: overrides2, info: _info, workspace: _workspaceVersion, ...meta } = specification;
      safeAssign(workspace, meta);
      return Promise.all(
        Object.entries(documents ?? {}).map(
          ([name, doc]) => addDocument({ url: doc.$ref, name, overrides: overrides2?.[name] })
        )
      );
    },
    rebaseDocument: async (input) => {
      const { name } = input;
      const originalDocument = originalDocuments[name];
      const intermediateDocument = intermediateDocuments[name];
      const activeDocument = workspace.documents[name] ? toRaw(getRaw(unpackOverridesProxy(workspace.documents[name]))) : void 0;
      if (!originalDocument || !intermediateDocument || !activeDocument) {
        return {
          ok: false,
          type: "CORRUPTED_STATE",
          message: `Cannot rebase document '${name}': missing original, intermediate, or active document state`
        };
      }
      const resolve = await measureAsync(
        "loadDocument",
        async () => await loadDocument({ ...input, fetch: input.fetch ?? workspaceProps?.fetch })
      );
      if (!resolve.ok || !isObject(resolve.data)) {
        return {
          ok: false,
          type: "FETCH_FAILED",
          message: `Failed to fetch document '${name}': request was not successful or returned invalid data`
        };
      }
      const newHash = generateHash(resolve.raw);
      if (activeDocument["x-scalar-original-document-hash"] === newHash) {
        return {
          ok: false,
          type: "NO_CHANGES_DETECTED",
          message: `No changes detected for document '${name}': document hash matches the active document`
        };
      }
      const newDocumentOrigin = resolve.data;
      overrides[name] = input.overrides ?? {};
      extraDocumentConfigurations[name] = { fetch: input.fetch };
      const changelogAA = diff(originalDocument, newDocumentOrigin);
      if (changelogAA.length === 0) {
        return {
          ok: false,
          type: "NO_CHANGES_DETECTED",
          message: `No changes detected for document '${name}' after fetching the latest version.`
        };
      }
      const changelogAB = diff(originalDocument, intermediateDocument);
      const changesA = merge(changelogAA, changelogAB);
      return {
        ok: true,
        conflicts: changesA.conflicts,
        applyChanges: async (resolvedConflicts) => {
          const changesetA = changesA.diffs.concat(resolvedConflicts);
          const newIntermediateDocument = apply(deepClone(originalDocument), changesetA);
          intermediateDocuments[name] = newIntermediateDocument;
          originalDocuments[name] = newDocumentOrigin;
          const changelogBA = diff(intermediateDocument, newIntermediateDocument);
          const changelogBB = diff(intermediateDocument, activeDocument);
          const changesB = merge(changelogBA, changelogBB);
          const changesetB = changesB.diffs.concat(changesB.conflicts.flatMap((it) => it[0]));
          const newActiveDocument = coerceValue(
            OpenAPIDocumentSchemaStrict,
            apply(deepClone(newIntermediateDocument), changesetB)
          );
          await addInMemoryDocument({
            ...input,
            document: {
              ...newActiveDocument,
              // force regeneration of navigation
              // when we are rebasing, we want to ensure that the navigation is always up to date
              [extensions.document.navigation]: void 0
            },
            documentSource: getDocumentSource(input),
            // Update the original document hash
            documentHash: generateHash(resolve.raw),
            initialize: false
          });
        }
      };
    }
  };
};
import { generateClientMutators } from "./mutators/index.js";
export {
  createWorkspaceStore,
  generateClientMutators
};
//# sourceMappingURL=client.js.map
