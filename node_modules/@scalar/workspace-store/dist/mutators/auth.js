import { generateUniqueValue } from "../helpers/generate-unique-value.js";
import { getResolvedRef } from "../helpers/get-resolved-ref.js";
import { isNonOptionalSecurityRequirement } from "../helpers/is-non-optional-security-requirement.js";
import { mergeObjects } from "../helpers/merge-object.js";
const updateSelectedSecuritySchemes = async (document, { selectedRequirements, newSchemes, meta }) => {
  if (!document) {
    return;
  }
  const getTarget = () => {
    if (meta.type === "document") {
      return document;
    }
    return getResolvedRef(document.paths?.[meta.path]?.[meta.method]);
  };
  const createdSecurityRequirements = await Promise.all(
    newSchemes.map(async (newScheme) => {
      const uniqueSchemeName = await generateUniqueValue({
        defaultValue: newScheme.name,
        validation: (value) => !document.components?.securitySchemes?.[value],
        maxRetries: 100
      });
      if (!uniqueSchemeName) {
        return;
      }
      if (!document.components) {
        document.components = {};
      }
      if (!document.components.securitySchemes) {
        document.components.securitySchemes = {};
      }
      document.components.securitySchemes[uniqueSchemeName] = newScheme.scheme;
      return {
        [uniqueSchemeName]: []
      };
    })
  );
  const createdSchemes = createdSecurityRequirements.filter(Boolean);
  const target = getTarget();
  const newSelectedSecuritySchemes = [...selectedRequirements, ...createdSchemes];
  if (!target) {
    return;
  }
  if (!target["x-scalar-selected-security"]) {
    target["x-scalar-selected-security"] = {
      selectedIndex: -1,
      selectedSchemes: []
    };
  }
  const selectedIndex = target["x-scalar-selected-security"].selectedIndex;
  target["x-scalar-selected-security"].selectedSchemes = newSelectedSecuritySchemes;
  if (newSelectedSecuritySchemes.length > 0 && selectedIndex < 0) {
    target["x-scalar-selected-security"].selectedIndex = 0;
  }
  if (selectedIndex >= newSelectedSecuritySchemes.length) {
    target["x-scalar-selected-security"].selectedIndex = newSelectedSecuritySchemes.length - 1;
  }
};
const updateSecurityScheme = (document, { payload, name }) => {
  const target = getResolvedRef(document?.components?.securitySchemes?.[name]);
  if (!target) {
    console.error(`Security scheme ${name} not found`);
    return;
  }
  if (target.type === payload.type) {
    mergeObjects(target, payload);
  }
  return target;
};
const updateSelectedAuthTab = (document, { index, meta }) => {
  if (!document) {
    return;
  }
  const getTarget = () => {
    if (meta.type === "document") {
      return document;
    }
    return getResolvedRef(document.paths?.[meta.path]?.[meta.method]);
  };
  const target = getTarget();
  if (!target) {
    return;
  }
  if (!target["x-scalar-selected-security"]) {
    target["x-scalar-selected-security"] = {
      selectedIndex: 0,
      selectedSchemes: []
    };
  }
  target["x-scalar-selected-security"].selectedIndex = index;
};
const updateSelectedScopes = (document, { id, name, scopes, newScopePayload, meta }) => {
  if (!document) {
    return;
  }
  const getTarget = () => {
    if (meta.type === "document") {
      return document;
    }
    return getResolvedRef(document.paths?.[meta.path]?.[meta.method]);
  };
  const target = getTarget();
  if (!target) {
    return;
  }
  const selectedSchemes = target["x-scalar-selected-security"]?.selectedSchemes;
  if (!selectedSchemes) {
    return;
  }
  const scheme = selectedSchemes.find((scheme2) => JSON.stringify(Object.keys(scheme2)) === JSON.stringify(id));
  if (!isNonOptionalSecurityRequirement(scheme)) {
    return;
  }
  if (newScopePayload) {
    const securityScheme = getResolvedRef(document.components?.securitySchemes?.[name]);
    const flow = securityScheme?.flows?.[newScopePayload?.flowType];
    if (!flow) {
      return;
    }
    flow.scopes ||= {};
    flow.scopes[newScopePayload.name] = newScopePayload.description;
    scheme[name] = [...scopes, newScopePayload.name];
    return;
  }
  scheme[name] = scopes;
};
const deleteSecurityScheme = (document, { names }) => {
  if (!document) {
    return;
  }
  const target = getResolvedRef(document.components?.securitySchemes);
  if (!target) {
    return;
  }
  names.forEach((name) => {
    delete target[name];
  });
  const filterSecuritySchemes = (schemes) => {
    return schemes.filter((scheme) => !names.some((name) => Object.keys(scheme).includes(name)));
  };
  if (document["x-scalar-selected-security"]) {
    const selectedSecurity = document["x-scalar-selected-security"];
    selectedSecurity.selectedSchemes = filterSecuritySchemes(selectedSecurity.selectedSchemes);
  }
  if (document["security"]) {
    document["security"] = filterSecuritySchemes(document["security"]);
  }
  Object.values(document.paths ?? {}).forEach((path) => {
    Object.values(path).forEach((operation) => {
      if (typeof operation !== "object") {
        return;
      }
      const resolvedOperation = getResolvedRef(operation);
      if ("security" in resolvedOperation && resolvedOperation["security"]) {
        resolvedOperation["security"] = filterSecuritySchemes(resolvedOperation["security"]);
      }
      if ("x-scalar-selected-security" in resolvedOperation && resolvedOperation["x-scalar-selected-security"]) {
        resolvedOperation["x-scalar-selected-security"].selectedSchemes = filterSecuritySchemes(
          resolvedOperation["x-scalar-selected-security"].selectedSchemes
        );
      }
    });
  });
};
const authMutatorsFactory = ({ document }) => {
  return {
    updateSelectedSecuritySchemes: (payload) => updateSelectedSecuritySchemes(document, payload),
    updateSecurityScheme: (payload) => updateSecurityScheme(document, payload),
    updateSelectedAuthTab: (payload) => updateSelectedAuthTab(document, payload),
    updateSelectedScopes: (payload) => updateSelectedScopes(document, payload),
    deleteSecurityScheme: (payload) => deleteSecurityScheme(document, payload)
  };
};
export {
  authMutatorsFactory,
  deleteSecurityScheme,
  updateSecurityScheme,
  updateSelectedAuthTab,
  updateSelectedScopes,
  updateSelectedSecuritySchemes
};
//# sourceMappingURL=auth.js.map
