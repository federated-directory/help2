import { isHttpMethod } from "@scalar/helpers/http/is-http-method";
import { preventPollution } from "@scalar/helpers/object/prevent-pollution";
import { findVariables } from "@scalar/helpers/regex/find-variables";
import { getResolvedRef } from "../helpers/get-resolved-ref.js";
import { unpackProxyObject } from "../helpers/unpack-proxy.js";
import { fetchRequestToHar } from "../mutators/fetch-request-to-har.js";
import { fetchResponseToHar } from "../mutators/fetch-response-to-har.js";
import { harToOperation } from "../mutators/har-to-operation.js";
import { getOpenapiObject, getOperationEntries } from "../navigation/index.js";
import { getNavigationOptions } from "../navigation/get-navigation-options.js";
import { canHaveOrder } from "../navigation/helpers/get-openapi-object.js";
import { isContentTypeParameterObject } from "../schemas/v3.1/strict/type-guards.js";
const getParameterPositions = (path, parameters) => {
  const positions = {};
  for (const paramName of parameters) {
    const position = path.indexOf(`{${paramName}}`);
    if (position !== -1) {
      positions[paramName] = position;
    }
  }
  return positions;
};
const syncParametersForPathChange = (newPath, oldPath, existingParameters) => {
  const oldPathParams = findVariables(oldPath, { includePath: true, includeEnv: false }).filter(
    (v) => v !== void 0
  );
  const newPathParams = findVariables(newPath, { includePath: true, includeEnv: false }).filter(
    (v) => v !== void 0
  );
  const oldPositions = getParameterPositions(oldPath, oldPathParams);
  const newPositions = getParameterPositions(newPath, newPathParams);
  const pathParameters = [];
  const nonPathParameters = [];
  for (const param of existingParameters) {
    const resolved = getResolvedRef(param);
    if (resolved?.in === "path") {
      pathParameters.push(resolved);
    } else {
      nonPathParameters.push(param);
    }
  }
  const existingPathParamsByName = /* @__PURE__ */ new Map();
  for (const param of pathParameters) {
    if (param.name) {
      existingPathParamsByName.set(param.name, param);
    }
  }
  const usedOldParams = /* @__PURE__ */ new Set();
  const syncedPathParameters = [];
  for (const newParamName of newPathParams) {
    if (existingPathParamsByName.has(newParamName)) {
      syncedPathParameters.push(existingPathParamsByName.get(newParamName));
      usedOldParams.add(newParamName);
      continue;
    }
    const newParamPosition = newPositions[newParamName];
    const oldParamAtPosition = oldPathParams.find(
      (oldParam) => oldPositions[oldParam] === newParamPosition && !usedOldParams.has(oldParam)
    );
    if (oldParamAtPosition && existingPathParamsByName.has(oldParamAtPosition)) {
      const oldParam = existingPathParamsByName.get(oldParamAtPosition);
      oldParam.name = newParamName;
      syncedPathParameters.push(oldParam);
      usedOldParams.add(oldParamAtPosition);
      continue;
    }
    syncedPathParameters.push({
      name: newParamName,
      in: "path"
    });
  }
  return unpackProxyObject([...syncedPathParameters, ...nonPathParameters], { depth: 1 });
};
const createOperation = (workspaceStore, payload) => {
  const document = workspaceStore?.workspace.documents[payload.documentName];
  if (!document) {
    payload.callback?.(false);
    return void 0;
  }
  const { path, method, operation } = payload;
  const normalizedPath = path.startsWith("/") ? path : `/${path}`;
  if (!document.paths) {
    document.paths = {};
  }
  if (!document.paths[normalizedPath]) {
    document.paths[normalizedPath] = {};
  }
  preventPollution(normalizedPath);
  preventPollution(method);
  document.paths[normalizedPath][method] = operation;
  const { servers } = operation;
  const firstServer = unpackProxyObject(servers?.[0]);
  for (const server of servers ?? []) {
    if (!document.servers?.some((s) => s.url === server.url)) {
      if (!document.servers) {
        document.servers = [];
      }
      document.servers.push(unpackProxyObject(server));
    }
  }
  if (firstServer) {
    document["x-scalar-selected-server"] = firstServer.url;
  }
  payload.callback?.(true);
  return normalizedPath;
};
const updateOperationSummary = (document, { meta, payload: { summary } }) => {
  if (!document) {
    return;
  }
  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method]);
  if (!operation) {
    return;
  }
  operation.summary = summary;
};
const updateOperationOrderId = ({
  store,
  operation,
  generateId,
  method,
  path,
  entries
}) => {
  entries?.forEach((entry) => {
    if (!canHaveOrder(entry.parent)) {
      return;
    }
    const parentOpenAPIObject = getOpenapiObject({ store, entry: entry.parent });
    if (!parentOpenAPIObject || !("x-scalar-order" in parentOpenAPIObject)) {
      return;
    }
    const order = parentOpenAPIObject["x-scalar-order"];
    const index = order?.indexOf(entry.id);
    if (!Array.isArray(order) || typeof index !== "number" || index < 0) {
      return;
    }
    const parentTag = entry.parent.type === "tag" && "name" in parentOpenAPIObject ? { tag: parentOpenAPIObject, id: entry.parent.id } : void 0;
    order[index] = generateId({
      type: "operation",
      path,
      method,
      operation,
      parentId: entry.parent.id,
      parentTag
    });
  });
};
const updateOperationPathMethod = (document, store, { meta, payload: { method, path }, callback }) => {
  const methodChanged = meta.method !== method;
  const pathChanged = meta.path !== path;
  if (!methodChanged && !pathChanged) {
    callback("no-change");
    return;
  }
  const finalMethod = methodChanged ? method : meta.method;
  const finalPath = pathChanged ? path : meta.path;
  if (document?.paths?.[finalPath]?.[finalMethod]) {
    callback("conflict");
    return;
  }
  const documentNavigation = document?.["x-scalar-navigation"];
  if (!documentNavigation || !store) {
    console.error("Document or workspace not found", { document });
    return;
  }
  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method]);
  if (!operation) {
    console.error("Operation not found", { meta, document });
    return;
  }
  if (pathChanged) {
    const oldPathParams = findVariables(meta.path, { includePath: true, includeEnv: false }).filter(
      (v) => v !== void 0
    );
    const newPathParams = findVariables(finalPath, { includePath: true, includeEnv: false }).filter(
      (v) => v !== void 0
    );
    if (oldPathParams.length > 0 || newPathParams.length > 0) {
      const existingParameters = operation.parameters ?? [];
      operation.parameters = syncParametersForPathChange(finalPath, meta.path, existingParameters);
    }
  }
  const { generateId } = getNavigationOptions(documentNavigation.name);
  const operationEntriesMap = getOperationEntries(documentNavigation);
  const entries = operationEntriesMap.get(`${meta.path}|${meta.method}`);
  if (entries) {
    updateOperationOrderId({ store, operation, generateId, method: finalMethod, path: finalPath, entries });
  }
  if (!document.paths) {
    document.paths = {};
  }
  if (!document.paths[finalPath]) {
    document.paths[finalPath] = {};
  }
  preventPollution(finalPath);
  preventPollution(meta.path);
  preventPollution(finalMethod);
  document.paths[finalPath][finalMethod] = unpackProxyObject(operation);
  const oldPathItems = document.paths[meta.path];
  if (oldPathItems && isHttpMethod(meta.method)) {
    delete oldPathItems[meta.method];
    if (Object.keys(oldPathItems).length === 0) {
      delete document.paths[meta.path];
    }
  }
  delete operation["x-scalar-history"];
  callback("success");
};
const deleteOperation = (workspace, { meta, documentName }) => {
  const document = workspace?.workspace.documents[documentName];
  if (!document) {
    return;
  }
  preventPollution(meta.path);
  preventPollution(meta.method);
  delete document.paths?.[meta.path]?.[meta.method];
  if (Object.keys(document.paths?.[meta.path] ?? {}).length === 0) {
    delete document.paths?.[meta.path];
  }
};
const deleteOperationExample = (workspace, { meta: { path, method, exampleKey }, documentName }) => {
  const document = workspace?.workspace.documents[documentName];
  if (!document) {
    return;
  }
  const operation = getResolvedRef(document.paths?.[path]?.[method]);
  if (!operation) {
    return;
  }
  operation.parameters?.forEach((parameter) => {
    const resolvedParameter = getResolvedRef(parameter);
    if ("content" in resolvedParameter && resolvedParameter.content) {
      Object.values(resolvedParameter.content).forEach((mediaType) => {
        delete mediaType.examples?.[exampleKey];
      });
    }
    if ("examples" in resolvedParameter && resolvedParameter.examples) {
      delete resolvedParameter.examples?.[exampleKey];
    }
  });
  const requestBody = getResolvedRef(operation.requestBody);
  if (!requestBody) {
    return;
  }
  Object.values(requestBody.content ?? {}).forEach((mediaType) => {
    delete mediaType.examples?.[exampleKey];
  });
};
const upsertOperationParameter = (document, { meta, type, payload, originalParameter }) => {
  if (originalParameter) {
    originalParameter.name = payload.name;
    if (isContentTypeParameterObject(originalParameter)) {
      return;
    }
    if (!originalParameter.examples) {
      originalParameter.examples = {};
    }
    originalParameter.examples[meta.exampleKey] ||= {};
    const example = getResolvedRef(originalParameter.examples[meta.exampleKey]);
    example.value = payload.value;
    example["x-disabled"] = payload.isDisabled;
    return;
  }
  const operation = getResolvedRef(document?.paths?.[meta.path]?.[meta.method]);
  if (!operation) {
    console.error("Operation not found", { meta, document });
    return;
  }
  operation.parameters ||= [];
  operation.parameters.push({
    name: payload.name,
    in: type,
    required: type === "path" ? true : false,
    examples: {
      [meta.exampleKey]: {
        value: payload.value,
        // We always want a new parameter to be enabled by default
        "x-disabled": false
      }
    }
  });
  return;
};
const updateOperationExtraParameters = (document, { type, meta, payload, in: location }) => {
  if (!document) {
    return;
  }
  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method]);
  if (!operation) {
    return;
  }
  if (!operation["x-scalar-disable-parameters"]) {
    operation["x-scalar-disable-parameters"] = {};
  }
  const mapping = {
    global: { cookie: "global-cookies" },
    default: { header: "default-headers" }
  };
  const key = mapping[type]?.[location];
  if (!key) {
    return;
  }
  if (!operation["x-scalar-disable-parameters"][key]) {
    operation["x-scalar-disable-parameters"][key] = {};
  }
  operation["x-scalar-disable-parameters"][key][meta.exampleKey] = {
    ...operation["x-scalar-disable-parameters"][key][meta.exampleKey] ?? {},
    [meta.name]: payload.isDisabled ?? false
  };
};
const deleteOperationParameter = (document, { meta, originalParameter }) => {
  const operation = getResolvedRef(document?.paths?.[meta.path]?.[meta.method]);
  const operationIndex = operation?.parameters?.findIndex((it) => getResolvedRef(it) === originalParameter) ?? -1;
  if (operation && operationIndex >= 0) {
    operation.parameters = unpackProxyObject(
      operation.parameters?.filter((_, i) => i !== operationIndex),
      { depth: 1 }
    );
    return;
  }
  const path = getResolvedRef(document?.paths?.[meta.path]);
  const pathIndex = path?.parameters?.findIndex((it) => getResolvedRef(it) === originalParameter) ?? -1;
  if (path && pathIndex >= 0) {
    path.parameters = unpackProxyObject(
      path.parameters?.filter((_, i) => i !== pathIndex),
      { depth: 1 }
    );
  }
};
const deleteAllOperationParameters = (document, { meta, type }) => {
  if (!document) {
    return;
  }
  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method]);
  if (!operation) {
    return;
  }
  operation.parameters = operation.parameters?.filter((it) => getResolvedRef(it).in !== type) ?? [];
};
const updateOperationRequestBodyContentType = (document, { meta, payload }) => {
  if (!document) {
    return;
  }
  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method]);
  if (!operation) {
    return;
  }
  let requestBody = getResolvedRef(operation.requestBody);
  if (!requestBody) {
    operation.requestBody = {
      content: {}
    };
    requestBody = getResolvedRef(operation.requestBody);
  }
  if (!requestBody["x-scalar-selected-content-type"]) {
    requestBody["x-scalar-selected-content-type"] = {};
  }
  requestBody["x-scalar-selected-content-type"][meta.exampleKey] = payload.contentType;
};
const findOrCreateRequestBodyExample = (document, contentType, meta) => {
  const operation = getResolvedRef(document?.paths?.[meta.path]?.[meta.method]);
  if (!operation) {
    return null;
  }
  let requestBody = getResolvedRef(operation.requestBody);
  if (!requestBody) {
    operation.requestBody = {
      content: {}
    };
    requestBody = getResolvedRef(operation.requestBody);
  }
  requestBody.content[contentType] ||= {};
  requestBody.content[contentType].examples ||= {};
  requestBody.content[contentType].examples[meta.exampleKey] ||= {};
  const example = getResolvedRef(requestBody.content[contentType].examples?.[meta.exampleKey]);
  return example ?? null;
};
const updateOperationRequestBodyExample = (document, { meta, payload, contentType }) => {
  const example = findOrCreateRequestBodyExample(document, contentType, meta);
  if (!example) {
    console.error("Example not found", meta.exampleKey);
    return;
  }
  example.value = payload;
};
const updateOperationRequestBodyFormValue = (document, { meta, payload, contentType }) => {
  const example = findOrCreateRequestBodyExample(document, contentType, meta);
  if (!example) {
    console.error("Example not found", meta.exampleKey);
    return;
  }
  example.value = unpackProxyObject(payload, { depth: 3 });
};
const HISTORY_LIMIT = 5;
const addResponseToHistory = async (document, { payload, meta }) => {
  if (!document || !payload) {
    return;
  }
  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method]);
  if (!operation) {
    return;
  }
  const operationParameters = operation.parameters ?? [];
  const variables = operationParameters.reduce((acc, param) => {
    const resolvedParam = getResolvedRef(param);
    if (isContentTypeParameterObject(resolvedParam)) {
      return acc;
    }
    if (resolvedParam.in === "path") {
      acc[resolvedParam.name] = getResolvedRef(resolvedParam.examples?.[meta.exampleKey])?.value ?? "";
    }
    return acc;
  }, {});
  const requestHar = await fetchRequestToHar({ request: payload.request });
  const responseHar = await fetchResponseToHar({ response: payload.response });
  operation["x-scalar-history"] ||= [];
  if (operation["x-scalar-history"].length >= HISTORY_LIMIT) {
    operation["x-scalar-history"] = unpackProxyObject(
      operation["x-scalar-history"].filter((_, i) => i !== 0),
      { depth: 1 }
    );
  }
  operation["x-scalar-history"].push({
    response: responseHar,
    request: requestHar,
    meta: {
      example: meta.exampleKey
    },
    time: payload.duration,
    timestamp: payload.timestamp,
    requestMetadata: {
      variables
    }
  });
};
const reloadOperationHistory = (document, { meta, index, callback }) => {
  if (!document) {
    console.error("Document not found", meta.path, meta.method);
    return;
  }
  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method]);
  if (!operation) {
    console.error("Operation not found", meta.path, meta.method);
    return;
  }
  const historyItem = operation["x-scalar-history"]?.[index];
  if (!historyItem) {
    console.error("History item not found", index);
    return;
  }
  harToOperation({
    harRequest: historyItem.request,
    exampleKey: "draft",
    baseOperation: operation,
    pathVariables: historyItem.requestMetadata.variables
  });
  callback("success");
};
const operationMutatorsFactory = ({
  document,
  store
}) => {
  return {
    createOperation: (payload) => createOperation(store, payload),
    updateOperationSummary: (payload) => updateOperationSummary(document, payload),
    updateOperationPathMethod: (payload) => updateOperationPathMethod(document, store, payload),
    deleteOperation: (payload) => deleteOperation(store, payload),
    deleteOperationExample: (payload) => deleteOperationExample(store, payload),
    updateOperationExtraParameters: (payload) => updateOperationExtraParameters(document, payload),
    upsertOperationParameter: (payload) => upsertOperationParameter(document, payload),
    deleteOperationParameter: (payload) => deleteOperationParameter(document, payload),
    deleteAllOperationParameters: (payload) => deleteAllOperationParameters(document, payload),
    updateOperationRequestBodyContentType: (payload) => updateOperationRequestBodyContentType(document, payload),
    updateOperationRequestBodyExample: (payload) => updateOperationRequestBodyExample(document, payload),
    updateOperationRequestBodyFormValue: (payload) => updateOperationRequestBodyFormValue(document, payload),
    addResponseToHistory: (payload) => addResponseToHistory(document, payload),
    reloadOperationHistory: (payload) => reloadOperationHistory(document, payload)
  };
};
export {
  addResponseToHistory,
  createOperation,
  deleteAllOperationParameters,
  deleteOperation,
  deleteOperationExample,
  deleteOperationParameter,
  operationMutatorsFactory,
  reloadOperationHistory,
  updateOperationExtraParameters,
  updateOperationPathMethod,
  updateOperationRequestBodyContentType,
  updateOperationRequestBodyExample,
  updateOperationRequestBodyFormValue,
  updateOperationSummary,
  upsertOperationParameter
};
//# sourceMappingURL=operation.js.map
