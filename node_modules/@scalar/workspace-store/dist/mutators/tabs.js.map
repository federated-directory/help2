{
  "version": 3,
  "sources": ["../../src/mutators/tabs.ts"],
  "sourcesContent": ["import type { TabEvents } from '@/events/definitions/tabs'\nimport { unpackProxyObject } from '@/helpers/unpack-proxy'\nimport type { Workspace } from '@/schemas'\n\n/**\n * Depth level for unpacking tab proxy objects.\n * We only need shallow unpacking since tabs are a flat array.\n */\nconst TAB_UNPACK_DEPTH = 1\n\n/**\n * Helper to validate that workspace has tabs configured.\n * Returns false if workspace or tabs are not available.\n */\nconst hasValidTabs = (\n  workspace: Workspace | null,\n): workspace is Workspace & { 'x-scalar-tabs': NonNullable<Workspace['x-scalar-tabs']> } => {\n  return workspace !== null && workspace['x-scalar-tabs'] !== undefined\n}\n\n/**\n * Helper to get the unpacked tabs array from workspace.\n * Returns the tabs as a plain array, not a proxy.\n */\nconst getUnpackedTabs = (\n  workspace: Workspace & { 'x-scalar-tabs': NonNullable<Workspace['x-scalar-tabs']> },\n): ReturnType<typeof unpackProxyObject<NonNullable<Workspace['x-scalar-tabs']>>> => {\n  return unpackProxyObject(workspace['x-scalar-tabs']!, { depth: TAB_UNPACK_DEPTH })\n}\n\n/**\n * Helper to get the current active tab index.\n * Defaults to 0 if not set.\n */\nconst getActiveIndex = (workspace: Workspace): number => {\n  return workspace['x-scalar-active-tab'] ?? 0\n}\n\n/**\n * Updates the tabs and active tab index in the workspace.\n * This is used for bulk updates when synchronizing state.\n */\nexport const updateTabs = (workspace: Workspace | null, payload: TabEvents['tabs:update:tabs']): void => {\n  if (!workspace) {\n    return\n  }\n\n  if (payload['x-scalar-tabs']) {\n    workspace['x-scalar-tabs'] = payload['x-scalar-tabs']\n  }\n\n  if (payload['x-scalar-active-tab'] !== undefined) {\n    workspace['x-scalar-active-tab'] = payload['x-scalar-active-tab']\n  }\n}\n\n/**\n * Adds a new tab by duplicating the currently active tab.\n * This preserves the user's context when opening a new tab.\n */\nexport const addTab = (workspace: Workspace | null, _payload: TabEvents['tabs:add:tab']): boolean => {\n  if (!hasValidTabs(workspace)) {\n    return false\n  }\n\n  const tabs = getUnpackedTabs(workspace)\n  const activeIndex = getActiveIndex(workspace)\n  const currentTab = tabs[activeIndex]\n\n  if (!currentTab) {\n    return false\n  }\n\n  const newTabs = [...tabs, { ...currentTab }]\n\n  workspace['x-scalar-tabs'] = newTabs\n  workspace['x-scalar-active-tab'] = newTabs.length - 1\n  return true\n}\n\n/**\n * Closes the currently active tab.\n * Prevents closing if only one tab remains, to ensure the user always has a tab open.\n * Adjusts the active index if needed to keep it in bounds.\n */\nexport const closeTab = (workspace: Workspace | null, payload: TabEvents['tabs:close:tab']): boolean => {\n  const getInputIndex = (): number => {\n    if ('event' in payload) {\n      return payload.event.code.startsWith('Digit') ? Number.parseInt(payload.event.key, 10) - 1 : Number.NaN\n    }\n    return payload.index\n  }\n\n  if (!hasValidTabs(workspace)) {\n    return false\n  }\n\n  const index = getInputIndex()\n  const filteredTabs = getUnpackedTabs(workspace).filter((_, i) => i !== index)\n\n  if (filteredTabs.length <= 0) {\n    return false\n  }\n\n  workspace['x-scalar-tabs'] = filteredTabs\n\n  /**\n   * If we closed a tab at the end, the active index needs to move back.\n   * This ensures the active tab stays within bounds after removal.\n   */\n  if (index >= filteredTabs.length) {\n    workspace['x-scalar-active-tab'] = filteredTabs.length - 1\n  }\n\n  return true\n}\n\n/**\n * Closes all other tabs except the one at the given index\n */\nexport const closeOtherTabs = (workspace: Workspace | null, payload: TabEvents['tabs:close:other-tabs']): boolean => {\n  if (!hasValidTabs(workspace)) {\n    return false\n  }\n\n  const tabs = getUnpackedTabs(workspace)\n\n  if (tabs.length <= 1) {\n    return false\n  }\n\n  workspace['x-scalar-tabs'] = tabs.filter((_, index) => index === payload.index)\n  // set the active tab to the first tab since we closed all other tabs\n  workspace['x-scalar-active-tab'] = 0\n  return true\n}\n\n/**\n * Navigates to the previous tab in the list.\n * Does nothing if already at the first tab.\n */\nexport const navigatePreviousTab = (\n  workspace: Workspace | null,\n  _payload: TabEvents['tabs:navigate:previous'],\n): boolean => {\n  if (!hasValidTabs(workspace)) {\n    return false\n  }\n\n  const activeIndex = getActiveIndex(workspace)\n\n  if (activeIndex <= 0) {\n    return false\n  }\n\n  workspace['x-scalar-active-tab'] = activeIndex - 1\n  return true\n}\n\n/**\n * Navigates to the next tab in the list.\n * Does nothing if already at the last tab.\n */\nexport const navigateNextTab = (workspace: Workspace | null, _payload: TabEvents['tabs:navigate:next']): boolean => {\n  if (!hasValidTabs(workspace)) {\n    return false\n  }\n\n  const tabs = getUnpackedTabs(workspace)\n  const activeIndex = getActiveIndex(workspace)\n\n  if (activeIndex >= tabs.length - 1) {\n    return false\n  }\n\n  workspace['x-scalar-active-tab'] = activeIndex + 1\n  return true\n}\n\n/**\n * Focuses a specific tab based on keyboard number input (1-9).\n * Extracts the digit from the keyboard event and focuses that tab.\n * Tab numbering starts at 1 for user convenience but uses 0-based indexing internally.\n */\nexport const focusTab = (workspace: Workspace | null, payload: TabEvents['tabs:focus:tab']): boolean => {\n  if (!hasValidTabs(workspace)) {\n    return false\n  }\n\n  const getInputIndex = (): number => {\n    if ('event' in payload) {\n      return payload.event.code.startsWith('Digit') ? Number.parseInt(payload.event.key, 10) - 1 : Number.NaN\n    }\n    return payload.index\n  }\n\n  const tabs = getUnpackedTabs(workspace)\n\n  const newActiveIndex = getInputIndex()\n\n  if (Number.isNaN(newActiveIndex) || newActiveIndex < 0 || newActiveIndex >= tabs.length) {\n    return false\n  }\n\n  workspace['x-scalar-active-tab'] = newActiveIndex\n  return true\n}\n\n/**\n * Focuses the last tab in the list.\n * This provides a quick way to jump to the end, regardless of how many tabs exist.\n */\nexport const focusLastTab = (workspace: Workspace | null, _payload: TabEvents['tabs:focus:tab-last']): boolean => {\n  if (!hasValidTabs(workspace)) {\n    return false\n  }\n\n  const tabs = getUnpackedTabs(workspace)\n\n  if (tabs.length <= 1) {\n    return false\n  }\n\n  workspace['x-scalar-active-tab'] = tabs.length - 1\n  return true\n}\n\nexport const tabsMutatorsFactory = ({ workspace }: { workspace: Workspace | null }) => {\n  return {\n    updateTabs: (payload: TabEvents['tabs:update:tabs']) => updateTabs(workspace, payload),\n    addTab: (payload: TabEvents['tabs:add:tab']) => addTab(workspace, payload),\n    closeTab: (payload: TabEvents['tabs:close:tab']) => closeTab(workspace, payload),\n    closeOtherTabs: (payload: TabEvents['tabs:close:other-tabs']) => closeOtherTabs(workspace, payload),\n    navigatePreviousTab: (payload: TabEvents['tabs:navigate:previous']) => navigatePreviousTab(workspace, payload),\n    navigateNextTab: (payload: TabEvents['tabs:navigate:next']) => navigateNextTab(workspace, payload),\n    focusTab: (payload: TabEvents['tabs:focus:tab']) => focusTab(workspace, payload),\n    focusLastTab: (payload: TabEvents['tabs:focus:tab-last']) => focusLastTab(workspace, payload),\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
