{
  "version": 3,
  "sources": ["../../src/mutators/fetch-response-to-har.ts"],
  "sourcesContent": ["import type { HarResponse } from '@scalar/snippetz'\n\ntype FetchResponseToHarProps = {\n  /** The Fetch API Response object to convert */\n  response: Response\n  /**\n   * Whether to include the response body in the HAR content.\n   * Note: Reading the body consumes it, so the response will be cloned automatically.\n   * Bodies will only be included if they meet the following criteria:\n   * - Not a streaming response (text/event-stream)\n   * - Text-based content (not binary)\n   * - Under 1MB in size\n   * @default true\n   */\n  includeBody?: boolean\n  /**\n   * HTTP version string to use (since Fetch API does not expose this)\n   * @default 'HTTP/1.1'\n   */\n  httpVersion?: string\n  /**\n   * The maximum size of the response body to include in the HAR content.\n   * @default 1MB\n   */\n  bodySizeLimit?: number\n}\n\n/**\n * Converts a Fetch API Response object to HAR (HTTP Archive) Response format.\n *\n * This function transforms a standard JavaScript Fetch API Response into the\n * HAR format, which is useful for:\n * - Recording HTTP responses for replay or analysis\n * - Creating test fixtures from real API responses\n * - Debugging and monitoring HTTP traffic\n * - Generating API documentation from real responses\n *\n * The conversion handles:\n * - Response status and status text\n * - Headers extraction (including Set-Cookie headers converted to cookies)\n * - Response body reading (with automatic cloning to preserve the original)\n * - Content-Type detection and MIME type extraction\n * - Size calculations for headers and body\n * - Redirect URL extraction from Location header\n *\n * Note: The Fetch API does not expose the HTTP version, so it defaults to HTTP/1.1\n * unless specified otherwise.\n *\n * @see https://w3c.github.io/web-performance/specs/HAR/Overview.html\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Response\n *\n * @example\n * const response = await fetch('https://api.example.com/users')\n * const harResponse = await fetchResponseToHar({ response })\n * console.log(harResponse.status) // 200\n */\nexport const fetchResponseToHar = async ({\n  response,\n  includeBody = true,\n  httpVersion = 'HTTP/1.1',\n  bodySizeLimit = 1048576,\n}: FetchResponseToHarProps): Promise<HarResponse> => {\n  // Extract the headers from the response\n  const { headers, headersSize, cookies } = processResponseHeaders(response)\n\n  // Extract redirect URL from Location header\n  const redirectURL = response.headers.get('location') || ''\n\n  // Get content type\n  const contentType = response.headers.get('content-type') ?? 'text/plain'\n\n  // Read the response body if requested\n  const bodyDetails = await (async () => {\n    if (includeBody && response.body) {\n      const details = await processResponseBody(response.clone())\n      if (details.size <= bodySizeLimit) {\n        return details\n      }\n    }\n    return { text: '', size: -1, encoding: undefined }\n  })()\n\n  // Create the HAR response object\n  const harResponse: HarResponse = {\n    status: response.status,\n    statusText: response.statusText,\n    httpVersion,\n    headers,\n    cookies,\n    content: {\n      size: bodyDetails.size,\n      mimeType: contentType,\n      text: bodyDetails.text,\n      encoding: bodyDetails.encoding,\n    },\n    redirectURL,\n    headersSize,\n    bodySize: bodyDetails.size,\n  }\n\n  return harResponse\n}\n\nconst processResponseHeaders = (response: Response) => {\n  return Array.from(response.headers.entries()).reduce<{\n    headers: { name: string; value: string }[]\n    headersSize: number\n    cookies: { name: string; value: string }[]\n  }>(\n    (acc, [name, value]) => {\n      acc.headers.push({ name, value })\n      acc.headersSize += name.length + 2 + value.length + 2\n\n      // Parse Set-Cookie headers into cookies array\n      if (name.toLowerCase() === 'set-cookie') {\n        const cookie = parseSetCookieHeader(value)\n        if (cookie) {\n          acc.cookies.push(cookie)\n        }\n      }\n\n      return acc\n    },\n    { headers: [], headersSize: 0, cookies: [] },\n  )\n}\n\nconst processResponseBody = async (response: Response) => {\n  const contentType = response.headers.get('content-type')\n  if (!contentType || !isTextBasedContent(contentType)) {\n    return { text: '', size: -1, encoding: undefined }\n  }\n\n  try {\n    // Read as ArrayBuffer to get the size\n    const arrayBuffer = await response.arrayBuffer()\n    const bodySize = arrayBuffer.byteLength\n    const text = new TextDecoder('utf-8').decode(arrayBuffer)\n    return { text, size: bodySize, encoding: undefined }\n  } catch {\n    // If body cannot be read, leave it empty\n    return { text: '', size: -1, encoding: undefined }\n  }\n}\n\n/**\n * Checks if the content type is text-based and should be included in HAR.\n * Text-based content types include:\n * - text/* (text/plain, text/html, text/css, etc.)\n * - application/json\n * - application/xml and text/xml\n * - application/javascript\n * - application/*+json and application/*+xml variants\n */\nexport const isTextBasedContent = (contentType: string): boolean => {\n  const lowerContentType = contentType.toLowerCase()\n\n  // Check for text/* types\n  if (lowerContentType.startsWith('text/')) {\n    return true\n  }\n\n  // Check for JSON types\n  if (lowerContentType.includes('application/json') || lowerContentType.includes('+json')) {\n    return true\n  }\n\n  // Check for XML types\n  if (\n    lowerContentType.includes('application/xml') ||\n    lowerContentType.includes('text/xml') ||\n    lowerContentType.includes('+xml')\n  ) {\n    return true\n  }\n\n  // Check for JavaScript\n  if (lowerContentType.includes('application/javascript') || lowerContentType.includes('application/x-javascript')) {\n    return true\n  }\n\n  // Check for common text-based formats\n  if (\n    lowerContentType.includes('application/x-www-form-urlencoded') ||\n    lowerContentType.includes('application/graphql')\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Parses a Set-Cookie header value into a cookie object.\n * This is a simplified parser that extracts the name and value.\n * For full cookie parsing with attributes, a more robust parser would be needed.\n */\nconst parseSetCookieHeader = (setCookieValue: string): { name: string; value: string } | null => {\n  // Set-Cookie format: name=value; attribute1=value1; attribute2=value2\n  const parts = setCookieValue.split(';')\n  if (parts.length === 0 || !parts[0]) {\n    return null\n  }\n\n  const cookiePart = parts[0].trim()\n  const equalIndex = cookiePart.indexOf('=')\n\n  if (equalIndex === -1) {\n    return null\n  }\n\n  const name = cookiePart.substring(0, equalIndex).trim()\n  const value = cookiePart.substring(equalIndex + 1).trim()\n\n  return { name, value }\n}\n"],
  "mappings": "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",
  "names": []
}
