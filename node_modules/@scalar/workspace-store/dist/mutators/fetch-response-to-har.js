const fetchResponseToHar = async ({
  response,
  includeBody = true,
  httpVersion = "HTTP/1.1",
  bodySizeLimit = 1048576
}) => {
  const { headers, headersSize, cookies } = processResponseHeaders(response);
  const redirectURL = response.headers.get("location") || "";
  const contentType = response.headers.get("content-type") ?? "text/plain";
  const bodyDetails = await (async () => {
    if (includeBody && response.body) {
      const details = await processResponseBody(response.clone());
      if (details.size <= bodySizeLimit) {
        return details;
      }
    }
    return { text: "", size: -1, encoding: void 0 };
  })();
  const harResponse = {
    status: response.status,
    statusText: response.statusText,
    httpVersion,
    headers,
    cookies,
    content: {
      size: bodyDetails.size,
      mimeType: contentType,
      text: bodyDetails.text,
      encoding: bodyDetails.encoding
    },
    redirectURL,
    headersSize,
    bodySize: bodyDetails.size
  };
  return harResponse;
};
const processResponseHeaders = (response) => {
  return Array.from(response.headers.entries()).reduce(
    (acc, [name, value]) => {
      acc.headers.push({ name, value });
      acc.headersSize += name.length + 2 + value.length + 2;
      if (name.toLowerCase() === "set-cookie") {
        const cookie = parseSetCookieHeader(value);
        if (cookie) {
          acc.cookies.push(cookie);
        }
      }
      return acc;
    },
    { headers: [], headersSize: 0, cookies: [] }
  );
};
const processResponseBody = async (response) => {
  const contentType = response.headers.get("content-type");
  if (!contentType || !isTextBasedContent(contentType)) {
    return { text: "", size: -1, encoding: void 0 };
  }
  try {
    const arrayBuffer = await response.arrayBuffer();
    const bodySize = arrayBuffer.byteLength;
    const text = new TextDecoder("utf-8").decode(arrayBuffer);
    return { text, size: bodySize, encoding: void 0 };
  } catch {
    return { text: "", size: -1, encoding: void 0 };
  }
};
const isTextBasedContent = (contentType) => {
  const lowerContentType = contentType.toLowerCase();
  if (lowerContentType.startsWith("text/")) {
    return true;
  }
  if (lowerContentType.includes("application/json") || lowerContentType.includes("+json")) {
    return true;
  }
  if (lowerContentType.includes("application/xml") || lowerContentType.includes("text/xml") || lowerContentType.includes("+xml")) {
    return true;
  }
  if (lowerContentType.includes("application/javascript") || lowerContentType.includes("application/x-javascript")) {
    return true;
  }
  if (lowerContentType.includes("application/x-www-form-urlencoded") || lowerContentType.includes("application/graphql")) {
    return true;
  }
  return false;
};
const parseSetCookieHeader = (setCookieValue) => {
  const parts = setCookieValue.split(";");
  if (parts.length === 0 || !parts[0]) {
    return null;
  }
  const cookiePart = parts[0].trim();
  const equalIndex = cookiePart.indexOf("=");
  if (equalIndex === -1) {
    return null;
  }
  const name = cookiePart.substring(0, equalIndex).trim();
  const value = cookiePart.substring(equalIndex + 1).trim();
  return { name, value };
};
export {
  fetchResponseToHar,
  isTextBasedContent
};
//# sourceMappingURL=fetch-response-to-har.js.map
