{
  "version": 3,
  "sources": ["../../src/mutators/operation.ts"],
  "sourcesContent": ["import type { HttpMethod } from '@scalar/helpers/http/http-methods'\nimport { isHttpMethod } from '@scalar/helpers/http/is-http-method'\nimport { preventPollution } from '@scalar/helpers/object/prevent-pollution'\nimport { findVariables } from '@scalar/helpers/regex/find-variables'\n\nimport type { WorkspaceStore } from '@/client'\nimport type { HooksEvents } from '@/events/definitions/hooks'\nimport type { OperationEvents } from '@/events/definitions/operation'\nimport { getResolvedRef } from '@/helpers/get-resolved-ref'\nimport { unpackProxyObject } from '@/helpers/unpack-proxy'\nimport { fetchRequestToHar } from '@/mutators/fetch-request-to-har'\nimport { fetchResponseToHar } from '@/mutators/fetch-response-to-har'\nimport { harToOperation } from '@/mutators/har-to-operation'\nimport { getOpenapiObject, getOperationEntries } from '@/navigation'\nimport { getNavigationOptions } from '@/navigation/get-navigation-options'\nimport { canHaveOrder } from '@/navigation/helpers/get-openapi-object'\nimport type { WorkspaceDocument } from '@/schemas'\nimport type { DisableParametersConfig } from '@/schemas/extensions/operation/x-scalar-disable-parameters'\nimport type { IdGenerator, TraversedOperation, TraversedWebhook, WithParent } from '@/schemas/navigation'\nimport type { ExampleObject, OperationObject, ParameterObject } from '@/schemas/v3.1/strict/openapi-document'\nimport type { ReferenceType } from '@/schemas/v3.1/strict/reference'\nimport { isContentTypeParameterObject } from '@/schemas/v3.1/strict/type-guards'\n\n/** ------------------------------------------------------------------------------------------------\n * Helper Functions for Path Parameter Synchronization\n * ------------------------------------------------------------------------------------------------ */\n\n/**\n * Creates a map of parameter names to their character positions in a path.\n * Used to detect renamed path parameters by position matching.\n */\nconst getParameterPositions = (path: string, parameters: readonly string[]): Record<string, number> => {\n  const positions: Record<string, number> = {}\n\n  for (const paramName of parameters) {\n    const position = path.indexOf(`{${paramName}}`)\n    if (position !== -1) {\n      positions[paramName] = position\n    }\n  }\n\n  return positions\n}\n\n/**\n * Syncs path parameters when the path changes.\n *\n * Preserves parameter configurations by:\n * 1. Keeping parameters with matching names\n * 2. Renaming parameters at the same position\n * 3. Creating new parameters with empty examples\n * 4. Removing parameters that no longer exist in the new path\n */\nconst syncParametersForPathChange = (\n  newPath: string,\n  oldPath: string,\n  existingParameters: ReferenceType<ParameterObject>[],\n): ReferenceType<ParameterObject>[] => {\n  // Extract path parameter names from both paths\n  const oldPathParams = findVariables(oldPath, { includePath: true, includeEnv: false }).filter(\n    (v): v is string => v !== undefined,\n  )\n  const newPathParams = findVariables(newPath, { includePath: true, includeEnv: false }).filter(\n    (v): v is string => v !== undefined,\n  )\n\n  const oldPositions = getParameterPositions(oldPath, oldPathParams)\n  const newPositions = getParameterPositions(newPath, newPathParams)\n\n  // Separate path and non-path parameters, resolving each parameter only once\n  const pathParameters: ParameterObject[] = []\n  const nonPathParameters: ReferenceType<ParameterObject>[] = []\n\n  for (const param of existingParameters) {\n    const resolved = getResolvedRef(param)\n    if (resolved?.in === 'path') {\n      pathParameters.push(resolved)\n    } else {\n      nonPathParameters.push(param)\n    }\n  }\n\n  // Create a map of existing path parameters by name for quick lookup\n  const existingPathParamsByName = new Map<string, ParameterObject>()\n  for (const param of pathParameters) {\n    if (param.name) {\n      existingPathParamsByName.set(param.name, param)\n    }\n  }\n\n  const usedOldParams = new Set<string>()\n  const syncedPathParameters: ReferenceType<ParameterObject>[] = []\n\n  for (const newParamName of newPathParams) {\n    // Case 1: Parameter with same name exists - preserve its config\n    if (existingPathParamsByName.has(newParamName)) {\n      syncedPathParameters.push(existingPathParamsByName.get(newParamName)!)\n      usedOldParams.add(newParamName)\n      continue\n    }\n\n    // Case 2: Check for parameter at same position (likely a rename)\n    const newParamPosition = newPositions[newParamName]\n    const oldParamAtPosition = oldPathParams.find(\n      (oldParam) => oldPositions[oldParam] === newParamPosition && !usedOldParams.has(oldParam),\n    )\n\n    // Rename: transfer the old parameter's config to the new name\n    if (oldParamAtPosition && existingPathParamsByName.has(oldParamAtPosition)) {\n      const oldParam = existingPathParamsByName.get(oldParamAtPosition)!\n      oldParam.name = newParamName\n      syncedPathParameters.push(oldParam)\n      usedOldParams.add(oldParamAtPosition)\n      continue\n    }\n\n    // Case 3: New parameter - create with empty examples\n    syncedPathParameters.push({\n      name: newParamName,\n      in: 'path',\n    })\n  }\n\n  // Return all parameters: synced path parameters + preserved non-path parameters\n  return unpackProxyObject([...syncedPathParameters, ...nonPathParameters], { depth: 1 })\n}\n\n/**\n * Creates a new operation at a specific path and method in the document.\n * Automatically normalizes the path to ensure it starts with a slash.\n *\n * Returns the normalized path if successful, undefined otherwise.\n *\n * Example:\n * ```ts\n * createOperation(\n *   document,\n *   'users',\n *   'get',\n *   { tags: ['Users'] },\n * )\n * ```\n */\nexport const createOperation = (\n  workspaceStore: WorkspaceStore | null,\n  payload: OperationEvents['operation:create:operation'],\n): string | undefined => {\n  const document = workspaceStore?.workspace.documents[payload.documentName]\n  if (!document) {\n    payload.callback?.(false)\n    return undefined\n  }\n\n  const { path, method, operation } = payload\n\n  /** Ensure the path starts with a slash */\n  const normalizedPath = path.startsWith('/') ? path : `/${path}`\n\n  /** Create the operation in the document */\n  if (!document.paths) {\n    document.paths = {}\n  }\n\n  if (!document.paths[normalizedPath]) {\n    document.paths[normalizedPath] = {}\n  }\n\n  /** Prevent pollution of the path and method */\n  preventPollution(normalizedPath)\n  preventPollution(method)\n\n  /** Create the operation in the document */\n  document.paths[normalizedPath][method] = operation\n\n  // Make sure that we are selecting the new operation server\n  const { servers } = operation\n  const firstServer = unpackProxyObject(servers?.[0])\n\n  // For now we only support document servers but in the future we might support operation servers\n  for (const server of servers ?? []) {\n    // If the server does not exist in the document, add it\n    if (!document.servers?.some((s) => s.url === server.url)) {\n      if (!document.servers) {\n        document.servers = []\n      }\n      document.servers.push(unpackProxyObject(server))\n    }\n  }\n\n  // Update the selected server to the first server of the created operation\n  if (firstServer) {\n    document['x-scalar-selected-server'] = firstServer.url\n  }\n\n  payload.callback?.(true)\n  return normalizedPath\n}\n\n/**\n * Updates the `summary` of an operation.\n * Safely no-ops if the document or operation does not exist.\n *\n * Example:\n * ```ts\n * updateOperationSummary(\n *   document,\n *   {\n *   meta: { method: 'get', path: '/users/{id}' },\n *   payload: { summary: 'Get a single user' },\n * })\n * ```\n */\nexport const updateOperationSummary = (\n  document: WorkspaceDocument | null,\n  { meta, payload: { summary } }: OperationEvents['operation:update:summary'],\n) => {\n  if (!document) {\n    return\n  }\n\n  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method as HttpMethod])\n  if (!operation) {\n    return\n  }\n\n  operation.summary = summary\n}\n\n/**\n * Updates the order ID of an operation in the sidebar.\n * Used when changing path or method so we do not lose the sidebar ordering\n */\nconst updateOperationOrderId = ({\n  store,\n  operation,\n  generateId,\n  method,\n  path,\n  entries,\n}: {\n  store: WorkspaceStore\n  operation: OperationObject\n  generateId: IdGenerator\n  method: HttpMethod\n  path: string\n  entries: (WithParent<TraversedOperation> | WithParent<TraversedWebhook>)[]\n}) => {\n  // Loop over the entries and replace the ID in the x-scalar-order with the new ID\n  entries?.forEach((entry) => {\n    if (!canHaveOrder(entry.parent)) {\n      return\n    }\n\n    // Ensure we have an x-scalar-order property\n    const parentOpenAPIObject = getOpenapiObject({ store, entry: entry.parent })\n    if (!parentOpenAPIObject || !('x-scalar-order' in parentOpenAPIObject)) {\n      return\n    }\n\n    const order = parentOpenAPIObject['x-scalar-order']\n    const index = order?.indexOf(entry.id)\n    if (!Array.isArray(order) || typeof index !== 'number' || index < 0) {\n      return\n    }\n\n    const parentTag =\n      entry.parent.type === 'tag' && 'name' in parentOpenAPIObject\n        ? { tag: parentOpenAPIObject, id: entry.parent.id }\n        : undefined\n\n    // Generate the new ID based on whether this is an operation or webhook\n    order[index] = generateId({\n      type: 'operation',\n      path,\n      method,\n      operation,\n      parentId: entry.parent.id,\n      parentTag,\n    })\n  })\n}\n\n/**\n * Updates the HTTP method and/or path of an operation and moves it to the new location.\n * This function:\n * 1. Moves the operation from the old method/path to the new method/path under paths\n * 2. Updates x-scalar-order to maintain the operation's position in the sidebar\n * 3. Syncs path parameters when the path changes\n *\n * Safely no-ops if nothing has changed, or if the document or operation does not exist.\n *\n * Example:\n * ```ts\n * updateOperationPathMethod({\n *   document,\n *   store,\n *   meta: { method: 'get', path: '/users' },\n *   payload: { method: 'post', path: '/api/users' },\n * })\n * ```\n */\nexport const updateOperationPathMethod = (\n  document: WorkspaceDocument | null,\n  store: WorkspaceStore | null,\n  { meta, payload: { method, path }, callback }: OperationEvents['operation:update:pathMethod'],\n): void => {\n  const methodChanged = meta.method !== method\n  const pathChanged = meta.path !== path\n\n  // If nothing has changed, no need to do anything\n  if (!methodChanged && !pathChanged) {\n    callback('no-change')\n    return\n  }\n\n  // Determine the final method and path\n  const finalMethod = methodChanged ? method : meta.method\n  const finalPath = pathChanged ? path : meta.path\n\n  // Check for conflicts at the target location\n  if (document?.paths?.[finalPath]?.[finalMethod as HttpMethod]) {\n    callback('conflict')\n    return\n  }\n\n  const documentNavigation = document?.['x-scalar-navigation']\n  if (!documentNavigation || !store) {\n    console.error('Document or workspace not found', { document })\n    return\n  }\n\n  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method as HttpMethod])\n  if (!operation) {\n    console.error('Operation not found', { meta, document })\n    return\n  }\n\n  // Sync path parameters if the path has changed\n  if (pathChanged) {\n    const oldPathParams = findVariables(meta.path, { includePath: true, includeEnv: false }).filter(\n      (v): v is string => v !== undefined,\n    )\n    const newPathParams = findVariables(finalPath, { includePath: true, includeEnv: false }).filter(\n      (v): v is string => v !== undefined,\n    )\n\n    if (oldPathParams.length > 0 || newPathParams.length > 0) {\n      const existingParameters = operation.parameters ?? []\n      operation.parameters = syncParametersForPathChange(finalPath, meta.path, existingParameters)\n    }\n  }\n\n  /**\n   * We don't pass navigation options as we don't have config on the client,\n   * and we don't change path or method on the references\n   */\n  const { generateId } = getNavigationOptions(documentNavigation.name)\n\n  /** Grabs all of the current operation entries for the given path and method */\n  const operationEntriesMap = getOperationEntries(documentNavigation)\n  const entries = operationEntriesMap.get(`${meta.path}|${meta.method}`)\n\n  // Updates the order ID so we don't lose the sidebar ordering when it rebuilds\n  if (entries) {\n    updateOperationOrderId({ store, operation, generateId, method: finalMethod, path: finalPath, entries })\n  }\n\n  // Initialize the paths object if it does not exist\n  if (!document.paths) {\n    document.paths = {}\n  }\n\n  // Initialize the new path if it does not exist\n  if (!document.paths[finalPath]) {\n    document.paths[finalPath] = {}\n  }\n\n  // Prevent assigning dangerous keys to the path items object\n  preventPollution(finalPath)\n  preventPollution(meta.path)\n  preventPollution(finalMethod)\n\n  // Move the operation to the new location\n  document.paths[finalPath][finalMethod] = unpackProxyObject(operation)\n\n  // Remove the operation from the old location\n  const oldPathItems = document.paths[meta.path]\n  if (oldPathItems && isHttpMethod(meta.method)) {\n    delete oldPathItems[meta.method]\n\n    // If the old path has no more operations, remove the path entry\n    if (Object.keys(oldPathItems).length === 0) {\n      delete document.paths[meta.path]\n    }\n  }\n\n  // We need to reset the history for the operation when the path or method changes\n  delete operation['x-scalar-history']\n\n  callback('success')\n}\n\n/**\n * Deletes an operation from the workspace\n *\n * Example:\n * ```ts\n * deleteOperation({\n *   document,\n *   meta: { method: 'get', path: '/users' },\n * })\n * ```\n */\nexport const deleteOperation = (\n  workspace: WorkspaceStore | null,\n  { meta, documentName }: OperationEvents['operation:delete:operation'],\n) => {\n  const document = workspace?.workspace.documents[documentName]\n  if (!document) {\n    return\n  }\n\n  preventPollution(meta.path)\n  preventPollution(meta.method)\n\n  delete document.paths?.[meta.path]?.[meta.method]\n\n  // If the path has no more operations, remove the path entry\n  if (Object.keys(document.paths?.[meta.path] ?? {}).length === 0) {\n    delete document.paths?.[meta.path]\n  }\n}\n\n/**\n * Deletes an example with the given exampleKey from operation parameters and request body.\n *\n * - Finds the target operation within the specified document and path/method.\n * - Removes example values matching exampleKey from both parameter-level and content-level examples.\n * - Safely no-ops if the document, operation, or request body does not exist.\n */\nexport const deleteOperationExample = (\n  workspace: WorkspaceStore | null,\n  { meta: { path, method, exampleKey }, documentName }: OperationEvents['operation:delete:example'],\n) => {\n  // Find the document in workspace based on documentName\n  const document = workspace?.workspace.documents[documentName]\n  if (!document) {\n    return\n  }\n\n  // Get the operation object for the given path and method\n  const operation = getResolvedRef(document.paths?.[path]?.[method])\n  if (!operation) {\n    return\n  }\n\n  // Remove the example from all operation parameters\n  operation.parameters?.forEach((parameter) => {\n    const resolvedParameter = getResolvedRef(parameter)\n\n    // Remove from content-level examples (if parameter uses content)\n    if ('content' in resolvedParameter && resolvedParameter.content) {\n      Object.values(resolvedParameter.content).forEach((mediaType) => {\n        delete mediaType.examples?.[exampleKey]\n      })\n    }\n\n    // Remove from parameter-level examples\n    if ('examples' in resolvedParameter && resolvedParameter.examples) {\n      delete resolvedParameter.examples?.[exampleKey]\n    }\n  })\n\n  // Remove the example from request body content types (if requestBody exists)\n  const requestBody = getResolvedRef(operation.requestBody)\n  if (!requestBody) {\n    return\n  }\n\n  // For each media type, remove the example matching exampleKey\n  Object.values(requestBody.content ?? {}).forEach((mediaType) => {\n    delete mediaType.examples?.[exampleKey]\n  })\n}\n\n/** ------------------------------------------------------------------------------------------------\n * Operation Parameters Mutators\n * ------------------------------------------------------------------------------------------------ */\n\n/**\n * Updates an existing parameter of a given `type` by its index within that\n * type subset (e.g. the N-th query parameter). Supports updating name, value,\n * and enabled state for the targeted example.\n * Safely no-ops if the document, operation, or parameter does not exist.\n *\n * Example:\n * ```ts\n * updateOperationParameter({\n *   document,\n *   type: 'query',\n *   index: 0,\n *   meta: { method: 'get', path: '/search', exampleKey: 'default' },\n *   payload: { value: 'alice', isDisabled: false },\n * })\n * ```\n */\nexport const upsertOperationParameter = (\n  document: WorkspaceDocument | null,\n  { meta, type, payload, originalParameter }: OperationEvents['operation:upsert:parameter'],\n) => {\n  // We are editing an existing parameter\n  if (originalParameter) {\n    originalParameter.name = payload.name\n\n    if (isContentTypeParameterObject(originalParameter)) {\n      // TODO: handle content-type parameters\n      return\n    }\n\n    if (!originalParameter.examples) {\n      originalParameter.examples = {}\n    }\n\n    // Create the example if it doesn't exist\n    originalParameter.examples[meta.exampleKey] ||= {}\n    const example = getResolvedRef(originalParameter.examples[meta.exampleKey])!\n\n    // Update the example value and disabled state\n    example.value = payload.value\n    example['x-disabled'] = payload.isDisabled\n    return\n  }\n\n  // We are adding a new parameter\n  const operation = getResolvedRef(document?.paths?.[meta.path]?.[meta.method])\n  if (!operation) {\n    console.error('Operation not found', { meta, document })\n    return\n  }\n\n  operation.parameters ||= []\n  operation.parameters.push({\n    name: payload.name,\n    in: type,\n    required: type === 'path' ? true : false,\n    examples: {\n      [meta.exampleKey]: {\n        value: payload.value,\n        // We always want a new parameter to be enabled by default\n        'x-disabled': false,\n      },\n    },\n  })\n  return\n}\n\n/**\n * Updates the disabled state of a default parameter for an operation.\n * Default parameters are inherited from higher-level configurations (like collection or server defaults)\n * and this allows individual operations to selectively disable them without removing them entirely.\n *\n * The disabled state is stored in the `x-scalar-disable-parameters` extension object, organized by\n * parameter type and example key. Missing objects are initialized automatically.\n *\n * @param document - The current workspace document\n * @param type - The parameter type (e.g., 'header'). Determines the storage key ('default-headers' for headers)\n * @param meta.path - Path of the operation (e.g., '/users')\n * @param meta.method - HTTP method of the operation (e.g., 'get')\n * @param meta.exampleKey - Key identifying the relevant example\n * @param meta.key - The specific parameter key being updated\n * @param payload.isDisabled - Whether the parameter should be disabled\n */\nexport const updateOperationExtraParameters = (\n  document: WorkspaceDocument | null,\n  { type, meta, payload, in: location }: OperationEvents['operation:update:extra-parameters'],\n) => {\n  type Type = OperationEvents['operation:update:extra-parameters']['type']\n  type In = OperationEvents['operation:update:extra-parameters']['in']\n\n  // Ensure there's a valid document\n  if (!document) {\n    return\n  }\n\n  // Resolve the referenced operation from the document using the path and method\n  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method])\n  if (!operation) {\n    return\n  }\n\n  // Initialize the 'x-scalar-disable-parameters' object if it doesn't exist\n  if (!operation['x-scalar-disable-parameters']) {\n    operation['x-scalar-disable-parameters'] = {}\n  }\n\n  /**\n   * Maps parameter type and location to the corresponding config key.\n   * Only valid combinations are defined here.\n   */\n  const mapping: Partial<Record<Type, Partial<Record<In, keyof DisableParametersConfig>>>> = {\n    global: { cookie: 'global-cookies' },\n    default: { header: 'default-headers' },\n  }\n\n  const key = mapping[type]?.[location]\n\n  if (!key) {\n    return\n  }\n\n  // Initialize the 'default-headers' object within 'x-scalar-disable-parameters' if it doesn't exist\n  if (!operation['x-scalar-disable-parameters'][key]) {\n    operation['x-scalar-disable-parameters'][key] = {}\n  }\n\n  // Update (or create) the entry for the specific example and key, preserving any existing settings\n  operation['x-scalar-disable-parameters'][key][meta.exampleKey] = {\n    ...(operation['x-scalar-disable-parameters'][key][meta.exampleKey] ?? {}),\n    [meta.name]: payload.isDisabled ?? false,\n  }\n}\n\n/**\n * Removes a parameter from the operation OR path\n *\n * Example:\n * ```ts\n * deleteOperationParameter({\n *   document,\n *   originalParameter,\n *   meta: { method: 'get', path: '/users', exampleKey: 'default' },\n * })\n * ```\n */\nexport const deleteOperationParameter = (\n  document: WorkspaceDocument | null,\n  { meta, originalParameter }: OperationEvents['operation:delete:parameter'],\n) => {\n  const operation = getResolvedRef(document?.paths?.[meta.path]?.[meta.method])\n\n  // Lets check if its on the operation first as its more likely\n  const operationIndex = operation?.parameters?.findIndex((it) => getResolvedRef(it) === originalParameter) ?? -1\n\n  // We cannot call splice on a proxy object, so we unwrap the array and filter it\n  if (operation && operationIndex >= 0) {\n    operation.parameters = unpackProxyObject(\n      operation.parameters?.filter((_, i) => i !== operationIndex),\n      { depth: 1 },\n    )\n    return\n  }\n\n  // If it wasn't on the operation it might be on the path\n  const path = getResolvedRef(document?.paths?.[meta.path])\n  const pathIndex = path?.parameters?.findIndex((it) => getResolvedRef(it) === originalParameter) ?? -1\n\n  if (path && pathIndex >= 0) {\n    path.parameters = unpackProxyObject(\n      path.parameters?.filter((_, i) => i !== pathIndex),\n      { depth: 1 },\n    )\n  }\n}\n\n/**\n * Deletes all parameters of a given `type` from the operation.\n * Safely no-ops if the document or operation does not exist.\n *\n * Example:\n * ```ts\n * deleteAllOperationParameters({\n *   document,\n *   type: 'cookie',\n *   meta: { method: 'get', path: '/users' },\n * })\n * ```\n */\nexport const deleteAllOperationParameters = (\n  document: WorkspaceDocument | null,\n  { meta, type }: OperationEvents['operation:delete-all:parameters'],\n) => {\n  if (!document) {\n    return\n  }\n\n  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method])\n  if (!operation) {\n    return\n  }\n\n  // Filter out parameters of the specified type\n  operation.parameters = operation.parameters?.filter((it) => getResolvedRef(it).in !== type) ?? []\n}\n\n/** ------------------------------------------------------------------------------------------------\n * Operation Request Body Mutators\n * ------------------------------------------------------------------------------------------------ */\n\n/**\n * Sets the selected request-body content type for the current `exampleKey`.\n * This stores the selection under `x-scalar-selected-content-type` on the\n * resolved requestBody. Safely no-ops if the document or operation does not exist.\n *\n * Example:\n * ```ts\n * updateOperationRequestBodyContentType({\n *   document,\n *   meta: { method: 'post', path: '/upload', exampleKey: 'default' },\n *   payload: { contentType: 'multipart/form-data' },\n * })\n * ```\n */\nexport const updateOperationRequestBodyContentType = (\n  document: WorkspaceDocument | null,\n  { meta, payload }: OperationEvents['operation:update:requestBody:contentType'],\n) => {\n  if (!document) {\n    return\n  }\n\n  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method])\n  if (!operation) {\n    return\n  }\n\n  let requestBody = getResolvedRef(operation.requestBody)\n  if (!requestBody) {\n    operation.requestBody = {\n      content: {},\n    }\n    requestBody = getResolvedRef(operation.requestBody)\n  }\n\n  if (!requestBody!['x-scalar-selected-content-type']) {\n    requestBody!['x-scalar-selected-content-type'] = {}\n  }\n\n  requestBody!['x-scalar-selected-content-type'][meta.exampleKey] = payload.contentType\n}\n\n/** Ensure the json that we need exists up to the example object in the request body */\nconst findOrCreateRequestBodyExample = (\n  document: WorkspaceDocument | null,\n  contentType: string,\n  meta: OperationEvents['operation:update:requestBody:contentType']['meta'],\n): ExampleObject | null => {\n  const operation = getResolvedRef(document?.paths?.[meta.path]?.[meta.method])\n  if (!operation) {\n    return null\n  }\n\n  // Ensure that the request body exists\n  let requestBody = getResolvedRef(operation.requestBody)\n  if (!requestBody) {\n    operation.requestBody = {\n      content: {},\n    }\n    requestBody = getResolvedRef(operation.requestBody)\n  }\n\n  // Ensure that the example exists\n  requestBody.content[contentType] ||= {}\n  requestBody.content[contentType].examples ||= {}\n  requestBody.content[contentType].examples[meta.exampleKey] ||= {}\n\n  const example = getResolvedRef(requestBody.content[contentType].examples?.[meta.exampleKey])\n  return example ?? null\n}\n\n/**\n * Creates or updates a concrete example value for a specific request-body\n * `contentType` and `exampleKey`. Safely no-ops if the document or operation\n * does not exist.\n *\n * Example:\n * ```ts\n * updateOperationRequestBodyExample({\n *   document,\n *   contentType: 'application/json',\n *   meta: { method: 'post', path: '/users', exampleKey: 'default' },\n *   payload: { value: JSON.stringify({ name: 'Ada' }) },\n * })\n * ```\n */\nexport const updateOperationRequestBodyExample = (\n  document: WorkspaceDocument | null,\n  { meta, payload, contentType }: OperationEvents['operation:update:requestBody:value'],\n) => {\n  const example = findOrCreateRequestBodyExample(document, contentType, meta)\n  if (!example) {\n    console.error('Example not found', meta.exampleKey)\n    return\n  }\n\n  example.value = payload\n}\n\n/**\n * Stores the form data for the request body example\n *\n * This needs special handling as we store it as an array of objects with a schema type of object\n */\nexport const updateOperationRequestBodyFormValue = (\n  document: WorkspaceDocument | null,\n  { meta, payload, contentType }: OperationEvents['operation:update:requestBody:formValue'],\n) => {\n  const example = findOrCreateRequestBodyExample(document, contentType, meta)\n  if (!example) {\n    console.error('Example not found', meta.exampleKey)\n    return\n  }\n\n  example.value = unpackProxyObject(payload, { depth: 3 })\n}\n\nconst HISTORY_LIMIT = 5\n\nexport const addResponseToHistory = async (\n  document: WorkspaceDocument | null,\n  { payload, meta }: HooksEvents['hooks:on:request:complete'],\n) => {\n  if (!document || !payload) {\n    return\n  }\n\n  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method])\n  if (!operation) {\n    return\n  }\n\n  const operationParameters = operation.parameters ?? []\n\n  // Get all the variables from the operation parameters\n  const variables = operationParameters.reduce<Record<string, string>>((acc, param) => {\n    const resolvedParam = getResolvedRef(param)\n    if (isContentTypeParameterObject(resolvedParam)) {\n      return acc\n    }\n    if (resolvedParam.in === 'path') {\n      acc[resolvedParam.name] = getResolvedRef(resolvedParam.examples?.[meta.exampleKey])?.value ?? ''\n    }\n    return acc\n  }, {})\n\n  const requestHar = await fetchRequestToHar({ request: payload.request })\n  const responseHar = await fetchResponseToHar({ response: payload.response })\n\n  operation['x-scalar-history'] ||= []\n  // If the history is full, remove the oldest entry\n  if (operation['x-scalar-history'].length >= HISTORY_LIMIT) {\n    // We need to unpack the history array to avoid proxy object issues\n    operation['x-scalar-history'] = unpackProxyObject(\n      operation['x-scalar-history'].filter((_, i) => i !== 0),\n      { depth: 1 },\n    )\n  }\n  // Add the new entry to the history\n  operation['x-scalar-history'].push({\n    response: responseHar,\n    request: requestHar,\n    meta: {\n      example: meta.exampleKey,\n    },\n    time: payload.duration,\n    timestamp: payload.timestamp,\n    requestMetadata: {\n      variables,\n    },\n  })\n}\n\nexport const reloadOperationHistory = (\n  document: WorkspaceDocument | null,\n  { meta, index, callback }: OperationEvents['operation:reload:history'],\n) => {\n  if (!document) {\n    console.error('Document not found', meta.path, meta.method)\n    return\n  }\n\n  const operation = getResolvedRef(document.paths?.[meta.path]?.[meta.method])\n  if (!operation) {\n    console.error('Operation not found', meta.path, meta.method)\n    return\n  }\n\n  const historyItem = operation['x-scalar-history']?.[index]\n  if (!historyItem) {\n    console.error('History item not found', index)\n    return\n  }\n\n  harToOperation({\n    harRequest: historyItem.request,\n    exampleKey: 'draft',\n    baseOperation: operation,\n    pathVariables: historyItem.requestMetadata.variables,\n  })\n  callback('success')\n}\n\nexport const operationMutatorsFactory = ({\n  document,\n  store,\n}: {\n  document: WorkspaceDocument | null\n  store: WorkspaceStore | null\n}) => {\n  return {\n    createOperation: (payload: OperationEvents['operation:create:operation']) => createOperation(store, payload),\n    updateOperationSummary: (payload: OperationEvents['operation:update:summary']) =>\n      updateOperationSummary(document, payload),\n    updateOperationPathMethod: (payload: OperationEvents['operation:update:pathMethod']) =>\n      updateOperationPathMethod(document, store, payload),\n    deleteOperation: (payload: OperationEvents['operation:delete:operation']) => deleteOperation(store, payload),\n    deleteOperationExample: (payload: OperationEvents['operation:delete:example']) =>\n      deleteOperationExample(store, payload),\n    updateOperationExtraParameters: (payload: OperationEvents['operation:update:extra-parameters']) =>\n      updateOperationExtraParameters(document, payload),\n    upsertOperationParameter: (payload: OperationEvents['operation:upsert:parameter']) =>\n      upsertOperationParameter(document, payload),\n    deleteOperationParameter: (payload: OperationEvents['operation:delete:parameter']) =>\n      deleteOperationParameter(document, payload),\n    deleteAllOperationParameters: (payload: OperationEvents['operation:delete-all:parameters']) =>\n      deleteAllOperationParameters(document, payload),\n    updateOperationRequestBodyContentType: (payload: OperationEvents['operation:update:requestBody:contentType']) =>\n      updateOperationRequestBodyContentType(document, payload),\n    updateOperationRequestBodyExample: (payload: OperationEvents['operation:update:requestBody:value']) =>\n      updateOperationRequestBodyExample(document, payload),\n    updateOperationRequestBodyFormValue: (payload: OperationEvents['operation:update:requestBody:formValue']) =>\n      updateOperationRequestBodyFormValue(document, payload),\n    addResponseToHistory: (payload: HooksEvents['hooks:on:request:complete']) =>\n      addResponseToHistory(document, payload),\n    reloadOperationHistory: (payload: OperationEvents['operation:reload:history']) =>\n      reloadOperationHistory(document, payload),\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
