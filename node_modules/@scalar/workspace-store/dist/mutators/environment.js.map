{
  "version": 3,
  "sources": ["../../src/mutators/environment.ts"],
  "sourcesContent": ["import type { EnvironmentEvents } from '@/events/definitions/environment'\nimport type { Workspace, WorkspaceDocument } from '@/schemas'\nimport {\n  type XScalarEnvVar,\n  type XScalarEnvironment,\n  xScalarEnvVarSchema,\n  xScalarEnvironmentSchema,\n} from '@/schemas/extensions/document/x-scalar-environments'\nimport { coerceValue } from '@/schemas/typebox-coerce'\n\ntype Event<T extends keyof EnvironmentEvents> = Omit<EnvironmentEvents[T], 'collectionType'>\n\n/**\n * Adds OR updates an environment to the document or workspace.\n *\n * @param document - current document if available\n * @param workspace - current workspace if available\n * @param environmentName - Name of the environment to add\n * @param payload - The environment configuration to add\n * @param oldEnvironmentName - Only needed when renaming the environment\n * @returns the parsed environment that was added or updated or undefined if the collection is not found\n */\nexport const upsertEnvironment = (\n  workspace: Workspace | null,\n  collection: WorkspaceDocument | Workspace | null,\n  { environmentName, payload, oldEnvironmentName }: Event<'environment:upsert:environment'>,\n): XScalarEnvironment | undefined => {\n  /** Discriminating between document and workspace */\n  if (!collection || !workspace) {\n    return\n  }\n\n  if (!collection['x-scalar-environments']) {\n    collection['x-scalar-environments'] = {}\n  }\n\n  // Check if this is a new environment before we create it\n  const isNewEnvironment = !collection['x-scalar-environments'][oldEnvironmentName ?? environmentName]\n\n  // Ensure we parse the payload but keep the old variables\n  const parsed = coerceValue(xScalarEnvironmentSchema, {\n    ...collection['x-scalar-environments'][oldEnvironmentName ?? environmentName],\n    ...payload,\n  })\n  collection['x-scalar-environments'][environmentName] = parsed\n\n  // If we are renaming the environment, we need to delete the old one\n  if (oldEnvironmentName && oldEnvironmentName !== environmentName) {\n    delete collection['x-scalar-environments'][oldEnvironmentName]\n\n    // If the old environment was active, we need to set the new environment as active\n    if (workspace['x-scalar-active-environment'] === oldEnvironmentName) {\n      workspace['x-scalar-active-environment'] = environmentName\n    }\n  }\n\n  // Set the newly created workspace environment as active\n  if (isNewEnvironment) {\n    workspace['x-scalar-active-environment'] = environmentName\n  }\n\n  return parsed\n}\n\nexport const deleteEnvironment = (\n  workspace: Workspace | null,\n  collection: WorkspaceDocument | Workspace | null,\n  { environmentName }: Event<'environment:delete:environment'>,\n) => {\n  if (!collection || !workspace) {\n    return\n  }\n\n  delete collection['x-scalar-environments']?.[environmentName]\n}\n\n/**\n * Adds OR updates an environment variable to the document or workspace.\n *\n * @param collection - Workspace OR document\n * @param environmentName - Name of the environment to add the variable to\n * @param variableName - Name of the variable to add\n * @param value - Value of the variable to add\n * @returns the parsed variable that was added or updated or undefined if the collection is not found\n */\nexport const upsertEnvironmentVariable = (\n  collection: WorkspaceDocument | Workspace | null,\n  { environmentName, variable, index }: Event<'environment:upsert:environment-variable'>,\n): XScalarEnvVar | undefined => {\n  // The environment should exist by now if we are upserting a variable\n  if (!collection?.['x-scalar-environments']?.[environmentName]) {\n    console.error('Environment not found', environmentName)\n    return\n  }\n\n  // Ensure we parse the variable for type safety\n  const parsed = coerceValue(xScalarEnvVarSchema, variable)\n\n  if (index !== undefined) {\n    // Delete the row if the name is empty\n    if (parsed.name === '') {\n      collection['x-scalar-environments'][environmentName].variables.splice(index, 1)\n      return\n    }\n\n    // Update\n    collection['x-scalar-environments'][environmentName].variables[index] = parsed\n  }\n  // Add\n  else {\n    collection['x-scalar-environments'][environmentName].variables.push(parsed)\n  }\n\n  return parsed\n}\n\nexport const deleteEnvironmentVariable = (\n  collection: WorkspaceDocument | Workspace | null,\n  { environmentName, index }: Event<'environment:delete:environment-variable'>,\n) => {\n  if (!collection?.['x-scalar-environments']?.[environmentName]) {\n    console.error('Environment not found', environmentName)\n    return\n  }\n  collection['x-scalar-environments']?.[environmentName]?.variables?.splice(index, 1)\n}\n\nexport const environmentMutatorsFactory = ({\n  workspace,\n  collection,\n}: {\n  workspace: Workspace | null\n  collection: WorkspaceDocument | Workspace | null\n}) => {\n  return {\n    upsertEnvironment: (payload: Event<'environment:upsert:environment'>) =>\n      upsertEnvironment(workspace, collection, payload),\n    deleteEnvironment: (payload: Event<'environment:delete:environment'>) =>\n      deleteEnvironment(workspace, collection, payload),\n    upsertEnvironmentVariable: (payload: Event<'environment:upsert:environment-variable'>) =>\n      upsertEnvironmentVariable(collection, payload),\n    deleteEnvironmentVariable: (payload: Event<'environment:delete:environment-variable'>) =>\n      deleteEnvironmentVariable(collection, payload),\n  }\n}\n"],
  "mappings": "AAEA;AAAA,EAGE;AAAA,EACA;AAAA,OACK;AACP,SAAS,mBAAmB;AAcrB,MAAM,oBAAoB,CAC/B,WACA,YACA,EAAE,iBAAiB,SAAS,mBAAmB,MACZ;AAEnC,MAAI,CAAC,cAAc,CAAC,WAAW;AAC7B;AAAA,EACF;AAEA,MAAI,CAAC,WAAW,uBAAuB,GAAG;AACxC,eAAW,uBAAuB,IAAI,CAAC;AAAA,EACzC;AAGA,QAAM,mBAAmB,CAAC,WAAW,uBAAuB,EAAE,sBAAsB,eAAe;AAGnG,QAAM,SAAS,YAAY,0BAA0B;AAAA,IACnD,GAAG,WAAW,uBAAuB,EAAE,sBAAsB,eAAe;AAAA,IAC5E,GAAG;AAAA,EACL,CAAC;AACD,aAAW,uBAAuB,EAAE,eAAe,IAAI;AAGvD,MAAI,sBAAsB,uBAAuB,iBAAiB;AAChE,WAAO,WAAW,uBAAuB,EAAE,kBAAkB;AAG7D,QAAI,UAAU,6BAA6B,MAAM,oBAAoB;AACnE,gBAAU,6BAA6B,IAAI;AAAA,IAC7C;AAAA,EACF;AAGA,MAAI,kBAAkB;AACpB,cAAU,6BAA6B,IAAI;AAAA,EAC7C;AAEA,SAAO;AACT;AAEO,MAAM,oBAAoB,CAC/B,WACA,YACA,EAAE,gBAAgB,MACf;AACH,MAAI,CAAC,cAAc,CAAC,WAAW;AAC7B;AAAA,EACF;AAEA,SAAO,WAAW,uBAAuB,IAAI,eAAe;AAC9D;AAWO,MAAM,4BAA4B,CACvC,YACA,EAAE,iBAAiB,UAAU,MAAM,MACL;AAE9B,MAAI,CAAC,aAAa,uBAAuB,IAAI,eAAe,GAAG;AAC7D,YAAQ,MAAM,yBAAyB,eAAe;AACtD;AAAA,EACF;AAGA,QAAM,SAAS,YAAY,qBAAqB,QAAQ;AAExD,MAAI,UAAU,QAAW;AAEvB,QAAI,OAAO,SAAS,IAAI;AACtB,iBAAW,uBAAuB,EAAE,eAAe,EAAE,UAAU,OAAO,OAAO,CAAC;AAC9E;AAAA,IACF;AAGA,eAAW,uBAAuB,EAAE,eAAe,EAAE,UAAU,KAAK,IAAI;AAAA,EAC1E,OAEK;AACH,eAAW,uBAAuB,EAAE,eAAe,EAAE,UAAU,KAAK,MAAM;AAAA,EAC5E;AAEA,SAAO;AACT;AAEO,MAAM,4BAA4B,CACvC,YACA,EAAE,iBAAiB,MAAM,MACtB;AACH,MAAI,CAAC,aAAa,uBAAuB,IAAI,eAAe,GAAG;AAC7D,YAAQ,MAAM,yBAAyB,eAAe;AACtD;AAAA,EACF;AACA,aAAW,uBAAuB,IAAI,eAAe,GAAG,WAAW,OAAO,OAAO,CAAC;AACpF;AAEO,MAAM,6BAA6B,CAAC;AAAA,EACzC;AAAA,EACA;AACF,MAGM;AACJ,SAAO;AAAA,IACL,mBAAmB,CAAC,YAClB,kBAAkB,WAAW,YAAY,OAAO;AAAA,IAClD,mBAAmB,CAAC,YAClB,kBAAkB,WAAW,YAAY,OAAO;AAAA,IAClD,2BAA2B,CAAC,YAC1B,0BAA0B,YAAY,OAAO;AAAA,IAC/C,2BAA2B,CAAC,YAC1B,0BAA0B,YAAY,OAAO;AAAA,EACjD;AACF;",
  "names": []
}
