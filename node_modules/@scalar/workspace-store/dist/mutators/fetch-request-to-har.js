const fetchRequestToHar = async ({
  request,
  includeBody = true,
  httpVersion = "HTTP/1.1",
  // Default to 1MB
  bodySizeLimit = 1048576
}) => {
  const url = new URL(request.url);
  const queryString = Array.from(url.searchParams.entries()).map(([name, value]) => ({ name, value }));
  const { headers, headersSize, cookies } = processRequestHeaders(request);
  const mimeType = request.headers.get("content-type")?.split(";")[0]?.trim() ?? "text/plain";
  const bodyDetails = await (async () => {
    if (includeBody && request.body) {
      const details = await processRequestBody(request.clone());
      if (details.size <= bodySizeLimit) {
        return details;
      }
    }
    return { text: "", size: -1 };
  })();
  const harRequest = {
    method: request.method,
    url: request.url,
    httpVersion,
    headers,
    cookies,
    queryString,
    headersSize,
    bodySize: bodyDetails.size,
    postData: "params" in bodyDetails ? {
      mimeType,
      params: bodyDetails.params
    } : {
      mimeType,
      text: bodyDetails.text
    }
  };
  return harRequest;
};
const processRequestBody = async (request) => {
  const formData = await tryGetRequestFormData(request.clone());
  if (formData) {
    return Array.from(formData.entries()).reduce(
      (acc, [name, value]) => {
        if (value instanceof File) {
          const fileName = `@${value.name}`;
          acc.params.push({ name, value: fileName });
          acc.size += fileName.length;
          return acc;
        }
        acc.params.push({ name, value });
        acc.size += value.length;
        return acc;
      },
      { params: [], size: 0 }
    );
  }
  if (request.headers.get("content-type")?.includes("application/octet-stream")) {
    return { text: "", size: -1 };
  }
  const arrayBuffer = await request.arrayBuffer();
  const size = arrayBuffer.byteLength;
  return { size, text: new TextDecoder().decode(arrayBuffer) };
};
async function tryGetRequestFormData(request) {
  if (typeof request.formData !== "function") {
    return null;
  }
  if (request.bodyUsed) {
    return null;
  }
  const contentType = request.headers.get("content-type") ?? "";
  if (!contentType.includes("multipart/form-data") && !contentType.includes("application/x-www-form-urlencoded")) {
    return null;
  }
  try {
    return await request.formData();
  } catch {
    return null;
  }
}
const processRequestHeaders = (request) => {
  return Array.from(request.headers.entries()).reduce(
    (acc, [name, value]) => {
      if (name.toLowerCase() === "cookie") {
        const parsedCookies = parseCookieHeader(value);
        acc.cookies.push(...parsedCookies.cookies);
      } else {
        acc.headers.push({ name, value });
        acc.headersSize += name.length + 2 + value.length + 2;
      }
      return acc;
    },
    { headers: [], headersSize: 0, cookies: [] }
  );
};
const parseCookieHeader = (cookieValue) => {
  return cookieValue.split(";").reduce(
    (acc, part) => {
      const trimmedPart = part.trim();
      const equalIndex = trimmedPart.indexOf("=");
      if (equalIndex === -1) {
        return acc;
      }
      const name = trimmedPart.substring(0, equalIndex).trim();
      const value = trimmedPart.substring(equalIndex + 1).trim();
      acc.cookies.push({ name, value });
      acc.size += name.length + 2 + value.length + 2;
      return acc;
    },
    { cookies: [], size: 0 }
  );
};
export {
  fetchRequestToHar
};
//# sourceMappingURL=fetch-request-to-har.js.map
