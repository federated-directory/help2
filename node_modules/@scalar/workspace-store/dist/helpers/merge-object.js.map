{
  "version": 3,
  "sources": ["../../src/helpers/merge-object.ts"],
  "sourcesContent": ["import { getRaw } from '@scalar/json-magic/magic-proxy'\n\nimport type { UnknownObject } from '@/helpers/general'\n\n/**\n * Deep merges two objects, combining their properties recursively.\n * Handles circular references by tracking visited objects to prevent infinite recursion.\n *\n * \u26A0\uFE0F Note: This operation assumes there are no key collisions between the objects.\n * Use isKeyCollisions() to check for collisions before merging.\n *\n * @param a - Target object to merge into\n * @param b - Source object to merge from\n * @param cache - Set of visited objects to prevent circular reference issues\n * @returns The merged object (mutates and returns a)\n *\n * @example\n * // Simple merge\n * const a = { name: 'John' }\n * const b = { age: 30 }\n * mergeObjects(a, b) // { name: 'John', age: 30 }\n *\n * // Nested merge\n * const a = { user: { name: 'John' } }\n * const b = { user: { age: 30 } }\n * mergeObjects(a, b) // { user: { name: 'John', age: 30 } }\n *\n * // Circular reference safe\n * const obj = { name: 'John' }\n * obj.self = obj\n * const target = { age: 30 }\n * mergeObjects(target, obj) // Safely merges without infinite recursion\n */\nexport const mergeObjects = <R>(\n  a: Record<string, unknown>,\n  b: Record<string, unknown>,\n  /**\n   * By default we overwrite array indexes, our store is built on this assumption when coercing the document\n   * Alternatively we may want to prevent this behaviour when merging with defaults and replace the whole array instead\n   */\n  replaceArrays = false,\n  cache: Set<unknown> = new Set(),\n): R => {\n  for (const key in b) {\n    if (!(key in a)) {\n      a[key] = b[key]\n    } else {\n      const aValue = a[key]\n      const bValue = b[key]\n\n      /** Replace whole array instead of replacing each index */\n      const shouldReplaceArrays = replaceArrays && (Array.isArray(aValue) || Array.isArray(bValue))\n\n      if (\n        typeof aValue === 'object' &&\n        aValue !== null &&\n        typeof bValue === 'object' &&\n        bValue !== null &&\n        !shouldReplaceArrays\n      ) {\n        const rawA = getRaw(aValue as UnknownObject)\n        const rawB = getRaw(bValue as UnknownObject)\n\n        // Check for circular references before recursive merge\n        if (cache.has(rawA) || cache.has(rawB)) {\n          // Skip merging this branch to prevent infinite recursion\n          continue\n        }\n\n        // Add objects to cache before recursive call\n        cache.add(rawA)\n        cache.add(rawB)\n\n        mergeObjects(aValue as Record<string, unknown>, bValue as Record<string, unknown>, replaceArrays, cache)\n      } else {\n        try {\n          a[key] = bValue // Overwrite with b's value if not an object\n        } catch (error) {\n          console.warn(`Issue setting ${key} on object`)\n          console.warn(error)\n        }\n      }\n    }\n  }\n\n  return a as R\n}\n"],
  "mappings": "AAAA,SAAS,cAAc;AAiChB,MAAM,eAAe,CAC1B,GACA,GAKA,gBAAgB,OAChB,QAAsB,oBAAI,IAAI,MACxB;AACN,aAAW,OAAO,GAAG;AACnB,QAAI,EAAE,OAAO,IAAI;AACf,QAAE,GAAG,IAAI,EAAE,GAAG;AAAA,IAChB,OAAO;AACL,YAAM,SAAS,EAAE,GAAG;AACpB,YAAM,SAAS,EAAE,GAAG;AAGpB,YAAM,sBAAsB,kBAAkB,MAAM,QAAQ,MAAM,KAAK,MAAM,QAAQ,MAAM;AAE3F,UACE,OAAO,WAAW,YAClB,WAAW,QACX,OAAO,WAAW,YAClB,WAAW,QACX,CAAC,qBACD;AACA,cAAM,OAAO,OAAO,MAAuB;AAC3C,cAAM,OAAO,OAAO,MAAuB;AAG3C,YAAI,MAAM,IAAI,IAAI,KAAK,MAAM,IAAI,IAAI,GAAG;AAEtC;AAAA,QACF;AAGA,cAAM,IAAI,IAAI;AACd,cAAM,IAAI,IAAI;AAEd,qBAAa,QAAmC,QAAmC,eAAe,KAAK;AAAA,MACzG,OAAO;AACL,YAAI;AACF,YAAE,GAAG,IAAI;AAAA,QACX,SAAS,OAAO;AACd,kBAAQ,KAAK,iBAAiB,GAAG,YAAY;AAC7C,kBAAQ,KAAK,KAAK;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;",
  "names": []
}
