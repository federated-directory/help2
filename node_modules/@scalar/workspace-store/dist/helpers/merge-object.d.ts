/**
 * Deep merges two objects, combining their properties recursively.
 * Handles circular references by tracking visited objects to prevent infinite recursion.
 *
 * ⚠️ Note: This operation assumes there are no key collisions between the objects.
 * Use isKeyCollisions() to check for collisions before merging.
 *
 * @param a - Target object to merge into
 * @param b - Source object to merge from
 * @param cache - Set of visited objects to prevent circular reference issues
 * @returns The merged object (mutates and returns a)
 *
 * @example
 * // Simple merge
 * const a = { name: 'John' }
 * const b = { age: 30 }
 * mergeObjects(a, b) // { name: 'John', age: 30 }
 *
 * // Nested merge
 * const a = { user: { name: 'John' } }
 * const b = { user: { age: 30 } }
 * mergeObjects(a, b) // { user: { name: 'John', age: 30 } }
 *
 * // Circular reference safe
 * const obj = { name: 'John' }
 * obj.self = obj
 * const target = { age: 30 }
 * mergeObjects(target, obj) // Safely merges without infinite recursion
 */
export declare const mergeObjects: <R>(a: Record<string, unknown>, b: Record<string, unknown>, 
/**
 * By default we overwrite array indexes, our store is built on this assumption when coercing the document
 * Alternatively we may want to prevent this behaviour when merging with defaults and replace the whole array instead
 */
replaceArrays?: boolean, cache?: Set<unknown>) => R;
//# sourceMappingURL=merge-object.d.ts.map