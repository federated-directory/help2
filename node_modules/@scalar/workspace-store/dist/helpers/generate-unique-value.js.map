{
  "version": 3,
  "sources": ["../../src/helpers/generate-unique-value.ts"],
  "sourcesContent": ["/**\n * Generates a unique value based on a given default value and a validation function.\n *\n * The process works as follows:\n * 1. Optionally transform (e.g., slugify) the default value using a transformation function.\n * 2. Check if this value is unique by executing the provided validation function.\n * 3. If not unique, repeatedly append an incrementing integer (e.g., \"my-name 1\", \"my-name 2\", ...) and re-check uniqueness,\n *    up to a maximum number of attempts (maxRetries).\n * 4. Returns the first unique value found or undefined if a unique value cannot be generated within the maximum retries.\n *\n * Example:\n * ```ts\n * // Existing names in use\n * const existing = new Set(['foo', 'foo 1', 'foo 2']);\n * const uniqueName = generateUniqueValue({\n *   defaultValue: 'foo',\n *   validation: (value) => !existing.has(value),\n *   // transformation is optional, e.g. (val) => val.toLowerCase().replace(/[^\\w]+/g, '-'),\n *   maxRetries: 10,\n * });\n * // uniqueName === 'foo 3'\n * ```\n */\nexport async function generateUniqueValue({\n  defaultValue,\n  /** Check function to verify the uniqueness of the value */\n  validation,\n  /** Transformation function to transform the default value (such as into a slug) */\n  transformation,\n  /** The maximum number of attempts to create a unique value by incrementing. */\n  maxRetries = 5,\n}: {\n  /**\n   * The original value to base the unique generation upon.\n   * Example: \"workspace\", which may end up producing \"workspace 2\", \"workspace 3\", etc.\n   */\n  defaultValue: string\n\n  /**\n   * Validation function that determines if a generated value is unique.\n   * Should return true if the value is unique; false if not.\n   * Can be asynchronous or synchronous.\n   */\n  validation: (value: string) => Promise<boolean> | boolean\n\n  /**\n   * Optional function to transform the default value before attempting uniqueness.\n   * Example: Transform \"Workspace A\" into \"workspace-a\" to follow a slug schema.\n   */\n  transformation?: (value: string) => string\n\n  /**\n   * The maximum number of attempts to create a unique value by incrementing.\n   * For example, if set to 5: \"foo\", \"foo 1\", \"foo 2\", \"foo 3\", \"foo 4\" will be attempted.\n   */\n  maxRetries: number\n}) {\n  const transformed = transformation?.(defaultValue) ?? defaultValue\n\n  if (await validation(transformed)) {\n    return transformed\n  }\n\n  return incrementValue({\n    value: [transformed, 1],\n    validation,\n    maxRetries,\n    transformation,\n  })\n}\n\n/**\n * Attempts to generate a unique value by appending and incrementing a counter to a base string.\n *\n * On each attempt, appends the next incrementing integer (e.g. \"foo 1\", \"foo 2\", etc.) to the original value,\n * and checks with the validation function whether the candidate value is unique.\n *\n * Continues until a unique value is found, or the maximum number of attempts is reached.\n *\n * Returns the first unique value found, or undefined if a unique value cannot be generated within maxRetries.\n *\n * Example:\n * ```ts\n * const existing = new Set(['bar', 'bar 1']);\n * const result = incrementValue({\n *   value: ['bar', 1],\n *   validation: (val) => !existing.has(val),\n *   maxRetries: 5,\n * });\n * // result === \"bar 2\"\n * ```\n */\nasync function incrementValue({\n  value,\n  validation,\n  maxRetries,\n  attempts = 0,\n  transformation,\n}: {\n  /**\n   * Tuple containing the base value and the starting increment number.\n   * Example: [\"workspace\", 1] will try \"workspace 1\", \"workspace 2\", etc.\n   */\n  value: [string, number] // [base value, next increment]\n\n  /**\n   * Function to validate if the generated value is unique.\n   * Should return true if the value is unique, otherwise false.\n   * Supports both synchronous and asynchronous operation.\n   */\n  validation: (value: string) => Promise<boolean> | boolean\n\n  /**\n   * The maximum number of retry attempts to generate a unique value.\n   * Generation will stop and return undefined if this number is exceeded.\n   */\n  maxRetries: number\n\n  /**\n   * The current attempt count.\n   * Used internally for recursion; users should generally omit this field.\n   */\n  attempts?: number\n\n  /**\n   * Optional function to transform the value before passing it to validation.\n   * E.g., for slugifying a value for URLs.\n   */\n  transformation?: (value: string) => string\n}) {\n  if (attempts >= maxRetries) {\n    return\n  }\n\n  const incremented = value.join(' ')\n  const transformed = transformation?.(incremented) ?? incremented\n\n  if (await validation(transformed)) {\n    return transformed\n  }\n\n  return incrementValue({\n    value: [value[0], value[1] + 1],\n    validation,\n    maxRetries,\n    transformation,\n    attempts: attempts + 1,\n  })\n}\n"],
  "mappings": "AAuBA,eAAsB,oBAAoB;AAAA,EACxC;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA,aAAa;AACf,GAyBG;AACD,QAAM,cAAc,iBAAiB,YAAY,KAAK;AAEtD,MAAI,MAAM,WAAW,WAAW,GAAG;AACjC,WAAO;AAAA,EACT;AAEA,SAAO,eAAe;AAAA,IACpB,OAAO,CAAC,aAAa,CAAC;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACH;AAuBA,eAAe,eAAe;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAW;AAAA,EACX;AACF,GA+BG;AACD,MAAI,YAAY,YAAY;AAC1B;AAAA,EACF;AAEA,QAAM,cAAc,MAAM,KAAK,GAAG;AAClC,QAAM,cAAc,iBAAiB,WAAW,KAAK;AAErD,MAAI,MAAM,WAAW,WAAW,GAAG;AACjC,WAAO;AAAA,EACT;AAEA,SAAO,eAAe;AAAA,IACpB,OAAO,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,WAAW;AAAA,EACvB,CAAC;AACH;",
  "names": []
}
