{
  "version": 3,
  "sources": ["../../src/helpers/general.ts"],
  "sourcesContent": ["export type UnknownObject = Record<string, unknown>\n\n/**\n * Checks if a string is a local reference (starts with #)\n * @param value - The reference string to check\n * @returns true if the string is a local reference, false otherwise\n * @example\n * ```ts\n * isLocalRef('#/components/schemas/User') // true\n * isLocalRef('https://example.com/schema.json') // false\n * isLocalRef('./local-schema.json') // false\n * ```\n */\nexport function isLocalRef(value: string): boolean {\n  return value.startsWith('#')\n}\n\nexport function keyOf<T extends Record<string, unknown>>(value: T) {\n  return Object.keys(value) as (keyof T)[]\n}\n\n/**\n * Deep clones a value using JSON serialization.\n *\n * @param value - The value to deep clone\n * @template T - The type of the value\n * @returns A deep clone of the value\n */\nexport const deepClone = <T>(value: T): T => {\n  return JSON.parse(JSON.stringify(value)) as T\n}\n\n/**\n * Splits an array into two arrays based on a condition.\n *\n * This function takes an array and a predicate function, then returns a tuple containing\n * two arrays: the first contains elements that pass the condition, and the second contains\n * elements that fail the condition.\n *\n * @param array - The array to split\n * @param condition - A predicate function that determines which array each element belongs to\n * @returns A tuple of two arrays: [passingElements, failingElements]\n *\n * @example\n * ```ts\n * const numbers = [1, 2, 3, 4, 5, 6]\n * const [evens, odds] = split(numbers, (n) => n % 2 === 0)\n * // evens: [2, 4, 6]\n * // odds: [1, 3, 5]\n *\n * const words = ['apple', 'banana', 'cherry', 'date']\n * const [longWords, shortWords] = split(words, (word) => word.length > 5)\n * // longWords: ['banana', 'cherry']\n * // shortWords: ['apple', 'date']\n * ```\n */\nexport const split = <T>(array: T[], condition: (element: T) => boolean) => {\n  return array.reduce<[T[], T[]]>(\n    ([pass, fail], item) => {\n      return condition(item) ? [[...pass, item], fail] : [pass, [...fail, item]]\n    },\n    [[], []],\n  )\n}\n\n/**\n * Safely assigns properties from a source object to a target object.\n *\n * This function uses Object.assign to copy enumerable properties from the source object\n * to the target object. It's a type-safe wrapper around Object.assign that ensures\n * the source object is compatible with the target object's type.\n *\n * @param target - The target object to assign properties to\n * @param source - The source object containing properties to assign\n * @template T - The type of the target object\n *\n * @example\n * ```ts\n * const target = { name: 'John', age: 30 }\n * const source = { age: 31, city: 'New York' }\n * safeAssign(target, source)\n * // target is now: { name: 'John', age: 31, city: 'New York' }\n *\n * const config = { theme: 'dark', language: 'en' }\n * const updates = { theme: 'light' }\n * safeAssign(config, updates)\n * // config is now: { theme: 'light', language: 'en' }\n * ```\n */\nexport const safeAssign = <T extends Record<string, unknown>>(target: T, source: Partial<T>) => {\n  Object.assign(target, source)\n}\n"],
  "mappings": "AAaO,SAAS,WAAW,OAAwB;AACjD,SAAO,MAAM,WAAW,GAAG;AAC7B;AAEO,SAAS,MAAyC,OAAU;AACjE,SAAO,OAAO,KAAK,KAAK;AAC1B;AASO,MAAM,YAAY,CAAI,UAAgB;AAC3C,SAAO,KAAK,MAAM,KAAK,UAAU,KAAK,CAAC;AACzC;AA0BO,MAAM,QAAQ,CAAI,OAAY,cAAuC;AAC1E,SAAO,MAAM;AAAA,IACX,CAAC,CAAC,MAAM,IAAI,GAAG,SAAS;AACtB,aAAO,UAAU,IAAI,IAAI,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,GAAG,MAAM,IAAI,CAAC;AAAA,IAC3E;AAAA,IACA,CAAC,CAAC,GAAG,CAAC,CAAC;AAAA,EACT;AACF;AA0BO,MAAM,aAAa,CAAoC,QAAW,WAAuB;AAC9F,SAAO,OAAO,QAAQ,MAAM;AAC9B;",
  "names": []
}
