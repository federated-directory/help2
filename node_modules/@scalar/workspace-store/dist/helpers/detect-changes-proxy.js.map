{
  "version": 3,
  "sources": ["../../src/helpers/detect-changes-proxy.ts"],
  "sourcesContent": ["import { isObject } from '@scalar/helpers/object/is-object'\n\nconst isDetectChangesProxy = Symbol('isDetectChangesProxy')\nconst detectChangesProxyTarget = Symbol('detectChangesProxyTarget')\n\n/**\n * createDetectChangesProxy - Creates a proxy for an object or array that detects and triggers hooks on changes.\n *\n * This proxy enables detection of set operations, triggering optional hooks (onBeforeChange, onAfterChange) with the path and value changed.\n * The proxy can be applied recursively to all nested objects/arrays, and caches proxies to prevent creating multiple proxies for the same object.\n *\n * Example usage:\n *\n * const obj = { foo: 1, bar: { baz: 2 } };\n * const proxy = createDetectChangesProxy(obj, {\n *   hooks: {\n *     onBeforeChange: (path, value) => console.log('Before', path, value),\n *     onAfterChange: (path, value) => console.log('After', path, value),\n *   }\n * });\n * proxy.foo = 42; // Console: Before ['foo'] '42', After ['foo'] '42'\n * proxy.bar.baz = 99; // Console: Before ['bar', 'baz'] '99', After ['bar', 'baz'] '99'\n *\n * @param target The target object or array to wrap in a proxy\n * @param options Optional: hooks for change detection\n * @param args Internal: proxy cache and current property path (used for recursion)\n * @returns The proxied object/array with change detection capabilities\n */\nexport const createDetectChangesProxy = <T>(\n  target: T,\n  options?: {\n    hooks: Partial<{\n      onBeforeChange: (path: string[], value: unknown) => void\n      onAfterChange: (path: string[], value: unknown) => void\n    }>\n  },\n  args: {\n    /** Cache for storing proxies */\n    proxyCache: WeakMap<object, unknown>\n    /** Path for the target */\n    path: string[]\n  } = {\n    proxyCache: new WeakMap<object, unknown>(),\n    path: [],\n  },\n): T => {\n  // Only wrap objects or arrays\n  if (!isObject(target) && !Array.isArray(target)) {\n    return target\n  }\n\n  // Return cached proxy if already created for this target\n  if (args.proxyCache.has(target)) {\n    return args.proxyCache.get(target)! as T\n  }\n\n  const proxy = new Proxy(target, {\n    get(target, prop, receiver) {\n      // Allow identifying if an object is a detect changes proxy\n      if (prop === isDetectChangesProxy) {\n        return true\n      }\n      // Allow access to the original target\n      if (prop === detectChangesProxyTarget) {\n        return target\n      }\n\n      // Recursively wrap property values in the detect changes proxy\n      const value = Reflect.get(target, prop, receiver)\n\n      if (isDetectChangesProxyObject(value)) {\n        return value\n      }\n\n      return createDetectChangesProxy(value, options, { ...args, path: [...args.path, String(prop)] })\n    },\n    set(target, prop, value, receiver) {\n      const path = [...args.path, String(prop)]\n      // Call before-change hook if provided\n      options?.hooks?.onBeforeChange?.(path, value)\n      const result = Reflect.set(target, prop, value, receiver)\n      // Call after-change hook if provided\n      options?.hooks?.onAfterChange?.(path, value)\n      return result\n    },\n  })\n\n  // Cache the proxy for this target\n  args.proxyCache.set(target, proxy)\n  return proxy\n}\n\nexport const isDetectChangesProxyObject = (obj: unknown): boolean => {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    (obj as { [isDetectChangesProxy]: boolean })[isDetectChangesProxy] === true\n  )\n}\n\n/**\n * Returns the raw/original (non-proxy) object if the passed object is a detect-changes proxy.\n * If the object is not a proxy, it returns the same object.\n *\n * @example\n * const proxy = createDetectChangesProxy({ a: 1 });\n * const raw = unpackDetectChangesProxy(proxy); // Gets the original object { a: 1 }\n * const notProxy = { b: 2 };\n * const stillRaw = unpackDetectChangesProxy(notProxy); // Returns { b: 2 }, unchanged\n */\nexport const unpackDetectChangesProxy = <T>(obj: T): T => {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj\n  }\n\n  // If object is a detect-changes proxy, return its underlying target\n  if ((obj as T & { [isDetectChangesProxy]: boolean | undefined })[isDetectChangesProxy]) {\n    return (obj as T & { [detectChangesProxyTarget]: T })[detectChangesProxyTarget]\n  }\n\n  return obj\n}\n"],
  "mappings": "AAAA,SAAS,gBAAgB;AAEzB,MAAM,uBAAuB,OAAO,sBAAsB;AAC1D,MAAM,2BAA2B,OAAO,0BAA0B;AAyB3D,MAAM,2BAA2B,CACtC,QACA,SAMA,OAKI;AAAA,EACF,YAAY,oBAAI,QAAyB;AAAA,EACzC,MAAM,CAAC;AACT,MACM;AAEN,MAAI,CAAC,SAAS,MAAM,KAAK,CAAC,MAAM,QAAQ,MAAM,GAAG;AAC/C,WAAO;AAAA,EACT;AAGA,MAAI,KAAK,WAAW,IAAI,MAAM,GAAG;AAC/B,WAAO,KAAK,WAAW,IAAI,MAAM;AAAA,EACnC;AAEA,QAAM,QAAQ,IAAI,MAAM,QAAQ;AAAA,IAC9B,IAAIA,SAAQ,MAAM,UAAU;AAE1B,UAAI,SAAS,sBAAsB;AACjC,eAAO;AAAA,MACT;AAEA,UAAI,SAAS,0BAA0B;AACrC,eAAOA;AAAA,MACT;AAGA,YAAM,QAAQ,QAAQ,IAAIA,SAAQ,MAAM,QAAQ;AAEhD,UAAI,2BAA2B,KAAK,GAAG;AACrC,eAAO;AAAA,MACT;AAEA,aAAO,yBAAyB,OAAO,SAAS,EAAE,GAAG,MAAM,MAAM,CAAC,GAAG,KAAK,MAAM,OAAO,IAAI,CAAC,EAAE,CAAC;AAAA,IACjG;AAAA,IACA,IAAIA,SAAQ,MAAM,OAAO,UAAU;AACjC,YAAM,OAAO,CAAC,GAAG,KAAK,MAAM,OAAO,IAAI,CAAC;AAExC,eAAS,OAAO,iBAAiB,MAAM,KAAK;AAC5C,YAAM,SAAS,QAAQ,IAAIA,SAAQ,MAAM,OAAO,QAAQ;AAExD,eAAS,OAAO,gBAAgB,MAAM,KAAK;AAC3C,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AAGD,OAAK,WAAW,IAAI,QAAQ,KAAK;AACjC,SAAO;AACT;AAEO,MAAM,6BAA6B,CAAC,QAA0B;AACnE,SACE,OAAO,QAAQ,YACf,QAAQ,QACP,IAA4C,oBAAoB,MAAM;AAE3E;AAYO,MAAM,2BAA2B,CAAI,QAAc;AACxD,MAAI,OAAO,QAAQ,YAAY,QAAQ,MAAM;AAC3C,WAAO;AAAA,EACT;AAGA,MAAK,IAA4D,oBAAoB,GAAG;AACtF,WAAQ,IAA8C,wBAAwB;AAAA,EAChF;AAEA,SAAO;AACT;",
  "names": ["target"]
}
