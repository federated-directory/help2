{
  "version": 3,
  "sources": ["../../src/helpers/overrides-proxy.ts"],
  "sourcesContent": ["import { isObject } from '@scalar/helpers/object/is-object'\n\nconst isOverridesProxy = Symbol('isOverridesProxy')\nexport const getOverridesTarget = Symbol('getOverridesTarget')\n\n/**\n * Recursively makes all properties of a type optional.\n *\n * - If T is an object, recursively applies DeepPartial to each property, making them optional.\n * - Otherwise, T is returned as-is.\n *\n * @template T - The type to make deeply partial (optional).\n * @example\n * type Example = { a: { b: number } }\n * type PartialExample = DeepPartial<Example>\n * // Result: { a?: { b?: number } }\n */\nexport type DeepPartial<T> = T extends object ? { [K in keyof T]?: DeepPartial<T[K]> } : T\n\n/**\n * Creates a proxy object that overlays \"overrides\" on top of a target object.\n *\n * - When reading a property, if an override exists, it is returned; otherwise, the original value is returned.\n * - When writing to a property, if an override exists, it is updated; otherwise, the original object is updated.\n * - This works recursively for nested objects, so overrides can be deeply partial.\n * - Special symbols are used to identify the proxy and to access the original target.\n *\n * @template T - The type of the target object.\n * @param target - The original object to proxy.\n * @param overrides - An optional object containing override values (deeply partial).\n * @returns A proxy object that reflects overrides on top of the target.\n *\n * @example\n * const original = { a: 1, b: { c: 2 } }\n * const overrides = { b: { c: 42 } }\n * const proxy = createOverridesProxy(original, { overrides })\n *\n * console.log(proxy.a) // 1 (from original)\n * console.log(proxy.b.c) // 42 (from overrides)\n *\n * proxy.a = 100\n * console.log(original.a) // 100\n *\n * proxy.b.c = 99\n * console.log(overrides.b.c) // 99\n */\nexport const createOverridesProxy = <T extends Record<string, unknown>>(\n  target: T,\n  options?: {\n    overrides?: DeepPartial<T>\n  },\n  args: {\n    cache: WeakMap<object, any>\n  } = {\n    cache: new WeakMap(),\n  },\n): T => {\n  if (!target || typeof target !== 'object') {\n    return target\n  }\n\n  // Return existing proxy for the same target to ensure referential stability\n  if (args.cache.has(target)) {\n    return args.cache.get(target)!\n  }\n\n  const { overrides } = options ?? {}\n\n  // Proxy handler to intercept get/set operations\n  const handler: ProxyHandler<T> = {\n    get(target, prop, receiver) {\n      // Special symbol to identify this as an overrides proxy\n      if (prop === isOverridesProxy) {\n        return true\n      }\n\n      // Special symbol to access the original target object\n      if (prop === getOverridesTarget) {\n        return target\n      }\n\n      const value = Reflect.get(target, prop, receiver)\n\n      // Return early if the value is already an overrides proxy\n      if (isOverridesProxyObject(value)) {\n        return value\n      }\n\n      // If the value is not an object, return the override if it exists, else the original value\n      if (!isObject(value)) {\n        return Reflect.get(overrides ?? {}, prop) ?? value\n      }\n\n      // For nested objects, recursively create a proxy with the corresponding overrides\n      return createOverridesProxy(value, { overrides: Reflect.get(overrides ?? {}, prop) }, args)\n    },\n\n    set(target, prop, value, receiver) {\n      // Prevent setting special symbols\n      if (prop === isOverridesProxy || prop === getOverridesTarget) {\n        return false\n      }\n\n      // If an override exists for this property, update it\n      const hasOverride = overrides && Reflect.has(overrides, prop)\n\n      if (hasOverride && overrides && typeof overrides === 'object') {\n        ;(overrides as any)[prop] = value\n        return true\n      }\n\n      // Otherwise, update the original target\n      return Reflect.set(target, prop, value, receiver)\n    },\n  }\n\n  // Return the proxy object\n  const proxy = new Proxy<T>(target, handler)\n  args.cache.set(target, proxy)\n  return proxy\n}\n\nexport const isOverridesProxyObject = (obj: unknown): boolean => {\n  return typeof obj === 'object' && obj !== null && (obj as { [isOverridesProxy]: boolean })[isOverridesProxy] === true\n}\n\n/**\n * Unpacks an object from the overrides proxy, returning the original (unproxied) target object.\n * If the input is not an overrides proxy, returns the object as-is.\n *\n * @param input - The potentially proxied object\n * @returns The original unproxied target object or the input object\n */\nexport function unpackOverridesProxy<T>(input: T): T {\n  if (\n    typeof input === 'object' &&\n    input !== null &&\n    (input as T & { [isOverridesProxy]: boolean | undefined })[isOverridesProxy]\n  ) {\n    return (input as T & { [getOverridesTarget]: T })[getOverridesTarget]\n  }\n\n  return input\n}\n"],
  "mappings": "AAAA,SAAS,gBAAgB;AAEzB,MAAM,mBAAmB,OAAO,kBAAkB;AAC3C,MAAM,qBAAqB,OAAO,oBAAoB;AA2CtD,MAAM,uBAAuB,CAClC,QACA,SAGA,OAEI;AAAA,EACF,OAAO,oBAAI,QAAQ;AACrB,MACM;AACN,MAAI,CAAC,UAAU,OAAO,WAAW,UAAU;AACzC,WAAO;AAAA,EACT;AAGA,MAAI,KAAK,MAAM,IAAI,MAAM,GAAG;AAC1B,WAAO,KAAK,MAAM,IAAI,MAAM;AAAA,EAC9B;AAEA,QAAM,EAAE,UAAU,IAAI,WAAW,CAAC;AAGlC,QAAM,UAA2B;AAAA,IAC/B,IAAIA,SAAQ,MAAM,UAAU;AAE1B,UAAI,SAAS,kBAAkB;AAC7B,eAAO;AAAA,MACT;AAGA,UAAI,SAAS,oBAAoB;AAC/B,eAAOA;AAAA,MACT;AAEA,YAAM,QAAQ,QAAQ,IAAIA,SAAQ,MAAM,QAAQ;AAGhD,UAAI,uBAAuB,KAAK,GAAG;AACjC,eAAO;AAAA,MACT;AAGA,UAAI,CAAC,SAAS,KAAK,GAAG;AACpB,eAAO,QAAQ,IAAI,aAAa,CAAC,GAAG,IAAI,KAAK;AAAA,MAC/C;AAGA,aAAO,qBAAqB,OAAO,EAAE,WAAW,QAAQ,IAAI,aAAa,CAAC,GAAG,IAAI,EAAE,GAAG,IAAI;AAAA,IAC5F;AAAA,IAEA,IAAIA,SAAQ,MAAM,OAAO,UAAU;AAEjC,UAAI,SAAS,oBAAoB,SAAS,oBAAoB;AAC5D,eAAO;AAAA,MACT;AAGA,YAAM,cAAc,aAAa,QAAQ,IAAI,WAAW,IAAI;AAE5D,UAAI,eAAe,aAAa,OAAO,cAAc,UAAU;AAC7D;AAAC,QAAC,UAAkB,IAAI,IAAI;AAC5B,eAAO;AAAA,MACT;AAGA,aAAO,QAAQ,IAAIA,SAAQ,MAAM,OAAO,QAAQ;AAAA,IAClD;AAAA,EACF;AAGA,QAAM,QAAQ,IAAI,MAAS,QAAQ,OAAO;AAC1C,OAAK,MAAM,IAAI,QAAQ,KAAK;AAC5B,SAAO;AACT;AAEO,MAAM,yBAAyB,CAAC,QAA0B;AAC/D,SAAO,OAAO,QAAQ,YAAY,QAAQ,QAAS,IAAwC,gBAAgB,MAAM;AACnH;AASO,SAAS,qBAAwB,OAAa;AACnD,MACE,OAAO,UAAU,YACjB,UAAU,QACT,MAA0D,gBAAgB,GAC3E;AACA,WAAQ,MAA0C,kBAAkB;AAAA,EACtE;AAEA,SAAO;AACT;",
  "names": ["target"]
}
