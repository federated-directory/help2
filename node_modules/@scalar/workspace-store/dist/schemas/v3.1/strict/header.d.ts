import type { ExampleObject } from './example.js';
import type { MediaTypeObject } from './media-type.js';
import { type ReferenceType } from './reference.js';
import type { SchemaObject } from './schema.js';
/** Common properties in both sides of the union */
type HeaderBase = {
    /** A brief description of the header. This could contain examples of use. CommonMark syntax MAY be used for rich text representation. */
    description?: string;
    /** Determines whether this header is mandatory. The default value is false. */
    required?: boolean;
    /** Specifies that the header is deprecated and SHOULD be transitioned out of usage. Default value is false. */
    deprecated?: boolean;
};
/** Header object that uses schema */
type HeaderWithSchemaObject = HeaderBase & {
    /** Describes how the header value will be serialized. The default (and only legal value for headers) is "simple". */
    style?: string;
    /** When this is true, header values of type array or object generate a single header whose value is a comma-separated list of the array items or key-value pairs of the map, see Style Examples. For other data types this field has no effect. The default value is false. */
    explode?: boolean;
    /** The schema defining the type used for the header. */
    schema?: ReferenceType<SchemaObject>;
    /** Example of the header's potential value; see Working With Examples. https://swagger.io/specification/#working-with-examples */
    example?: any;
    /** Examples of the header's potential value; see Working With Examples. https://swagger.io/specification/#working-with-examples */
    examples?: Record<string, ReferenceType<ExampleObject>>;
};
/**
 * Describes a single header for HTTP responses and for individual parts in multipart representations; see the relevant Response Object and Encoding Object documentation for restrictions on which headers can be described.
 *
 * The Header Object follows the structure of the Parameter Object, including determining its serialization strategy based on whether schema or content is present, with the following changes:
 *
 *    - name MUST NOT be specified, it is given in the corresponding headers map.
 *    - in MUST NOT be specified, it is implicitly in header.
 *    - All traits that are affected by the location MUST be applicable to a location of header (for example, style). This means that allowEmptyValue and allowReserved MUST NOT be used, and style, if used, MUST be limited to "simple".
 */
export declare const HeaderObjectSchemaDefinition: import("@scalar/typebox").TUnion<[import("@scalar/typebox").TIntersect<[import("@scalar/typebox").TObject<{
    /** A brief description of the header. This could contain examples of use. CommonMark syntax MAY be used for rich text representation. */
    description: import("@scalar/typebox").TOptional<import("@scalar/typebox").TString>;
    /** Determines whether this header is mandatory. The default value is false. */
    required: import("@scalar/typebox").TOptional<import("@scalar/typebox").TBoolean>;
    /** Specifies that the header is deprecated and SHOULD be transitioned out of usage. Default value is false. */
    deprecated: import("@scalar/typebox").TOptional<import("@scalar/typebox").TBoolean>;
}>, import("@scalar/typebox").TObject<{
    /** Describes how the header value will be serialized. The default (and only legal value for headers) is "simple". */
    style: import("@scalar/typebox").TOptional<import("@scalar/typebox").TString>;
    /** When this is true, header values of type array or object generate a single header whose value is a comma-separated list of the array items or key-value pairs of the map, see Style Examples. For other data types this field has no effect. The default value is false. */
    explode: import("@scalar/typebox").TOptional<import("@scalar/typebox").TBoolean>;
    /** The schema defining the type used for the header. */
    schema: import("@scalar/typebox").TOptional<import("@scalar/typebox").TUnion<[import("@scalar/typebox").TRef<"SchemaObject">, import("@scalar/typebox").TIntersect<[import("@scalar/typebox").TIntersect<[import("@scalar/typebox").TObject<{
        $ref: import("@scalar/typebox").TString;
        summary: import("@scalar/typebox").TOptional<import("@scalar/typebox").TString>;
        description: import("@scalar/typebox").TOptional<import("@scalar/typebox").TString>;
    }>, import("@scalar/typebox").TObject<{
        $status: import("@scalar/typebox").TOptional<import("@scalar/typebox").TUnion<[import("@scalar/typebox").TLiteral<"loading">, import("@scalar/typebox").TLiteral<"error">]>>;
        $global: import("@scalar/typebox").TOptional<import("@scalar/typebox").TBoolean>;
    }>]>, import("@scalar/typebox").TObject<{
        '$ref-value': import("@scalar/typebox").TRef<"SchemaObject">;
    }>]>]>>;
    /** Example of the header's potential value; see Working With Examples. https://swagger.io/specification/#working-with-examples */
    example: import("@scalar/typebox").TOptional<import("@scalar/typebox").TAny>;
    /** Examples of the header's potential value; see Working With Examples. https://swagger.io/specification/#working-with-examples */
    examples: import("@scalar/typebox").TOptional<import("@scalar/typebox").TRecord<import("@scalar/typebox").TString, import("@scalar/typebox").TUnion<[import("@scalar/typebox").TRef<"ExampleObject">, import("@scalar/typebox").TIntersect<[import("@scalar/typebox").TIntersect<[import("@scalar/typebox").TObject<{
        $ref: import("@scalar/typebox").TString;
        summary: import("@scalar/typebox").TOptional<import("@scalar/typebox").TString>;
        description: import("@scalar/typebox").TOptional<import("@scalar/typebox").TString>;
    }>, import("@scalar/typebox").TObject<{
        $status: import("@scalar/typebox").TOptional<import("@scalar/typebox").TUnion<[import("@scalar/typebox").TLiteral<"loading">, import("@scalar/typebox").TLiteral<"error">]>>;
        $global: import("@scalar/typebox").TOptional<import("@scalar/typebox").TBoolean>;
    }>]>, import("@scalar/typebox").TObject<{
        '$ref-value': import("@scalar/typebox").TRef<"ExampleObject">;
    }>]>]>>>;
}>]>, import("@scalar/typebox").TIntersect<[import("@scalar/typebox").TObject<{
    /** A brief description of the header. This could contain examples of use. CommonMark syntax MAY be used for rich text representation. */
    description: import("@scalar/typebox").TOptional<import("@scalar/typebox").TString>;
    /** Determines whether this header is mandatory. The default value is false. */
    required: import("@scalar/typebox").TOptional<import("@scalar/typebox").TBoolean>;
    /** Specifies that the header is deprecated and SHOULD be transitioned out of usage. Default value is false. */
    deprecated: import("@scalar/typebox").TOptional<import("@scalar/typebox").TBoolean>;
}>, import("@scalar/typebox").TObject<{
    content: import("@scalar/typebox").TOptional<import("@scalar/typebox").TRecord<import("@scalar/typebox").TString, import("@scalar/typebox").TRef<"MediaTypeObject">>>;
}>]>]>;
/** Header object that uses content */
type HeaderWithContent = HeaderBase & {
    content?: Record<string, MediaTypeObject>;
};
/**
 * Describes a single header for HTTP responses and for individual parts in multipart representations; see the relevant Response Object and Encoding Object documentation for restrictions on which headers can be described.
 *
 * The Header Object follows the structure of the Parameter Object, including determining its serialization strategy based on whether schema or content is present, with the following changes:
 *
 *    - name MUST NOT be specified, it is given in the corresponding headers map.
 *    - in MUST NOT be specified, it is implicitly in header.
 *    - All traits that are affected by the location MUST be applicable to a location of header (for example, style). This means that allowEmptyValue and allowReserved MUST NOT be used, and style, if used, MUST be limited to "simple".
 */
export type HeaderObject = HeaderWithSchemaObject | HeaderWithContent;
export {};
//# sourceMappingURL=header.d.ts.map