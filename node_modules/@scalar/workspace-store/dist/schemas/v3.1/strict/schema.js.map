{
  "version": 3,
  "sources": ["../../../../src/schemas/v3.1/strict/schema.ts"],
  "sourcesContent": ["import { Type } from '@scalar/typebox'\n\nimport { compose } from '@/schemas/compose'\nimport { type XInternal, XInternalSchema } from '@/schemas/extensions/document/x-internal'\nimport { type XScalarIgnore, XScalarIgnoreSchema } from '@/schemas/extensions/document/x-scalar-ignore'\nimport { XTags } from '@/schemas/extensions/document/x-tags'\nimport {\n  type XAdditionalPropertiesName,\n  XAdditionalPropertiesNameSchema,\n} from '@/schemas/extensions/schema/x-additional-properties-name'\nimport { type XEnumDescriptions, XEnumDescriptionsSchema } from '@/schemas/extensions/schema/x-enum-descriptions'\nimport { type XEnumVarNames, XEnumVarNamesSchema } from '@/schemas/extensions/schema/x-enum-varnames'\nimport { type XExamples, XExamplesSchema } from '@/schemas/extensions/schema/x-examples'\nimport { type XVariable, XVariableSchema } from '@/schemas/extensions/schema/x-variable'\nimport type { ExternalDocumentationObject } from '@/schemas/v3.1/strict/external-documentation'\nimport type { XMLObject } from '@/schemas/v3.1/strict/xml'\n\nimport type { DiscriminatorObject } from './discriminator'\nimport {\n  DiscriminatorObjectRef,\n  ExternalDocumentationObjectRef,\n  SchemaObjectRef,\n  XMLObjectRef,\n} from './ref-definitions'\nimport { type ReferenceType, reference } from './reference'\n\nconst schemaOrReference = Type.Union([SchemaObjectRef, reference(SchemaObjectRef)])\n\n/** We use this type to ensure that we are parsing a schema object as every property can be optional */\ntype _InternalType = CoreProperties & {\n  __scalar_: string\n} & Extensions\n\n/**\n * Primitive types that don't have additional validation properties.\n * These types (null, boolean, string, number, integer, object, array) can be used\n * without additional validation constraints.\n *\n * TODO: Type array will actually validate against every union type but we can cross that bridge when we come to it\n */\nconst OtherTypes = Type.Object({\n  type: Type.Union([\n    Type.Literal('null'),\n    Type.Literal('boolean'),\n    Type.Array(\n      Type.Union([\n        Type.Literal('null'),\n        Type.Literal('boolean'),\n        Type.Literal('string'),\n        Type.Literal('number'),\n        Type.Literal('integer'),\n        Type.Literal('object'),\n        Type.Literal('array'),\n      ]),\n    ),\n  ]),\n})\n\ntype OtherType = 'boolean' | 'null' | ('string' | 'number' | 'boolean' | 'object' | 'null' | 'integer' | 'array')[]\n\ntype OtherTypes = CoreProperties & {\n  type: OtherType\n} & Extensions\n\nconst Extensions = compose(\n  XScalarIgnoreSchema,\n  XInternalSchema,\n  XVariableSchema,\n  XExamplesSchema,\n  XEnumDescriptionsSchema,\n  XEnumVarNamesSchema,\n  XAdditionalPropertiesNameSchema,\n  XTags,\n)\n\ntype Extensions = XScalarIgnore &\n  XInternal &\n  XVariable &\n  XEnumDescriptions &\n  XEnumVarNames &\n  XExamples &\n  XAdditionalPropertiesName &\n  XTags\n\nconst CorePropertiesWithSchema = Type.Object({\n  name: Type.Optional(Type.String()),\n  /** A title for the schema. */\n  title: Type.Optional(Type.String()),\n  /** A description of the schema. */\n  description: Type.Optional(Type.String()),\n  /** Default value for the schema. */\n  default: Type.Optional(Type.Unknown()),\n  /** Array of allowed values. */\n  enum: Type.Optional(Type.Array(Type.Unknown())),\n  /** Constant value that must match exactly. */\n  const: Type.Optional(Type.Unknown()),\n  /** Media type for content validation. */\n  contentMediaType: Type.Optional(Type.String()),\n  /** Content encoding. */\n  contentEncoding: Type.Optional(Type.String()),\n  /** Schema for content validation. */\n  contentSchema: Type.Optional(schemaOrReference),\n  /** Whether the schema is deprecated. */\n  deprecated: Type.Optional(Type.Boolean()),\n  /** Adds support for polymorphism. The discriminator is used to determine which of a set of schemas a payload is expected to satisfy. See Composition and Inheritance for more details. */\n  discriminator: Type.Optional(DiscriminatorObjectRef),\n  /** Whether the schema is read-only. */\n  readOnly: Type.Optional(Type.Boolean()),\n  /** Whether the schema is write-only. */\n  writeOnly: Type.Optional(Type.Boolean()),\n  /** This MAY be used only on property schemas. It has no effect on root schemas. Adds additional metadata to describe the XML representation of this property. */\n  xml: Type.Optional(XMLObjectRef),\n  /** Additional external documentation for this schema. */\n  externalDocs: Type.Optional(ExternalDocumentationObjectRef),\n  /**\n   * A free-form field to include an example of an instance for this schema. To represent examples that cannot be naturally represented in JSON or YAML, a string value can be used to contain the example with escaping where necessary.\n   *\n   * @deprecated The example field has been deprecated in favor of the JSON Schema examples keyword. Use of example is discouraged, and later versions of this specification may remove it.\n   */\n  example: Type.Optional(Type.Unknown()),\n  /**\n   * An array of examples of valid instances for this schema. This keyword follows the JSON Schema Draft 2020-12 specification.\n   * Each example should be a valid instance of the schema.\n   */\n  examples: Type.Optional(Type.Array(Type.Unknown())),\n  /** All schemas must be valid. */\n  allOf: Type.Optional(Type.Array(schemaOrReference)),\n  /** Exactly one schema must be valid. */\n  oneOf: Type.Optional(Type.Array(schemaOrReference)),\n  /** At least one schema must be valid. */\n  anyOf: Type.Optional(Type.Array(schemaOrReference)),\n  /** Schema must not be valid. */\n  not: Type.Optional(schemaOrReference),\n})\n\ntype CoreProperties = {\n  name?: string\n  /** A title for the schema. */\n  title?: string\n  /** A description of the schema. */\n  description?: string\n  /** Default value for the schema. */\n  default?: unknown\n  /** Array of allowed values. */\n  enum?: unknown[]\n  /** Constant value that must match exactly. */\n  const?: unknown\n  /** Media type for content validation. */\n  contentMediaType?: string\n  /** Content encoding. */\n  contentEncoding?: string\n  /** Schema for content validation. */\n  contentSchema?: ReferenceType<SchemaObject>\n  /** Whether the schema is deprecated. */\n  deprecated?: boolean\n  /** Adds support for polymorphism. The discriminator is used to determine which of a set of schemas a payload is expected to satisfy. See Composition and Inheritance for more details. */\n  discriminator?: DiscriminatorObject\n  /** Whether the schema is read-only. */\n  readOnly?: boolean\n  /** Whether the schema is write-only. */\n  writeOnly?: boolean\n  /** This MAY be used only on property schemas. It has no effect on root schemas. Adds additional metadata to describe the XML representation of this property. */\n  xml?: XMLObject\n  /** Additional external documentation for this schema. */\n  externalDocs?: ExternalDocumentationObject\n  /**\n   * A free-form field to include an example of an instance for this schema. To represent examples that cannot be naturally represented in JSON or YAML, a string value can be used to contain the example with escaping where necessary.\n   *\n   * @deprecated The example field has been deprecated in favor of the JSON Schema examples keyword. Use of example is discouraged, and later versions of this specification may remove it.\n   */\n  example?: unknown\n  /**\n   * An array of examples of valid instances for this schema. This keyword follows the JSON Schema Draft 2020-12 specification.\n   * Each example should be a valid instance of the schema.\n   */\n  examples?: unknown[]\n  /** All schemas must be valid. */\n  allOf?: ReferenceType<SchemaObject>[]\n  /** Exactly one schema must be valid. */\n  oneOf?: ReferenceType<SchemaObject>[]\n  /** At least one schema must be valid. */\n  anyOf?: ReferenceType<SchemaObject>[]\n  /** Schema must not be valid. */\n  not?: ReferenceType<SchemaObject>\n}\n\n/**\n * Numeric validation properties for number and integer types.\n */\nconst NumericProperties = Type.Object({\n  type: Type.Union([Type.Literal('number'), Type.Literal('integer')]),\n  /** Different subtypes */\n  format: Type.Optional(Type.String()),\n  /** Number must be a multiple of this value. */\n  multipleOf: Type.Optional(Type.Number()),\n  /** Maximum value (inclusive). */\n  maximum: Type.Optional(Type.Number()),\n  /** Maximum value (exclusive). */\n  exclusiveMaximum: Type.Optional(Type.Number({ minimum: 0 })),\n  /** Minimum value (inclusive). */\n  minimum: Type.Optional(Type.Number()),\n  /** Minimum value (exclusive). */\n  exclusiveMinimum: Type.Optional(Type.Number({ minimum: 0 })),\n})\n\ntype NumericObject = CoreProperties & {\n  type: 'number' | 'integer'\n  /** Different subtypes */\n  format?:\n    | 'int8'\n    | 'int16'\n    | 'int32'\n    | 'int64'\n    | 'uint8'\n    | 'uint16'\n    | 'uint32'\n    | 'uint64'\n    | 'double-int'\n    | 'float'\n    | 'double'\n    | 'decimal'\n    | 'decimal128'\n    | 'sf-integer'\n    | 'sf-decimal'\n    | (string & {})\n  /** Number must be a multiple of this value. */\n  multipleOf?: number\n  /** Maximum value (inclusive). */\n  maximum?: number\n  /** Maximum value (exclusive). */\n  exclusiveMaximum?: number\n  /** Minimum value (inclusive). */\n  minimum?: number\n  /** Minimum value (exclusive). */\n  exclusiveMinimum?: number\n} & Extensions\n\n/**\n * String validation properties for string types.\n */\nconst StringValidationProperties = Type.Object({\n  type: Type.Literal('string'),\n  /** Different subtypes - allow any arbitrary string, this negates the purpose of having a union of formats so we type it in typescript instead */\n  format: Type.Optional(Type.String()),\n  /** Maximum string length. */\n  maxLength: Type.Optional(Type.Integer({ minimum: 0 })),\n  /** Minimum string length. */\n  minLength: Type.Optional(Type.Integer({ minimum: 0 })),\n  /** Regular expression pattern. */\n  pattern: Type.Optional(Type.String()),\n})\n\n/**\n * Supported string formats in OpenAPI schemas.\n *\n * These provide better type safety for string format validation. We wanted to allow any arbitrary string\n * in the schema, so we type it in typescript instead. This gives us autocomplete while allowing any string!\n */\ntype StringFormat =\n  // Date and time formats\n  | 'date'\n  | 'date-time'\n  | 'date-time-local'\n  | 'time'\n  | 'time-local'\n  | 'duration'\n  | 'http-date'\n  // Network formats\n  | 'email'\n  | 'idn-email'\n  | 'hostname'\n  | 'idn-hostname'\n  | 'ipv4'\n  | 'ipv6'\n  | 'uri'\n  | 'uri-reference'\n  | 'uri-template'\n  | 'iri'\n  | 'iri-reference'\n  | 'uuid'\n  // Content formats\n  | 'binary'\n  | 'byte'\n  | 'base64url'\n  | 'html'\n  | 'commonmark'\n  | 'password'\n  | 'regex'\n  | 'json-pointer'\n  | 'relative-json-pointer'\n  | 'media-range'\n  // Character formats\n  | 'char'\n  // Structured field string formats\n  | 'sf-string'\n  | 'sf-token'\n  | 'sf-binary'\n  | 'sf-boolean'\n  | (string & {})\n\ntype StringObject = CoreProperties & {\n  type: 'string'\n  /** Different subtypes - allow any arbitrary string, this negates the purpose of having a union of formats so we type it in typescript instead */\n  format?: StringFormat\n  /** Maximum string length. */\n  maxLength?: number\n  /** Minimum string length. */\n  minLength?: number\n  /** Regular expression pattern. */\n  pattern?: string\n} & Extensions\n\nconst ArrayValidationPropertiesWithSchema = Type.Object({\n  type: Type.Literal('array'),\n  /** Maximum number of items in array. */\n  maxItems: Type.Optional(Type.Integer({ minimum: 0 })),\n  /** Minimum number of items in array. */\n  minItems: Type.Optional(Type.Integer({ minimum: 0 })),\n  /** Whether array items must be unique. */\n  uniqueItems: Type.Optional(Type.Boolean()),\n  /** Schema for array items. */\n  items: Type.Optional(schemaOrReference),\n  /** Schema for tuple validation. */\n  prefixItems: Type.Optional(Type.Array(schemaOrReference)),\n})\n\ntype ArrayObject = CoreProperties & {\n  type: 'array'\n  /** Maximum number of items in array. */\n  maxItems?: number\n  /** Minimum number of items in array. */\n  minItems?: number\n  /** Whether array items must be unique. */\n  uniqueItems?: boolean\n  /** Schema for array items. */\n  items?: ReferenceType<SchemaObject>\n  /** Schema for tuple validation. */\n  prefixItems?: ReferenceType<SchemaObject>[]\n} & Extensions\n\nconst ObjectValidationPropertiesWithSchema = Type.Object({\n  type: Type.Literal('object'),\n  /** Maximum number of properties. */\n  maxProperties: Type.Optional(Type.Integer({ minimum: 0 })),\n  /** Minimum number of properties. */\n  minProperties: Type.Optional(Type.Integer({ minimum: 0 })),\n  /** Array of required property names. */\n  required: Type.Optional(Type.Array(Type.String())),\n  /** Object property definitions. */\n  properties: Type.Optional(Type.Record(Type.String(), schemaOrReference)),\n  /** Schema for additional properties. */\n  additionalProperties: Type.Optional(Type.Union([Type.Boolean(), schemaOrReference])),\n  /** Properties matching regex patterns. */\n  patternProperties: Type.Optional(Type.Record(Type.String(), schemaOrReference)),\n})\n\ntype ObjectObject = CoreProperties & {\n  type: 'object'\n  /** Maximum number of properties. */\n  maxProperties?: number\n  /** Minimum number of properties. */\n  minProperties?: number\n  /** Array of required property names. */\n  required?: string[]\n  /** Object property definitions. */\n  properties?: Record<string, ReferenceType<SchemaObject>>\n  /** Schema for additional properties. */\n  additionalProperties?: boolean | ReferenceType<SchemaObject>\n  /** Properties matching regex patterns. */\n  patternProperties?: Record<string, ReferenceType<SchemaObject>>\n} & Extensions\n\n/** Builds the recursive schema schema */\nexport const SchemaObjectSchemaDefinition = Type.Union([\n  // Keep compositions first so they get priority when union is evaluated\n  // Make sure there is always a required field so not all properties are optional\n  // When all properties are optional (1) typescript will not throw any warnings/error and accepts anything\n  // even a non resolved ref and (2) it will match any schema so it will not validate the refs correctly\n  compose(Type.Object({ __scalar_: Type.String() }), CorePropertiesWithSchema, Extensions),\n  compose(OtherTypes, CorePropertiesWithSchema, Extensions),\n  compose(NumericProperties, CorePropertiesWithSchema, Extensions),\n  compose(StringValidationProperties, CorePropertiesWithSchema, Extensions),\n  compose(ObjectValidationPropertiesWithSchema, CorePropertiesWithSchema, Extensions),\n  compose(ArrayValidationPropertiesWithSchema, CorePropertiesWithSchema, Extensions),\n])\n\nexport type SchemaObject = _InternalType | OtherTypes | NumericObject | StringObject | ObjectObject | ArrayObject\n"],
  "mappings": "AAAA,SAAS,YAAY;AAErB,SAAS,eAAe;AACxB,SAAyB,uBAAuB;AAChD,SAA6B,2BAA2B;AACxD,SAAS,aAAa;AACtB;AAAA,EAEE;AAAA,OACK;AACP,SAAiC,+BAA+B;AAChE,SAA6B,2BAA2B;AACxD,SAAyB,uBAAuB;AAChD,SAAyB,uBAAuB;AAKhD;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAA6B,iBAAiB;AAE9C,MAAM,oBAAoB,KAAK,MAAM,CAAC,iBAAiB,UAAU,eAAe,CAAC,CAAC;AAclF,MAAM,aAAa,KAAK,OAAO;AAAA,EAC7B,MAAM,KAAK,MAAM;AAAA,IACf,KAAK,QAAQ,MAAM;AAAA,IACnB,KAAK,QAAQ,SAAS;AAAA,IACtB,KAAK;AAAA,MACH,KAAK,MAAM;AAAA,QACT,KAAK,QAAQ,MAAM;AAAA,QACnB,KAAK,QAAQ,SAAS;AAAA,QACtB,KAAK,QAAQ,QAAQ;AAAA,QACrB,KAAK,QAAQ,QAAQ;AAAA,QACrB,KAAK,QAAQ,SAAS;AAAA,QACtB,KAAK,QAAQ,QAAQ;AAAA,QACrB,KAAK,QAAQ,OAAO;AAAA,MACtB,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACH,CAAC;AAQD,MAAM,aAAa;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAWA,MAAM,2BAA2B,KAAK,OAAO;AAAA,EAC3C,MAAM,KAAK,SAAS,KAAK,OAAO,CAAC;AAAA;AAAA,EAEjC,OAAO,KAAK,SAAS,KAAK,OAAO,CAAC;AAAA;AAAA,EAElC,aAAa,KAAK,SAAS,KAAK,OAAO,CAAC;AAAA;AAAA,EAExC,SAAS,KAAK,SAAS,KAAK,QAAQ,CAAC;AAAA;AAAA,EAErC,MAAM,KAAK,SAAS,KAAK,MAAM,KAAK,QAAQ,CAAC,CAAC;AAAA;AAAA,EAE9C,OAAO,KAAK,SAAS,KAAK,QAAQ,CAAC;AAAA;AAAA,EAEnC,kBAAkB,KAAK,SAAS,KAAK,OAAO,CAAC;AAAA;AAAA,EAE7C,iBAAiB,KAAK,SAAS,KAAK,OAAO,CAAC;AAAA;AAAA,EAE5C,eAAe,KAAK,SAAS,iBAAiB;AAAA;AAAA,EAE9C,YAAY,KAAK,SAAS,KAAK,QAAQ,CAAC;AAAA;AAAA,EAExC,eAAe,KAAK,SAAS,sBAAsB;AAAA;AAAA,EAEnD,UAAU,KAAK,SAAS,KAAK,QAAQ,CAAC;AAAA;AAAA,EAEtC,WAAW,KAAK,SAAS,KAAK,QAAQ,CAAC;AAAA;AAAA,EAEvC,KAAK,KAAK,SAAS,YAAY;AAAA;AAAA,EAE/B,cAAc,KAAK,SAAS,8BAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM1D,SAAS,KAAK,SAAS,KAAK,QAAQ,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAKrC,UAAU,KAAK,SAAS,KAAK,MAAM,KAAK,QAAQ,CAAC,CAAC;AAAA;AAAA,EAElD,OAAO,KAAK,SAAS,KAAK,MAAM,iBAAiB,CAAC;AAAA;AAAA,EAElD,OAAO,KAAK,SAAS,KAAK,MAAM,iBAAiB,CAAC;AAAA;AAAA,EAElD,OAAO,KAAK,SAAS,KAAK,MAAM,iBAAiB,CAAC;AAAA;AAAA,EAElD,KAAK,KAAK,SAAS,iBAAiB;AACtC,CAAC;AAwDD,MAAM,oBAAoB,KAAK,OAAO;AAAA,EACpC,MAAM,KAAK,MAAM,CAAC,KAAK,QAAQ,QAAQ,GAAG,KAAK,QAAQ,SAAS,CAAC,CAAC;AAAA;AAAA,EAElE,QAAQ,KAAK,SAAS,KAAK,OAAO,CAAC;AAAA;AAAA,EAEnC,YAAY,KAAK,SAAS,KAAK,OAAO,CAAC;AAAA;AAAA,EAEvC,SAAS,KAAK,SAAS,KAAK,OAAO,CAAC;AAAA;AAAA,EAEpC,kBAAkB,KAAK,SAAS,KAAK,OAAO,EAAE,SAAS,EAAE,CAAC,CAAC;AAAA;AAAA,EAE3D,SAAS,KAAK,SAAS,KAAK,OAAO,CAAC;AAAA;AAAA,EAEpC,kBAAkB,KAAK,SAAS,KAAK,OAAO,EAAE,SAAS,EAAE,CAAC,CAAC;AAC7D,CAAC;AAqCD,MAAM,6BAA6B,KAAK,OAAO;AAAA,EAC7C,MAAM,KAAK,QAAQ,QAAQ;AAAA;AAAA,EAE3B,QAAQ,KAAK,SAAS,KAAK,OAAO,CAAC;AAAA;AAAA,EAEnC,WAAW,KAAK,SAAS,KAAK,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC;AAAA;AAAA,EAErD,WAAW,KAAK,SAAS,KAAK,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC;AAAA;AAAA,EAErD,SAAS,KAAK,SAAS,KAAK,OAAO,CAAC;AACtC,CAAC;AA8DD,MAAM,sCAAsC,KAAK,OAAO;AAAA,EACtD,MAAM,KAAK,QAAQ,OAAO;AAAA;AAAA,EAE1B,UAAU,KAAK,SAAS,KAAK,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC;AAAA;AAAA,EAEpD,UAAU,KAAK,SAAS,KAAK,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC;AAAA;AAAA,EAEpD,aAAa,KAAK,SAAS,KAAK,QAAQ,CAAC;AAAA;AAAA,EAEzC,OAAO,KAAK,SAAS,iBAAiB;AAAA;AAAA,EAEtC,aAAa,KAAK,SAAS,KAAK,MAAM,iBAAiB,CAAC;AAC1D,CAAC;AAgBD,MAAM,uCAAuC,KAAK,OAAO;AAAA,EACvD,MAAM,KAAK,QAAQ,QAAQ;AAAA;AAAA,EAE3B,eAAe,KAAK,SAAS,KAAK,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC;AAAA;AAAA,EAEzD,eAAe,KAAK,SAAS,KAAK,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC;AAAA;AAAA,EAEzD,UAAU,KAAK,SAAS,KAAK,MAAM,KAAK,OAAO,CAAC,CAAC;AAAA;AAAA,EAEjD,YAAY,KAAK,SAAS,KAAK,OAAO,KAAK,OAAO,GAAG,iBAAiB,CAAC;AAAA;AAAA,EAEvE,sBAAsB,KAAK,SAAS,KAAK,MAAM,CAAC,KAAK,QAAQ,GAAG,iBAAiB,CAAC,CAAC;AAAA;AAAA,EAEnF,mBAAmB,KAAK,SAAS,KAAK,OAAO,KAAK,OAAO,GAAG,iBAAiB,CAAC;AAChF,CAAC;AAmBM,MAAM,+BAA+B,KAAK,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,EAKrD,QAAQ,KAAK,OAAO,EAAE,WAAW,KAAK,OAAO,EAAE,CAAC,GAAG,0BAA0B,UAAU;AAAA,EACvF,QAAQ,YAAY,0BAA0B,UAAU;AAAA,EACxD,QAAQ,mBAAmB,0BAA0B,UAAU;AAAA,EAC/D,QAAQ,4BAA4B,0BAA0B,UAAU;AAAA,EACxE,QAAQ,sCAAsC,0BAA0B,UAAU;AAAA,EAClF,QAAQ,qCAAqC,0BAA0B,UAAU;AACnF,CAAC;",
  "names": []
}
